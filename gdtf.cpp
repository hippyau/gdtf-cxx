// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "gdtf.h"

namespace device
{
  // matrixtype
  // 


  // colorcietype
  // 


  // offsettype
  // 


  // dmxtype
  // 


  // dmxvalue
  // 


  // nametype
  // 


  // dataversion
  // 


  // guidtype
  // 


  // PhysicalUnitEnum
  // 

  PhysicalUnitEnum::
  PhysicalUnitEnum (value v)
  : ::xml_schema::string (_xsd_PhysicalUnitEnum_literals_[v])
  {
  }

  PhysicalUnitEnum::
  PhysicalUnitEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  PhysicalUnitEnum::
  PhysicalUnitEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  PhysicalUnitEnum::
  PhysicalUnitEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  PhysicalUnitEnum::
  PhysicalUnitEnum (const PhysicalUnitEnum& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  PhysicalUnitEnum& PhysicalUnitEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_PhysicalUnitEnum_literals_[v]);

    return *this;
  }


  // MasterEnum
  // 

  MasterEnum::
  MasterEnum (value v)
  : ::xml_schema::string (_xsd_MasterEnum_literals_[v])
  {
  }

  MasterEnum::
  MasterEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  MasterEnum::
  MasterEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  MasterEnum::
  MasterEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  MasterEnum::
  MasterEnum (const MasterEnum& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  MasterEnum& MasterEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_MasterEnum_literals_[v]);

    return *this;
  }


  // PrimitiveTypeEnum
  // 

  PrimitiveTypeEnum::
  PrimitiveTypeEnum (value v)
  : ::xml_schema::string (_xsd_PrimitiveTypeEnum_literals_[v])
  {
  }

  PrimitiveTypeEnum::
  PrimitiveTypeEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  PrimitiveTypeEnum::
  PrimitiveTypeEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  PrimitiveTypeEnum::
  PrimitiveTypeEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  PrimitiveTypeEnum::
  PrimitiveTypeEnum (const PrimitiveTypeEnum& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  PrimitiveTypeEnum& PrimitiveTypeEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_PrimitiveTypeEnum_literals_[v]);

    return *this;
  }


  // LampTypeEnum
  // 

  LampTypeEnum::
  LampTypeEnum (value v)
  : ::xml_schema::string (_xsd_LampTypeEnum_literals_[v])
  {
  }

  LampTypeEnum::
  LampTypeEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  LampTypeEnum::
  LampTypeEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  LampTypeEnum::
  LampTypeEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  LampTypeEnum::
  LampTypeEnum (const LampTypeEnum& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  LampTypeEnum& LampTypeEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_LampTypeEnum_literals_[v]);

    return *this;
  }


  // BeamTypeEnum
  // 

  BeamTypeEnum::
  BeamTypeEnum (value v)
  : ::xml_schema::string (_xsd_BeamTypeEnum_literals_[v])
  {
  }

  BeamTypeEnum::
  BeamTypeEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  BeamTypeEnum::
  BeamTypeEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  BeamTypeEnum::
  BeamTypeEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  BeamTypeEnum::
  BeamTypeEnum (const BeamTypeEnum& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  BeamTypeEnum& BeamTypeEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_BeamTypeEnum_literals_[v]);

    return *this;
  }


  // ColorSpaceEnum
  // 

  ColorSpaceEnum::
  ColorSpaceEnum (value v)
  : ::xml_schema::string (_xsd_ColorSpaceEnum_literals_[v])
  {
  }

  ColorSpaceEnum::
  ColorSpaceEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ColorSpaceEnum::
  ColorSpaceEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ColorSpaceEnum::
  ColorSpaceEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ColorSpaceEnum::
  ColorSpaceEnum (const ColorSpaceEnum& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ColorSpaceEnum& ColorSpaceEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ColorSpaceEnum_literals_[v]);

    return *this;
  }


  // InterpolationToEnum
  // 

  InterpolationToEnum::
  InterpolationToEnum (value v)
  : ::xml_schema::string (_xsd_InterpolationToEnum_literals_[v])
  {
  }

  InterpolationToEnum::
  InterpolationToEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  InterpolationToEnum::
  InterpolationToEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  InterpolationToEnum::
  InterpolationToEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  InterpolationToEnum::
  InterpolationToEnum (const InterpolationToEnum& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  InterpolationToEnum& InterpolationToEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_InterpolationToEnum_literals_[v]);

    return *this;
  }


  // SnapEnum
  // 

  SnapEnum::
  SnapEnum (value v)
  : ::xml_schema::string (_xsd_SnapEnum_literals_[v])
  {
  }

  SnapEnum::
  SnapEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  SnapEnum::
  SnapEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  SnapEnum::
  SnapEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  SnapEnum::
  SnapEnum (const SnapEnum& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  SnapEnum& SnapEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_SnapEnum_literals_[v]);

    return *this;
  }


  // YesNoEnum
  // 

  YesNoEnum::
  YesNoEnum (value v)
  : ::xml_schema::string (_xsd_YesNoEnum_literals_[v])
  {
  }

  YesNoEnum::
  YesNoEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  YesNoEnum::
  YesNoEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  YesNoEnum::
  YesNoEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  YesNoEnum::
  YesNoEnum (const YesNoEnum& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  YesNoEnum& YesNoEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_YesNoEnum_literals_[v]);

    return *this;
  }


  // RelationTypesEnum
  // 

  RelationTypesEnum::
  RelationTypesEnum (value v)
  : ::xml_schema::string (_xsd_RelationTypesEnum_literals_[v])
  {
  }

  RelationTypesEnum::
  RelationTypesEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RelationTypesEnum::
  RelationTypesEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RelationTypesEnum::
  RelationTypesEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RelationTypesEnum::
  RelationTypesEnum (const RelationTypesEnum& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RelationTypesEnum& RelationTypesEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RelationTypesEnum_literals_[v]);

    return *this;
  }


  // RDMParameterTypeEnum
  // 

  RDMParameterTypeEnum::
  RDMParameterTypeEnum (value v)
  : ::xml_schema::string (_xsd_RDMParameterTypeEnum_literals_[v])
  {
  }

  RDMParameterTypeEnum::
  RDMParameterTypeEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterTypeEnum::
  RDMParameterTypeEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterTypeEnum::
  RDMParameterTypeEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterTypeEnum::
  RDMParameterTypeEnum (const RDMParameterTypeEnum& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RDMParameterTypeEnum& RDMParameterTypeEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RDMParameterTypeEnum_literals_[v]);

    return *this;
  }


  // ThresholdOperatorEnum
  // 

  ThresholdOperatorEnum::
  ThresholdOperatorEnum (value v)
  : ::xml_schema::string (_xsd_ThresholdOperatorEnum_literals_[v])
  {
  }

  ThresholdOperatorEnum::
  ThresholdOperatorEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ThresholdOperatorEnum::
  ThresholdOperatorEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ThresholdOperatorEnum::
  ThresholdOperatorEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ThresholdOperatorEnum::
  ThresholdOperatorEnum (const ThresholdOperatorEnum& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ThresholdOperatorEnum& ThresholdOperatorEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ThresholdOperatorEnum_literals_[v]);

    return *this;
  }


  // RDMParameterDataTypeEnum
  // 

  RDMParameterDataTypeEnum::
  RDMParameterDataTypeEnum (value v)
  : ::xml_schema::string (_xsd_RDMParameterDataTypeEnum_literals_[v])
  {
  }

  RDMParameterDataTypeEnum::
  RDMParameterDataTypeEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterDataTypeEnum::
  RDMParameterDataTypeEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterDataTypeEnum::
  RDMParameterDataTypeEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterDataTypeEnum::
  RDMParameterDataTypeEnum (const RDMParameterDataTypeEnum& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RDMParameterDataTypeEnum& RDMParameterDataTypeEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RDMParameterDataTypeEnum_literals_[v]);

    return *this;
  }


  // RDMParameterCommandEnum
  // 

  RDMParameterCommandEnum::
  RDMParameterCommandEnum (value v)
  : ::xml_schema::string (_xsd_RDMParameterCommandEnum_literals_[v])
  {
  }

  RDMParameterCommandEnum::
  RDMParameterCommandEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterCommandEnum::
  RDMParameterCommandEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterCommandEnum::
  RDMParameterCommandEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterCommandEnum::
  RDMParameterCommandEnum (const RDMParameterCommandEnum& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RDMParameterCommandEnum& RDMParameterCommandEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RDMParameterCommandEnum_literals_[v]);

    return *this;
  }


  // RDMSensorTypeEnum
  // 

  RDMSensorTypeEnum::
  RDMSensorTypeEnum (value v)
  : ::xml_schema::string (_xsd_RDMSensorTypeEnum_literals_[v])
  {
  }

  RDMSensorTypeEnum::
  RDMSensorTypeEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RDMSensorTypeEnum::
  RDMSensorTypeEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMSensorTypeEnum::
  RDMSensorTypeEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMSensorTypeEnum::
  RDMSensorTypeEnum (const RDMSensorTypeEnum& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RDMSensorTypeEnum& RDMSensorTypeEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RDMSensorTypeEnum_literals_[v]);

    return *this;
  }


  // RDMParameterSensorUnitEnum
  // 

  RDMParameterSensorUnitEnum::
  RDMParameterSensorUnitEnum (value v)
  : ::xml_schema::string (_xsd_RDMParameterSensorUnitEnum_literals_[v])
  {
  }

  RDMParameterSensorUnitEnum::
  RDMParameterSensorUnitEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterSensorUnitEnum::
  RDMParameterSensorUnitEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterSensorUnitEnum::
  RDMParameterSensorUnitEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterSensorUnitEnum::
  RDMParameterSensorUnitEnum (const RDMParameterSensorUnitEnum& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RDMParameterSensorUnitEnum& RDMParameterSensorUnitEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RDMParameterSensorUnitEnum_literals_[v]);

    return *this;
  }


  // RDMSlotInfoTypeEnum
  // 

  RDMSlotInfoTypeEnum::
  RDMSlotInfoTypeEnum (value v)
  : ::xml_schema::string (_xsd_RDMSlotInfoTypeEnum_literals_[v])
  {
  }

  RDMSlotInfoTypeEnum::
  RDMSlotInfoTypeEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RDMSlotInfoTypeEnum::
  RDMSlotInfoTypeEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMSlotInfoTypeEnum::
  RDMSlotInfoTypeEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMSlotInfoTypeEnum::
  RDMSlotInfoTypeEnum (const RDMSlotInfoTypeEnum& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RDMSlotInfoTypeEnum& RDMSlotInfoTypeEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RDMSlotInfoTypeEnum_literals_[v]);

    return *this;
  }


  // RDMSlotLabelIDEnum
  // 

  RDMSlotLabelIDEnum::
  RDMSlotLabelIDEnum (value v)
  : ::xml_schema::string (_xsd_RDMSlotLabelIDEnum_literals_[v])
  {
  }

  RDMSlotLabelIDEnum::
  RDMSlotLabelIDEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RDMSlotLabelIDEnum::
  RDMSlotLabelIDEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMSlotLabelIDEnum::
  RDMSlotLabelIDEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMSlotLabelIDEnum::
  RDMSlotLabelIDEnum (const RDMSlotLabelIDEnum& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RDMSlotLabelIDEnum& RDMSlotLabelIDEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RDMSlotLabelIDEnum_literals_[v]);

    return *this;
  }


  // RDMParameterSensorUnitPrefixEnum
  // 

  RDMParameterSensorUnitPrefixEnum::
  RDMParameterSensorUnitPrefixEnum (value v)
  : ::xml_schema::string (_xsd_RDMParameterSensorUnitPrefixEnum_literals_[v])
  {
  }

  RDMParameterSensorUnitPrefixEnum::
  RDMParameterSensorUnitPrefixEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterSensorUnitPrefixEnum::
  RDMParameterSensorUnitPrefixEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterSensorUnitPrefixEnum::
  RDMParameterSensorUnitPrefixEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RDMParameterSensorUnitPrefixEnum::
  RDMParameterSensorUnitPrefixEnum (const RDMParameterSensorUnitPrefixEnum& v,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RDMParameterSensorUnitPrefixEnum& RDMParameterSensorUnitPrefixEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RDMParameterSensorUnitPrefixEnum_literals_[v]);

    return *this;
  }


  // CESEnum
  // 

  CESEnum::
  CESEnum (value v)
  : ::xml_schema::string (_xsd_CESEnum_literals_[v])
  {
  }

  CESEnum::
  CESEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  CESEnum::
  CESEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  CESEnum::
  CESEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  CESEnum::
  CESEnum (const CESEnum& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  CESEnum& CESEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_CESEnum_literals_[v]);

    return *this;
  }


  // AttributeEnum
  // 

  AttributeEnum::
  AttributeEnum (value v)
  : ::xml_schema::string (_xsd_AttributeEnum_literals_[v])
  {
  }

  AttributeEnum::
  AttributeEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  AttributeEnum::
  AttributeEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  AttributeEnum::
  AttributeEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  AttributeEnum::
  AttributeEnum (const AttributeEnum& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  AttributeEnum& AttributeEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_AttributeEnum_literals_[v]);

    return *this;
  }


  // GDTF
  // 

  const GDTF::FixtureType_type& GDTF::
  FixtureType () const
  {
    return this->FixtureType_.get ();
  }

  GDTF::FixtureType_type& GDTF::
  FixtureType ()
  {
    return this->FixtureType_.get ();
  }

  void GDTF::
  FixtureType (const FixtureType_type& x)
  {
    this->FixtureType_.set (x);
  }

  void GDTF::
  FixtureType (::std::unique_ptr< FixtureType_type > x)
  {
    this->FixtureType_.set (std::move (x));
  }

  const GDTF::DataVersion_type& GDTF::
  DataVersion () const
  {
    return this->DataVersion_.get ();
  }

  GDTF::DataVersion_type& GDTF::
  DataVersion ()
  {
    return this->DataVersion_.get ();
  }

  void GDTF::
  DataVersion (const DataVersion_type& x)
  {
    this->DataVersion_.set (x);
  }

  void GDTF::
  DataVersion (::std::unique_ptr< DataVersion_type > x)
  {
    this->DataVersion_.set (std::move (x));
  }


  // FixtureType
  // 

  const FixtureType::AttributeDefinitions_sequence& FixtureType::
  AttributeDefinitions () const
  {
    return this->AttributeDefinitions_;
  }

  FixtureType::AttributeDefinitions_sequence& FixtureType::
  AttributeDefinitions ()
  {
    return this->AttributeDefinitions_;
  }

  void FixtureType::
  AttributeDefinitions (const AttributeDefinitions_sequence& s)
  {
    this->AttributeDefinitions_ = s;
  }

  const FixtureType::Wheels_sequence& FixtureType::
  Wheels () const
  {
    return this->Wheels_;
  }

  FixtureType::Wheels_sequence& FixtureType::
  Wheels ()
  {
    return this->Wheels_;
  }

  void FixtureType::
  Wheels (const Wheels_sequence& s)
  {
    this->Wheels_ = s;
  }

  const FixtureType::PhysicalDescriptions_sequence& FixtureType::
  PhysicalDescriptions () const
  {
    return this->PhysicalDescriptions_;
  }

  FixtureType::PhysicalDescriptions_sequence& FixtureType::
  PhysicalDescriptions ()
  {
    return this->PhysicalDescriptions_;
  }

  void FixtureType::
  PhysicalDescriptions (const PhysicalDescriptions_sequence& s)
  {
    this->PhysicalDescriptions_ = s;
  }

  const FixtureType::Models_sequence& FixtureType::
  Models () const
  {
    return this->Models_;
  }

  FixtureType::Models_sequence& FixtureType::
  Models ()
  {
    return this->Models_;
  }

  void FixtureType::
  Models (const Models_sequence& s)
  {
    this->Models_ = s;
  }

  const FixtureType::Geometries_sequence& FixtureType::
  Geometries () const
  {
    return this->Geometries_;
  }

  FixtureType::Geometries_sequence& FixtureType::
  Geometries ()
  {
    return this->Geometries_;
  }

  void FixtureType::
  Geometries (const Geometries_sequence& s)
  {
    this->Geometries_ = s;
  }

  const FixtureType::DMXModes_sequence& FixtureType::
  DMXModes () const
  {
    return this->DMXModes_;
  }

  FixtureType::DMXModes_sequence& FixtureType::
  DMXModes ()
  {
    return this->DMXModes_;
  }

  void FixtureType::
  DMXModes (const DMXModes_sequence& s)
  {
    this->DMXModes_ = s;
  }

  const FixtureType::Revisions_sequence& FixtureType::
  Revisions () const
  {
    return this->Revisions_;
  }

  FixtureType::Revisions_sequence& FixtureType::
  Revisions ()
  {
    return this->Revisions_;
  }

  void FixtureType::
  Revisions (const Revisions_sequence& s)
  {
    this->Revisions_ = s;
  }

  const FixtureType::FTPresets_sequence& FixtureType::
  FTPresets () const
  {
    return this->FTPresets_;
  }

  FixtureType::FTPresets_sequence& FixtureType::
  FTPresets ()
  {
    return this->FTPresets_;
  }

  void FixtureType::
  FTPresets (const FTPresets_sequence& s)
  {
    this->FTPresets_ = s;
  }

  const FixtureType::Protocols_sequence& FixtureType::
  Protocols () const
  {
    return this->Protocols_;
  }

  FixtureType::Protocols_sequence& FixtureType::
  Protocols ()
  {
    return this->Protocols_;
  }

  void FixtureType::
  Protocols (const Protocols_sequence& s)
  {
    this->Protocols_ = s;
  }

  const FixtureType::Name_type& FixtureType::
  Name () const
  {
    return this->Name_.get ();
  }

  FixtureType::Name_type& FixtureType::
  Name ()
  {
    return this->Name_.get ();
  }

  void FixtureType::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void FixtureType::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const FixtureType::ShortName_optional& FixtureType::
  ShortName () const
  {
    return this->ShortName_;
  }

  FixtureType::ShortName_optional& FixtureType::
  ShortName ()
  {
    return this->ShortName_;
  }

  void FixtureType::
  ShortName (const ShortName_type& x)
  {
    this->ShortName_.set (x);
  }

  void FixtureType::
  ShortName (const ShortName_optional& x)
  {
    this->ShortName_ = x;
  }

  void FixtureType::
  ShortName (::std::unique_ptr< ShortName_type > x)
  {
    this->ShortName_.set (std::move (x));
  }

  const FixtureType::LongName_optional& FixtureType::
  LongName () const
  {
    return this->LongName_;
  }

  FixtureType::LongName_optional& FixtureType::
  LongName ()
  {
    return this->LongName_;
  }

  void FixtureType::
  LongName (const LongName_type& x)
  {
    this->LongName_.set (x);
  }

  void FixtureType::
  LongName (const LongName_optional& x)
  {
    this->LongName_ = x;
  }

  void FixtureType::
  LongName (::std::unique_ptr< LongName_type > x)
  {
    this->LongName_.set (std::move (x));
  }

  const FixtureType::Manufacturer_type& FixtureType::
  Manufacturer () const
  {
    return this->Manufacturer_.get ();
  }

  FixtureType::Manufacturer_type& FixtureType::
  Manufacturer ()
  {
    return this->Manufacturer_.get ();
  }

  void FixtureType::
  Manufacturer (const Manufacturer_type& x)
  {
    this->Manufacturer_.set (x);
  }

  void FixtureType::
  Manufacturer (::std::unique_ptr< Manufacturer_type > x)
  {
    this->Manufacturer_.set (std::move (x));
  }

  const FixtureType::Description_type& FixtureType::
  Description () const
  {
    return this->Description_.get ();
  }

  FixtureType::Description_type& FixtureType::
  Description ()
  {
    return this->Description_.get ();
  }

  void FixtureType::
  Description (const Description_type& x)
  {
    this->Description_.set (x);
  }

  void FixtureType::
  Description (::std::unique_ptr< Description_type > x)
  {
    this->Description_.set (std::move (x));
  }

  const FixtureType::FixtureTypeID_type& FixtureType::
  FixtureTypeID () const
  {
    return this->FixtureTypeID_.get ();
  }

  FixtureType::FixtureTypeID_type& FixtureType::
  FixtureTypeID ()
  {
    return this->FixtureTypeID_.get ();
  }

  void FixtureType::
  FixtureTypeID (const FixtureTypeID_type& x)
  {
    this->FixtureTypeID_.set (x);
  }

  void FixtureType::
  FixtureTypeID (::std::unique_ptr< FixtureTypeID_type > x)
  {
    this->FixtureTypeID_.set (std::move (x));
  }

  const FixtureType::Thumbnail_optional& FixtureType::
  Thumbnail () const
  {
    return this->Thumbnail_;
  }

  FixtureType::Thumbnail_optional& FixtureType::
  Thumbnail ()
  {
    return this->Thumbnail_;
  }

  void FixtureType::
  Thumbnail (const Thumbnail_type& x)
  {
    this->Thumbnail_.set (x);
  }

  void FixtureType::
  Thumbnail (const Thumbnail_optional& x)
  {
    this->Thumbnail_ = x;
  }

  void FixtureType::
  Thumbnail (::std::unique_ptr< Thumbnail_type > x)
  {
    this->Thumbnail_.set (std::move (x));
  }

  const FixtureType::RefFT_optional& FixtureType::
  RefFT () const
  {
    return this->RefFT_;
  }

  FixtureType::RefFT_optional& FixtureType::
  RefFT ()
  {
    return this->RefFT_;
  }

  void FixtureType::
  RefFT (const RefFT_type& x)
  {
    this->RefFT_.set (x);
  }

  void FixtureType::
  RefFT (const RefFT_optional& x)
  {
    this->RefFT_ = x;
  }

  void FixtureType::
  RefFT (::std::unique_ptr< RefFT_type > x)
  {
    this->RefFT_.set (std::move (x));
  }


  // Wheels
  // 

  const Wheels::Wheel_sequence& Wheels::
  Wheel () const
  {
    return this->Wheel_;
  }

  Wheels::Wheel_sequence& Wheels::
  Wheel ()
  {
    return this->Wheel_;
  }

  void Wheels::
  Wheel (const Wheel_sequence& s)
  {
    this->Wheel_ = s;
  }


  // Wheel
  // 

  const Wheel::Slot_sequence& Wheel::
  Slot () const
  {
    return this->Slot_;
  }

  Wheel::Slot_sequence& Wheel::
  Slot ()
  {
    return this->Slot_;
  }

  void Wheel::
  Slot (const Slot_sequence& s)
  {
    this->Slot_ = s;
  }

  const Wheel::Name_optional& Wheel::
  Name () const
  {
    return this->Name_;
  }

  Wheel::Name_optional& Wheel::
  Name ()
  {
    return this->Name_;
  }

  void Wheel::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Wheel::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void Wheel::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }


  // Slot
  // 

  const Slot::Facet_sequence& Slot::
  Facet () const
  {
    return this->Facet_;
  }

  Slot::Facet_sequence& Slot::
  Facet ()
  {
    return this->Facet_;
  }

  void Slot::
  Facet (const Facet_sequence& s)
  {
    this->Facet_ = s;
  }

  const Slot::Name_type& Slot::
  Name () const
  {
    return this->Name_.get ();
  }

  Slot::Name_type& Slot::
  Name ()
  {
    return this->Name_.get ();
  }

  void Slot::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Slot::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const Slot::Color_optional& Slot::
  Color () const
  {
    return this->Color_;
  }

  Slot::Color_optional& Slot::
  Color ()
  {
    return this->Color_;
  }

  void Slot::
  Color (const Color_type& x)
  {
    this->Color_.set (x);
  }

  void Slot::
  Color (const Color_optional& x)
  {
    this->Color_ = x;
  }

  void Slot::
  Color (::std::unique_ptr< Color_type > x)
  {
    this->Color_.set (std::move (x));
  }

  const Slot::Filter_optional& Slot::
  Filter () const
  {
    return this->Filter_;
  }

  Slot::Filter_optional& Slot::
  Filter ()
  {
    return this->Filter_;
  }

  void Slot::
  Filter (const Filter_type& x)
  {
    this->Filter_.set (x);
  }

  void Slot::
  Filter (const Filter_optional& x)
  {
    this->Filter_ = x;
  }

  void Slot::
  Filter (::std::unique_ptr< Filter_type > x)
  {
    this->Filter_.set (std::move (x));
  }

  const Slot::MediaFileName_optional& Slot::
  MediaFileName () const
  {
    return this->MediaFileName_;
  }

  Slot::MediaFileName_optional& Slot::
  MediaFileName ()
  {
    return this->MediaFileName_;
  }

  void Slot::
  MediaFileName (const MediaFileName_type& x)
  {
    this->MediaFileName_.set (x);
  }

  void Slot::
  MediaFileName (const MediaFileName_optional& x)
  {
    this->MediaFileName_ = x;
  }

  void Slot::
  MediaFileName (::std::unique_ptr< MediaFileName_type > x)
  {
    this->MediaFileName_.set (std::move (x));
  }


  // Facet
  // 

  const Facet::Color_optional& Facet::
  Color () const
  {
    return this->Color_;
  }

  Facet::Color_optional& Facet::
  Color ()
  {
    return this->Color_;
  }

  void Facet::
  Color (const Color_type& x)
  {
    this->Color_.set (x);
  }

  void Facet::
  Color (const Color_optional& x)
  {
    this->Color_ = x;
  }

  void Facet::
  Color (::std::unique_ptr< Color_type > x)
  {
    this->Color_.set (std::move (x));
  }

  const Facet::Rotation_optional& Facet::
  Rotation () const
  {
    return this->Rotation_;
  }

  Facet::Rotation_optional& Facet::
  Rotation ()
  {
    return this->Rotation_;
  }

  void Facet::
  Rotation (const Rotation_type& x)
  {
    this->Rotation_.set (x);
  }

  void Facet::
  Rotation (const Rotation_optional& x)
  {
    this->Rotation_ = x;
  }

  void Facet::
  Rotation (::std::unique_ptr< Rotation_type > x)
  {
    this->Rotation_.set (std::move (x));
  }


  // Models
  // 

  const Models::Model_sequence& Models::
  Model () const
  {
    return this->Model_;
  }

  Models::Model_sequence& Models::
  Model ()
  {
    return this->Model_;
  }

  void Models::
  Model (const Model_sequence& s)
  {
    this->Model_ = s;
  }


  // Model
  // 

  const Model::Name_type& Model::
  Name () const
  {
    return this->Name_.get ();
  }

  Model::Name_type& Model::
  Name ()
  {
    return this->Name_.get ();
  }

  void Model::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Model::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const Model::Length_optional& Model::
  Length () const
  {
    return this->Length_;
  }

  Model::Length_optional& Model::
  Length ()
  {
    return this->Length_;
  }

  void Model::
  Length (const Length_type& x)
  {
    this->Length_.set (x);
  }

  void Model::
  Length (const Length_optional& x)
  {
    this->Length_ = x;
  }

  const Model::Width_optional& Model::
  Width () const
  {
    return this->Width_;
  }

  Model::Width_optional& Model::
  Width ()
  {
    return this->Width_;
  }

  void Model::
  Width (const Width_type& x)
  {
    this->Width_.set (x);
  }

  void Model::
  Width (const Width_optional& x)
  {
    this->Width_ = x;
  }

  const Model::Height_optional& Model::
  Height () const
  {
    return this->Height_;
  }

  Model::Height_optional& Model::
  Height ()
  {
    return this->Height_;
  }

  void Model::
  Height (const Height_type& x)
  {
    this->Height_.set (x);
  }

  void Model::
  Height (const Height_optional& x)
  {
    this->Height_ = x;
  }

  const Model::PrimitiveType_optional& Model::
  PrimitiveType () const
  {
    return this->PrimitiveType_;
  }

  Model::PrimitiveType_optional& Model::
  PrimitiveType ()
  {
    return this->PrimitiveType_;
  }

  void Model::
  PrimitiveType (const PrimitiveType_type& x)
  {
    this->PrimitiveType_.set (x);
  }

  void Model::
  PrimitiveType (const PrimitiveType_optional& x)
  {
    this->PrimitiveType_ = x;
  }

  void Model::
  PrimitiveType (::std::unique_ptr< PrimitiveType_type > x)
  {
    this->PrimitiveType_.set (std::move (x));
  }

  const Model::File_optional& Model::
  File () const
  {
    return this->File_;
  }

  Model::File_optional& Model::
  File ()
  {
    return this->File_;
  }

  void Model::
  File (const File_type& x)
  {
    this->File_.set (x);
  }

  void Model::
  File (const File_optional& x)
  {
    this->File_ = x;
  }

  void Model::
  File (::std::unique_ptr< File_type > x)
  {
    this->File_.set (std::move (x));
  }


  // Geometries
  // 

  const Geometries::Geometry_sequence& Geometries::
  Geometry () const
  {
    return this->Geometry_;
  }

  Geometries::Geometry_sequence& Geometries::
  Geometry ()
  {
    return this->Geometry_;
  }

  void Geometries::
  Geometry (const Geometry_sequence& s)
  {
    this->Geometry_ = s;
  }

  const Geometries::Axis_sequence& Geometries::
  Axis () const
  {
    return this->Axis_;
  }

  Geometries::Axis_sequence& Geometries::
  Axis ()
  {
    return this->Axis_;
  }

  void Geometries::
  Axis (const Axis_sequence& s)
  {
    this->Axis_ = s;
  }

  const Geometries::FilterBeam_sequence& Geometries::
  FilterBeam () const
  {
    return this->FilterBeam_;
  }

  Geometries::FilterBeam_sequence& Geometries::
  FilterBeam ()
  {
    return this->FilterBeam_;
  }

  void Geometries::
  FilterBeam (const FilterBeam_sequence& s)
  {
    this->FilterBeam_ = s;
  }

  const Geometries::FilterColor_sequence& Geometries::
  FilterColor () const
  {
    return this->FilterColor_;
  }

  Geometries::FilterColor_sequence& Geometries::
  FilterColor ()
  {
    return this->FilterColor_;
  }

  void Geometries::
  FilterColor (const FilterColor_sequence& s)
  {
    this->FilterColor_ = s;
  }

  const Geometries::FilterGobo_sequence& Geometries::
  FilterGobo () const
  {
    return this->FilterGobo_;
  }

  Geometries::FilterGobo_sequence& Geometries::
  FilterGobo ()
  {
    return this->FilterGobo_;
  }

  void Geometries::
  FilterGobo (const FilterGobo_sequence& s)
  {
    this->FilterGobo_ = s;
  }

  const Geometries::FilterShaper_sequence& Geometries::
  FilterShaper () const
  {
    return this->FilterShaper_;
  }

  Geometries::FilterShaper_sequence& Geometries::
  FilterShaper ()
  {
    return this->FilterShaper_;
  }

  void Geometries::
  FilterShaper (const FilterShaper_sequence& s)
  {
    this->FilterShaper_ = s;
  }

  const Geometries::Beam_sequence& Geometries::
  Beam () const
  {
    return this->Beam_;
  }

  Geometries::Beam_sequence& Geometries::
  Beam ()
  {
    return this->Beam_;
  }

  void Geometries::
  Beam (const Beam_sequence& s)
  {
    this->Beam_ = s;
  }

  const Geometries::GeometryReference_sequence& Geometries::
  GeometryReference () const
  {
    return this->GeometryReference_;
  }

  Geometries::GeometryReference_sequence& Geometries::
  GeometryReference ()
  {
    return this->GeometryReference_;
  }

  void Geometries::
  GeometryReference (const GeometryReference_sequence& s)
  {
    this->GeometryReference_ = s;
  }


  // Geometry
  // 

  const Geometry::Geometry1_sequence& Geometry::
  Geometry1 () const
  {
    return this->Geometry1_;
  }

  Geometry::Geometry1_sequence& Geometry::
  Geometry1 ()
  {
    return this->Geometry1_;
  }

  void Geometry::
  Geometry1 (const Geometry1_sequence& s)
  {
    this->Geometry1_ = s;
  }

  const Geometry::Axis_sequence& Geometry::
  Axis () const
  {
    return this->Axis_;
  }

  Geometry::Axis_sequence& Geometry::
  Axis ()
  {
    return this->Axis_;
  }

  void Geometry::
  Axis (const Axis_sequence& s)
  {
    this->Axis_ = s;
  }

  const Geometry::FilterBeam_sequence& Geometry::
  FilterBeam () const
  {
    return this->FilterBeam_;
  }

  Geometry::FilterBeam_sequence& Geometry::
  FilterBeam ()
  {
    return this->FilterBeam_;
  }

  void Geometry::
  FilterBeam (const FilterBeam_sequence& s)
  {
    this->FilterBeam_ = s;
  }

  const Geometry::FilterColor_sequence& Geometry::
  FilterColor () const
  {
    return this->FilterColor_;
  }

  Geometry::FilterColor_sequence& Geometry::
  FilterColor ()
  {
    return this->FilterColor_;
  }

  void Geometry::
  FilterColor (const FilterColor_sequence& s)
  {
    this->FilterColor_ = s;
  }

  const Geometry::FilterGobo_sequence& Geometry::
  FilterGobo () const
  {
    return this->FilterGobo_;
  }

  Geometry::FilterGobo_sequence& Geometry::
  FilterGobo ()
  {
    return this->FilterGobo_;
  }

  void Geometry::
  FilterGobo (const FilterGobo_sequence& s)
  {
    this->FilterGobo_ = s;
  }

  const Geometry::FilterShaper_sequence& Geometry::
  FilterShaper () const
  {
    return this->FilterShaper_;
  }

  Geometry::FilterShaper_sequence& Geometry::
  FilterShaper ()
  {
    return this->FilterShaper_;
  }

  void Geometry::
  FilterShaper (const FilterShaper_sequence& s)
  {
    this->FilterShaper_ = s;
  }

  const Geometry::Beam_sequence& Geometry::
  Beam () const
  {
    return this->Beam_;
  }

  Geometry::Beam_sequence& Geometry::
  Beam ()
  {
    return this->Beam_;
  }

  void Geometry::
  Beam (const Beam_sequence& s)
  {
    this->Beam_ = s;
  }

  const Geometry::GeometryReference_sequence& Geometry::
  GeometryReference () const
  {
    return this->GeometryReference_;
  }

  Geometry::GeometryReference_sequence& Geometry::
  GeometryReference ()
  {
    return this->GeometryReference_;
  }

  void Geometry::
  GeometryReference (const GeometryReference_sequence& s)
  {
    this->GeometryReference_ = s;
  }

  const Geometry::Name_optional& Geometry::
  Name () const
  {
    return this->Name_;
  }

  Geometry::Name_optional& Geometry::
  Name ()
  {
    return this->Name_;
  }

  void Geometry::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Geometry::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void Geometry::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const Geometry::Model_optional& Geometry::
  Model () const
  {
    return this->Model_;
  }

  Geometry::Model_optional& Geometry::
  Model ()
  {
    return this->Model_;
  }

  void Geometry::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void Geometry::
  Model (const Model_optional& x)
  {
    this->Model_ = x;
  }

  void Geometry::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }

  const Geometry::Position_optional& Geometry::
  Position () const
  {
    return this->Position_;
  }

  Geometry::Position_optional& Geometry::
  Position ()
  {
    return this->Position_;
  }

  void Geometry::
  Position (const Position_type& x)
  {
    this->Position_.set (x);
  }

  void Geometry::
  Position (const Position_optional& x)
  {
    this->Position_ = x;
  }

  void Geometry::
  Position (::std::unique_ptr< Position_type > x)
  {
    this->Position_.set (std::move (x));
  }


  // Axis
  // 

  const Axis::Geometry_sequence& Axis::
  Geometry () const
  {
    return this->Geometry_;
  }

  Axis::Geometry_sequence& Axis::
  Geometry ()
  {
    return this->Geometry_;
  }

  void Axis::
  Geometry (const Geometry_sequence& s)
  {
    this->Geometry_ = s;
  }

  const Axis::Axis1_sequence& Axis::
  Axis1 () const
  {
    return this->Axis1_;
  }

  Axis::Axis1_sequence& Axis::
  Axis1 ()
  {
    return this->Axis1_;
  }

  void Axis::
  Axis1 (const Axis1_sequence& s)
  {
    this->Axis1_ = s;
  }

  const Axis::FilterBeam_sequence& Axis::
  FilterBeam () const
  {
    return this->FilterBeam_;
  }

  Axis::FilterBeam_sequence& Axis::
  FilterBeam ()
  {
    return this->FilterBeam_;
  }

  void Axis::
  FilterBeam (const FilterBeam_sequence& s)
  {
    this->FilterBeam_ = s;
  }

  const Axis::FilterColor_sequence& Axis::
  FilterColor () const
  {
    return this->FilterColor_;
  }

  Axis::FilterColor_sequence& Axis::
  FilterColor ()
  {
    return this->FilterColor_;
  }

  void Axis::
  FilterColor (const FilterColor_sequence& s)
  {
    this->FilterColor_ = s;
  }

  const Axis::FilterGobo_sequence& Axis::
  FilterGobo () const
  {
    return this->FilterGobo_;
  }

  Axis::FilterGobo_sequence& Axis::
  FilterGobo ()
  {
    return this->FilterGobo_;
  }

  void Axis::
  FilterGobo (const FilterGobo_sequence& s)
  {
    this->FilterGobo_ = s;
  }

  const Axis::FilterShaper_sequence& Axis::
  FilterShaper () const
  {
    return this->FilterShaper_;
  }

  Axis::FilterShaper_sequence& Axis::
  FilterShaper ()
  {
    return this->FilterShaper_;
  }

  void Axis::
  FilterShaper (const FilterShaper_sequence& s)
  {
    this->FilterShaper_ = s;
  }

  const Axis::Beam_sequence& Axis::
  Beam () const
  {
    return this->Beam_;
  }

  Axis::Beam_sequence& Axis::
  Beam ()
  {
    return this->Beam_;
  }

  void Axis::
  Beam (const Beam_sequence& s)
  {
    this->Beam_ = s;
  }

  const Axis::GeometryReference_sequence& Axis::
  GeometryReference () const
  {
    return this->GeometryReference_;
  }

  Axis::GeometryReference_sequence& Axis::
  GeometryReference ()
  {
    return this->GeometryReference_;
  }

  void Axis::
  GeometryReference (const GeometryReference_sequence& s)
  {
    this->GeometryReference_ = s;
  }

  const Axis::Name_optional& Axis::
  Name () const
  {
    return this->Name_;
  }

  Axis::Name_optional& Axis::
  Name ()
  {
    return this->Name_;
  }

  void Axis::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Axis::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void Axis::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const Axis::Model_optional& Axis::
  Model () const
  {
    return this->Model_;
  }

  Axis::Model_optional& Axis::
  Model ()
  {
    return this->Model_;
  }

  void Axis::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void Axis::
  Model (const Model_optional& x)
  {
    this->Model_ = x;
  }

  void Axis::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }

  const Axis::Position_optional& Axis::
  Position () const
  {
    return this->Position_;
  }

  Axis::Position_optional& Axis::
  Position ()
  {
    return this->Position_;
  }

  void Axis::
  Position (const Position_type& x)
  {
    this->Position_.set (x);
  }

  void Axis::
  Position (const Position_optional& x)
  {
    this->Position_ = x;
  }

  void Axis::
  Position (::std::unique_ptr< Position_type > x)
  {
    this->Position_.set (std::move (x));
  }


  // FilterBeam
  // 

  const FilterBeam::Geometry_sequence& FilterBeam::
  Geometry () const
  {
    return this->Geometry_;
  }

  FilterBeam::Geometry_sequence& FilterBeam::
  Geometry ()
  {
    return this->Geometry_;
  }

  void FilterBeam::
  Geometry (const Geometry_sequence& s)
  {
    this->Geometry_ = s;
  }

  const FilterBeam::Axis_sequence& FilterBeam::
  Axis () const
  {
    return this->Axis_;
  }

  FilterBeam::Axis_sequence& FilterBeam::
  Axis ()
  {
    return this->Axis_;
  }

  void FilterBeam::
  Axis (const Axis_sequence& s)
  {
    this->Axis_ = s;
  }

  const FilterBeam::FilterBeam1_sequence& FilterBeam::
  FilterBeam1 () const
  {
    return this->FilterBeam1_;
  }

  FilterBeam::FilterBeam1_sequence& FilterBeam::
  FilterBeam1 ()
  {
    return this->FilterBeam1_;
  }

  void FilterBeam::
  FilterBeam1 (const FilterBeam1_sequence& s)
  {
    this->FilterBeam1_ = s;
  }

  const FilterBeam::FilterColor_sequence& FilterBeam::
  FilterColor () const
  {
    return this->FilterColor_;
  }

  FilterBeam::FilterColor_sequence& FilterBeam::
  FilterColor ()
  {
    return this->FilterColor_;
  }

  void FilterBeam::
  FilterColor (const FilterColor_sequence& s)
  {
    this->FilterColor_ = s;
  }

  const FilterBeam::FilterGobo_sequence& FilterBeam::
  FilterGobo () const
  {
    return this->FilterGobo_;
  }

  FilterBeam::FilterGobo_sequence& FilterBeam::
  FilterGobo ()
  {
    return this->FilterGobo_;
  }

  void FilterBeam::
  FilterGobo (const FilterGobo_sequence& s)
  {
    this->FilterGobo_ = s;
  }

  const FilterBeam::FilterShaper_sequence& FilterBeam::
  FilterShaper () const
  {
    return this->FilterShaper_;
  }

  FilterBeam::FilterShaper_sequence& FilterBeam::
  FilterShaper ()
  {
    return this->FilterShaper_;
  }

  void FilterBeam::
  FilterShaper (const FilterShaper_sequence& s)
  {
    this->FilterShaper_ = s;
  }

  const FilterBeam::Beam_sequence& FilterBeam::
  Beam () const
  {
    return this->Beam_;
  }

  FilterBeam::Beam_sequence& FilterBeam::
  Beam ()
  {
    return this->Beam_;
  }

  void FilterBeam::
  Beam (const Beam_sequence& s)
  {
    this->Beam_ = s;
  }

  const FilterBeam::GeometryReference_sequence& FilterBeam::
  GeometryReference () const
  {
    return this->GeometryReference_;
  }

  FilterBeam::GeometryReference_sequence& FilterBeam::
  GeometryReference ()
  {
    return this->GeometryReference_;
  }

  void FilterBeam::
  GeometryReference (const GeometryReference_sequence& s)
  {
    this->GeometryReference_ = s;
  }

  const FilterBeam::Name_optional& FilterBeam::
  Name () const
  {
    return this->Name_;
  }

  FilterBeam::Name_optional& FilterBeam::
  Name ()
  {
    return this->Name_;
  }

  void FilterBeam::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void FilterBeam::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void FilterBeam::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const FilterBeam::Model_optional& FilterBeam::
  Model () const
  {
    return this->Model_;
  }

  FilterBeam::Model_optional& FilterBeam::
  Model ()
  {
    return this->Model_;
  }

  void FilterBeam::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void FilterBeam::
  Model (const Model_optional& x)
  {
    this->Model_ = x;
  }

  void FilterBeam::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }

  const FilterBeam::Position_optional& FilterBeam::
  Position () const
  {
    return this->Position_;
  }

  FilterBeam::Position_optional& FilterBeam::
  Position ()
  {
    return this->Position_;
  }

  void FilterBeam::
  Position (const Position_type& x)
  {
    this->Position_.set (x);
  }

  void FilterBeam::
  Position (const Position_optional& x)
  {
    this->Position_ = x;
  }

  void FilterBeam::
  Position (::std::unique_ptr< Position_type > x)
  {
    this->Position_.set (std::move (x));
  }


  // FilterColor
  // 

  const FilterColor::Geometry_sequence& FilterColor::
  Geometry () const
  {
    return this->Geometry_;
  }

  FilterColor::Geometry_sequence& FilterColor::
  Geometry ()
  {
    return this->Geometry_;
  }

  void FilterColor::
  Geometry (const Geometry_sequence& s)
  {
    this->Geometry_ = s;
  }

  const FilterColor::Axis_sequence& FilterColor::
  Axis () const
  {
    return this->Axis_;
  }

  FilterColor::Axis_sequence& FilterColor::
  Axis ()
  {
    return this->Axis_;
  }

  void FilterColor::
  Axis (const Axis_sequence& s)
  {
    this->Axis_ = s;
  }

  const FilterColor::FilterBeam_sequence& FilterColor::
  FilterBeam () const
  {
    return this->FilterBeam_;
  }

  FilterColor::FilterBeam_sequence& FilterColor::
  FilterBeam ()
  {
    return this->FilterBeam_;
  }

  void FilterColor::
  FilterBeam (const FilterBeam_sequence& s)
  {
    this->FilterBeam_ = s;
  }

  const FilterColor::FilterColor1_sequence& FilterColor::
  FilterColor1 () const
  {
    return this->FilterColor1_;
  }

  FilterColor::FilterColor1_sequence& FilterColor::
  FilterColor1 ()
  {
    return this->FilterColor1_;
  }

  void FilterColor::
  FilterColor1 (const FilterColor1_sequence& s)
  {
    this->FilterColor1_ = s;
  }

  const FilterColor::FilterGobo_sequence& FilterColor::
  FilterGobo () const
  {
    return this->FilterGobo_;
  }

  FilterColor::FilterGobo_sequence& FilterColor::
  FilterGobo ()
  {
    return this->FilterGobo_;
  }

  void FilterColor::
  FilterGobo (const FilterGobo_sequence& s)
  {
    this->FilterGobo_ = s;
  }

  const FilterColor::FilterShaper_sequence& FilterColor::
  FilterShaper () const
  {
    return this->FilterShaper_;
  }

  FilterColor::FilterShaper_sequence& FilterColor::
  FilterShaper ()
  {
    return this->FilterShaper_;
  }

  void FilterColor::
  FilterShaper (const FilterShaper_sequence& s)
  {
    this->FilterShaper_ = s;
  }

  const FilterColor::Beam_sequence& FilterColor::
  Beam () const
  {
    return this->Beam_;
  }

  FilterColor::Beam_sequence& FilterColor::
  Beam ()
  {
    return this->Beam_;
  }

  void FilterColor::
  Beam (const Beam_sequence& s)
  {
    this->Beam_ = s;
  }

  const FilterColor::GeometryReference_sequence& FilterColor::
  GeometryReference () const
  {
    return this->GeometryReference_;
  }

  FilterColor::GeometryReference_sequence& FilterColor::
  GeometryReference ()
  {
    return this->GeometryReference_;
  }

  void FilterColor::
  GeometryReference (const GeometryReference_sequence& s)
  {
    this->GeometryReference_ = s;
  }

  const FilterColor::Name_optional& FilterColor::
  Name () const
  {
    return this->Name_;
  }

  FilterColor::Name_optional& FilterColor::
  Name ()
  {
    return this->Name_;
  }

  void FilterColor::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void FilterColor::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void FilterColor::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const FilterColor::Model_optional& FilterColor::
  Model () const
  {
    return this->Model_;
  }

  FilterColor::Model_optional& FilterColor::
  Model ()
  {
    return this->Model_;
  }

  void FilterColor::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void FilterColor::
  Model (const Model_optional& x)
  {
    this->Model_ = x;
  }

  void FilterColor::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }

  const FilterColor::Position_optional& FilterColor::
  Position () const
  {
    return this->Position_;
  }

  FilterColor::Position_optional& FilterColor::
  Position ()
  {
    return this->Position_;
  }

  void FilterColor::
  Position (const Position_type& x)
  {
    this->Position_.set (x);
  }

  void FilterColor::
  Position (const Position_optional& x)
  {
    this->Position_ = x;
  }

  void FilterColor::
  Position (::std::unique_ptr< Position_type > x)
  {
    this->Position_.set (std::move (x));
  }


  // FilterGobo
  // 

  const FilterGobo::Geometry_sequence& FilterGobo::
  Geometry () const
  {
    return this->Geometry_;
  }

  FilterGobo::Geometry_sequence& FilterGobo::
  Geometry ()
  {
    return this->Geometry_;
  }

  void FilterGobo::
  Geometry (const Geometry_sequence& s)
  {
    this->Geometry_ = s;
  }

  const FilterGobo::Axis_sequence& FilterGobo::
  Axis () const
  {
    return this->Axis_;
  }

  FilterGobo::Axis_sequence& FilterGobo::
  Axis ()
  {
    return this->Axis_;
  }

  void FilterGobo::
  Axis (const Axis_sequence& s)
  {
    this->Axis_ = s;
  }

  const FilterGobo::FilterBeam_sequence& FilterGobo::
  FilterBeam () const
  {
    return this->FilterBeam_;
  }

  FilterGobo::FilterBeam_sequence& FilterGobo::
  FilterBeam ()
  {
    return this->FilterBeam_;
  }

  void FilterGobo::
  FilterBeam (const FilterBeam_sequence& s)
  {
    this->FilterBeam_ = s;
  }

  const FilterGobo::FilterColor_sequence& FilterGobo::
  FilterColor () const
  {
    return this->FilterColor_;
  }

  FilterGobo::FilterColor_sequence& FilterGobo::
  FilterColor ()
  {
    return this->FilterColor_;
  }

  void FilterGobo::
  FilterColor (const FilterColor_sequence& s)
  {
    this->FilterColor_ = s;
  }

  const FilterGobo::FilterGobo1_sequence& FilterGobo::
  FilterGobo1 () const
  {
    return this->FilterGobo1_;
  }

  FilterGobo::FilterGobo1_sequence& FilterGobo::
  FilterGobo1 ()
  {
    return this->FilterGobo1_;
  }

  void FilterGobo::
  FilterGobo1 (const FilterGobo1_sequence& s)
  {
    this->FilterGobo1_ = s;
  }

  const FilterGobo::FilterShaper_sequence& FilterGobo::
  FilterShaper () const
  {
    return this->FilterShaper_;
  }

  FilterGobo::FilterShaper_sequence& FilterGobo::
  FilterShaper ()
  {
    return this->FilterShaper_;
  }

  void FilterGobo::
  FilterShaper (const FilterShaper_sequence& s)
  {
    this->FilterShaper_ = s;
  }

  const FilterGobo::Beam_sequence& FilterGobo::
  Beam () const
  {
    return this->Beam_;
  }

  FilterGobo::Beam_sequence& FilterGobo::
  Beam ()
  {
    return this->Beam_;
  }

  void FilterGobo::
  Beam (const Beam_sequence& s)
  {
    this->Beam_ = s;
  }

  const FilterGobo::GeometryReference_sequence& FilterGobo::
  GeometryReference () const
  {
    return this->GeometryReference_;
  }

  FilterGobo::GeometryReference_sequence& FilterGobo::
  GeometryReference ()
  {
    return this->GeometryReference_;
  }

  void FilterGobo::
  GeometryReference (const GeometryReference_sequence& s)
  {
    this->GeometryReference_ = s;
  }

  const FilterGobo::Name_optional& FilterGobo::
  Name () const
  {
    return this->Name_;
  }

  FilterGobo::Name_optional& FilterGobo::
  Name ()
  {
    return this->Name_;
  }

  void FilterGobo::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void FilterGobo::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void FilterGobo::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const FilterGobo::Model_optional& FilterGobo::
  Model () const
  {
    return this->Model_;
  }

  FilterGobo::Model_optional& FilterGobo::
  Model ()
  {
    return this->Model_;
  }

  void FilterGobo::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void FilterGobo::
  Model (const Model_optional& x)
  {
    this->Model_ = x;
  }

  void FilterGobo::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }

  const FilterGobo::Position_optional& FilterGobo::
  Position () const
  {
    return this->Position_;
  }

  FilterGobo::Position_optional& FilterGobo::
  Position ()
  {
    return this->Position_;
  }

  void FilterGobo::
  Position (const Position_type& x)
  {
    this->Position_.set (x);
  }

  void FilterGobo::
  Position (const Position_optional& x)
  {
    this->Position_ = x;
  }

  void FilterGobo::
  Position (::std::unique_ptr< Position_type > x)
  {
    this->Position_.set (std::move (x));
  }


  // FilterShaper
  // 

  const FilterShaper::Geometry_sequence& FilterShaper::
  Geometry () const
  {
    return this->Geometry_;
  }

  FilterShaper::Geometry_sequence& FilterShaper::
  Geometry ()
  {
    return this->Geometry_;
  }

  void FilterShaper::
  Geometry (const Geometry_sequence& s)
  {
    this->Geometry_ = s;
  }

  const FilterShaper::Axis_sequence& FilterShaper::
  Axis () const
  {
    return this->Axis_;
  }

  FilterShaper::Axis_sequence& FilterShaper::
  Axis ()
  {
    return this->Axis_;
  }

  void FilterShaper::
  Axis (const Axis_sequence& s)
  {
    this->Axis_ = s;
  }

  const FilterShaper::FilterBeam_sequence& FilterShaper::
  FilterBeam () const
  {
    return this->FilterBeam_;
  }

  FilterShaper::FilterBeam_sequence& FilterShaper::
  FilterBeam ()
  {
    return this->FilterBeam_;
  }

  void FilterShaper::
  FilterBeam (const FilterBeam_sequence& s)
  {
    this->FilterBeam_ = s;
  }

  const FilterShaper::FilterColor_sequence& FilterShaper::
  FilterColor () const
  {
    return this->FilterColor_;
  }

  FilterShaper::FilterColor_sequence& FilterShaper::
  FilterColor ()
  {
    return this->FilterColor_;
  }

  void FilterShaper::
  FilterColor (const FilterColor_sequence& s)
  {
    this->FilterColor_ = s;
  }

  const FilterShaper::FilterGobo_sequence& FilterShaper::
  FilterGobo () const
  {
    return this->FilterGobo_;
  }

  FilterShaper::FilterGobo_sequence& FilterShaper::
  FilterGobo ()
  {
    return this->FilterGobo_;
  }

  void FilterShaper::
  FilterGobo (const FilterGobo_sequence& s)
  {
    this->FilterGobo_ = s;
  }

  const FilterShaper::FilterShaper1_sequence& FilterShaper::
  FilterShaper1 () const
  {
    return this->FilterShaper1_;
  }

  FilterShaper::FilterShaper1_sequence& FilterShaper::
  FilterShaper1 ()
  {
    return this->FilterShaper1_;
  }

  void FilterShaper::
  FilterShaper1 (const FilterShaper1_sequence& s)
  {
    this->FilterShaper1_ = s;
  }

  const FilterShaper::Beam_sequence& FilterShaper::
  Beam () const
  {
    return this->Beam_;
  }

  FilterShaper::Beam_sequence& FilterShaper::
  Beam ()
  {
    return this->Beam_;
  }

  void FilterShaper::
  Beam (const Beam_sequence& s)
  {
    this->Beam_ = s;
  }

  const FilterShaper::GeometryReference_sequence& FilterShaper::
  GeometryReference () const
  {
    return this->GeometryReference_;
  }

  FilterShaper::GeometryReference_sequence& FilterShaper::
  GeometryReference ()
  {
    return this->GeometryReference_;
  }

  void FilterShaper::
  GeometryReference (const GeometryReference_sequence& s)
  {
    this->GeometryReference_ = s;
  }

  const FilterShaper::Name_optional& FilterShaper::
  Name () const
  {
    return this->Name_;
  }

  FilterShaper::Name_optional& FilterShaper::
  Name ()
  {
    return this->Name_;
  }

  void FilterShaper::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void FilterShaper::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void FilterShaper::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const FilterShaper::Model_optional& FilterShaper::
  Model () const
  {
    return this->Model_;
  }

  FilterShaper::Model_optional& FilterShaper::
  Model ()
  {
    return this->Model_;
  }

  void FilterShaper::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void FilterShaper::
  Model (const Model_optional& x)
  {
    this->Model_ = x;
  }

  void FilterShaper::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }

  const FilterShaper::Position_optional& FilterShaper::
  Position () const
  {
    return this->Position_;
  }

  FilterShaper::Position_optional& FilterShaper::
  Position ()
  {
    return this->Position_;
  }

  void FilterShaper::
  Position (const Position_type& x)
  {
    this->Position_.set (x);
  }

  void FilterShaper::
  Position (const Position_optional& x)
  {
    this->Position_ = x;
  }

  void FilterShaper::
  Position (::std::unique_ptr< Position_type > x)
  {
    this->Position_.set (std::move (x));
  }


  // Beam
  // 

  const Beam::Geometry_sequence& Beam::
  Geometry () const
  {
    return this->Geometry_;
  }

  Beam::Geometry_sequence& Beam::
  Geometry ()
  {
    return this->Geometry_;
  }

  void Beam::
  Geometry (const Geometry_sequence& s)
  {
    this->Geometry_ = s;
  }

  const Beam::Axis_sequence& Beam::
  Axis () const
  {
    return this->Axis_;
  }

  Beam::Axis_sequence& Beam::
  Axis ()
  {
    return this->Axis_;
  }

  void Beam::
  Axis (const Axis_sequence& s)
  {
    this->Axis_ = s;
  }

  const Beam::FilterBeam_sequence& Beam::
  FilterBeam () const
  {
    return this->FilterBeam_;
  }

  Beam::FilterBeam_sequence& Beam::
  FilterBeam ()
  {
    return this->FilterBeam_;
  }

  void Beam::
  FilterBeam (const FilterBeam_sequence& s)
  {
    this->FilterBeam_ = s;
  }

  const Beam::FilterColor_sequence& Beam::
  FilterColor () const
  {
    return this->FilterColor_;
  }

  Beam::FilterColor_sequence& Beam::
  FilterColor ()
  {
    return this->FilterColor_;
  }

  void Beam::
  FilterColor (const FilterColor_sequence& s)
  {
    this->FilterColor_ = s;
  }

  const Beam::FilterGobo_sequence& Beam::
  FilterGobo () const
  {
    return this->FilterGobo_;
  }

  Beam::FilterGobo_sequence& Beam::
  FilterGobo ()
  {
    return this->FilterGobo_;
  }

  void Beam::
  FilterGobo (const FilterGobo_sequence& s)
  {
    this->FilterGobo_ = s;
  }

  const Beam::FilterShaper_sequence& Beam::
  FilterShaper () const
  {
    return this->FilterShaper_;
  }

  Beam::FilterShaper_sequence& Beam::
  FilterShaper ()
  {
    return this->FilterShaper_;
  }

  void Beam::
  FilterShaper (const FilterShaper_sequence& s)
  {
    this->FilterShaper_ = s;
  }

  const Beam::Beam1_sequence& Beam::
  Beam1 () const
  {
    return this->Beam1_;
  }

  Beam::Beam1_sequence& Beam::
  Beam1 ()
  {
    return this->Beam1_;
  }

  void Beam::
  Beam1 (const Beam1_sequence& s)
  {
    this->Beam1_ = s;
  }

  const Beam::GeometryReference_sequence& Beam::
  GeometryReference () const
  {
    return this->GeometryReference_;
  }

  Beam::GeometryReference_sequence& Beam::
  GeometryReference ()
  {
    return this->GeometryReference_;
  }

  void Beam::
  GeometryReference (const GeometryReference_sequence& s)
  {
    this->GeometryReference_ = s;
  }

  const Beam::Name_type& Beam::
  Name () const
  {
    return this->Name_.get ();
  }

  Beam::Name_type& Beam::
  Name ()
  {
    return this->Name_.get ();
  }

  void Beam::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Beam::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const Beam::Model_type& Beam::
  Model () const
  {
    return this->Model_.get ();
  }

  Beam::Model_type& Beam::
  Model ()
  {
    return this->Model_.get ();
  }

  void Beam::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void Beam::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }

  const Beam::Position_type& Beam::
  Position () const
  {
    return this->Position_.get ();
  }

  Beam::Position_type& Beam::
  Position ()
  {
    return this->Position_.get ();
  }

  void Beam::
  Position (const Position_type& x)
  {
    this->Position_.set (x);
  }

  void Beam::
  Position (::std::unique_ptr< Position_type > x)
  {
    this->Position_.set (std::move (x));
  }

  const Beam::LampType_optional& Beam::
  LampType () const
  {
    return this->LampType_;
  }

  Beam::LampType_optional& Beam::
  LampType ()
  {
    return this->LampType_;
  }

  void Beam::
  LampType (const LampType_type& x)
  {
    this->LampType_.set (x);
  }

  void Beam::
  LampType (const LampType_optional& x)
  {
    this->LampType_ = x;
  }

  void Beam::
  LampType (::std::unique_ptr< LampType_type > x)
  {
    this->LampType_.set (std::move (x));
  }

  const Beam::PowerConsumption_optional& Beam::
  PowerConsumption () const
  {
    return this->PowerConsumption_;
  }

  Beam::PowerConsumption_optional& Beam::
  PowerConsumption ()
  {
    return this->PowerConsumption_;
  }

  void Beam::
  PowerConsumption (const PowerConsumption_type& x)
  {
    this->PowerConsumption_.set (x);
  }

  void Beam::
  PowerConsumption (const PowerConsumption_optional& x)
  {
    this->PowerConsumption_ = x;
  }

  const Beam::LuminousFlux_optional& Beam::
  LuminousFlux () const
  {
    return this->LuminousFlux_;
  }

  Beam::LuminousFlux_optional& Beam::
  LuminousFlux ()
  {
    return this->LuminousFlux_;
  }

  void Beam::
  LuminousFlux (const LuminousFlux_type& x)
  {
    this->LuminousFlux_.set (x);
  }

  void Beam::
  LuminousFlux (const LuminousFlux_optional& x)
  {
    this->LuminousFlux_ = x;
  }

  const Beam::ColorTemperature_optional& Beam::
  ColorTemperature () const
  {
    return this->ColorTemperature_;
  }

  Beam::ColorTemperature_optional& Beam::
  ColorTemperature ()
  {
    return this->ColorTemperature_;
  }

  void Beam::
  ColorTemperature (const ColorTemperature_type& x)
  {
    this->ColorTemperature_.set (x);
  }

  void Beam::
  ColorTemperature (const ColorTemperature_optional& x)
  {
    this->ColorTemperature_ = x;
  }

  const Beam::BeamAngle_optional& Beam::
  BeamAngle () const
  {
    return this->BeamAngle_;
  }

  Beam::BeamAngle_optional& Beam::
  BeamAngle ()
  {
    return this->BeamAngle_;
  }

  void Beam::
  BeamAngle (const BeamAngle_type& x)
  {
    this->BeamAngle_.set (x);
  }

  void Beam::
  BeamAngle (const BeamAngle_optional& x)
  {
    this->BeamAngle_ = x;
  }

  const Beam::FieldAngle_optional& Beam::
  FieldAngle () const
  {
    return this->FieldAngle_;
  }

  Beam::FieldAngle_optional& Beam::
  FieldAngle ()
  {
    return this->FieldAngle_;
  }

  void Beam::
  FieldAngle (const FieldAngle_type& x)
  {
    this->FieldAngle_.set (x);
  }

  void Beam::
  FieldAngle (const FieldAngle_optional& x)
  {
    this->FieldAngle_ = x;
  }

  const Beam::BeamRadius_optional& Beam::
  BeamRadius () const
  {
    return this->BeamRadius_;
  }

  Beam::BeamRadius_optional& Beam::
  BeamRadius ()
  {
    return this->BeamRadius_;
  }

  void Beam::
  BeamRadius (const BeamRadius_type& x)
  {
    this->BeamRadius_.set (x);
  }

  void Beam::
  BeamRadius (const BeamRadius_optional& x)
  {
    this->BeamRadius_ = x;
  }

  const Beam::BeamType_optional& Beam::
  BeamType () const
  {
    return this->BeamType_;
  }

  Beam::BeamType_optional& Beam::
  BeamType ()
  {
    return this->BeamType_;
  }

  void Beam::
  BeamType (const BeamType_type& x)
  {
    this->BeamType_.set (x);
  }

  void Beam::
  BeamType (const BeamType_optional& x)
  {
    this->BeamType_ = x;
  }

  void Beam::
  BeamType (::std::unique_ptr< BeamType_type > x)
  {
    this->BeamType_.set (std::move (x));
  }

  const Beam::ColorRenderingIndex_optional& Beam::
  ColorRenderingIndex () const
  {
    return this->ColorRenderingIndex_;
  }

  Beam::ColorRenderingIndex_optional& Beam::
  ColorRenderingIndex ()
  {
    return this->ColorRenderingIndex_;
  }

  void Beam::
  ColorRenderingIndex (const ColorRenderingIndex_type& x)
  {
    this->ColorRenderingIndex_.set (x);
  }

  void Beam::
  ColorRenderingIndex (const ColorRenderingIndex_optional& x)
  {
    this->ColorRenderingIndex_ = x;
  }


  // GeometryReference
  // 

  const GeometryReference::Break_sequence& GeometryReference::
  Break () const
  {
    return this->Break_;
  }

  GeometryReference::Break_sequence& GeometryReference::
  Break ()
  {
    return this->Break_;
  }

  void GeometryReference::
  Break (const Break_sequence& s)
  {
    this->Break_ = s;
  }

  const GeometryReference::Name_optional& GeometryReference::
  Name () const
  {
    return this->Name_;
  }

  GeometryReference::Name_optional& GeometryReference::
  Name ()
  {
    return this->Name_;
  }

  void GeometryReference::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void GeometryReference::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void GeometryReference::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const GeometryReference::Position_optional& GeometryReference::
  Position () const
  {
    return this->Position_;
  }

  GeometryReference::Position_optional& GeometryReference::
  Position ()
  {
    return this->Position_;
  }

  void GeometryReference::
  Position (const Position_type& x)
  {
    this->Position_.set (x);
  }

  void GeometryReference::
  Position (const Position_optional& x)
  {
    this->Position_ = x;
  }

  void GeometryReference::
  Position (::std::unique_ptr< Position_type > x)
  {
    this->Position_.set (std::move (x));
  }

  const GeometryReference::Geometry_optional& GeometryReference::
  Geometry () const
  {
    return this->Geometry_;
  }

  GeometryReference::Geometry_optional& GeometryReference::
  Geometry ()
  {
    return this->Geometry_;
  }

  void GeometryReference::
  Geometry (const Geometry_type& x)
  {
    this->Geometry_.set (x);
  }

  void GeometryReference::
  Geometry (const Geometry_optional& x)
  {
    this->Geometry_ = x;
  }

  void GeometryReference::
  Geometry (::std::unique_ptr< Geometry_type > x)
  {
    this->Geometry_.set (std::move (x));
  }

  const GeometryReference::Model_optional& GeometryReference::
  Model () const
  {
    return this->Model_;
  }

  GeometryReference::Model_optional& GeometryReference::
  Model ()
  {
    return this->Model_;
  }

  void GeometryReference::
  Model (const Model_type& x)
  {
    this->Model_.set (x);
  }

  void GeometryReference::
  Model (const Model_optional& x)
  {
    this->Model_ = x;
  }

  void GeometryReference::
  Model (::std::unique_ptr< Model_type > x)
  {
    this->Model_.set (std::move (x));
  }


  // Break
  // 

  const Break::DMXOffset_optional& Break::
  DMXOffset () const
  {
    return this->DMXOffset_;
  }

  Break::DMXOffset_optional& Break::
  DMXOffset ()
  {
    return this->DMXOffset_;
  }

  void Break::
  DMXOffset (const DMXOffset_type& x)
  {
    this->DMXOffset_.set (x);
  }

  void Break::
  DMXOffset (const DMXOffset_optional& x)
  {
    this->DMXOffset_ = x;
  }

  const Break::DMXBreak_optional& Break::
  DMXBreak () const
  {
    return this->DMXBreak_;
  }

  Break::DMXBreak_optional& Break::
  DMXBreak ()
  {
    return this->DMXBreak_;
  }

  void Break::
  DMXBreak (const DMXBreak_type& x)
  {
    this->DMXBreak_.set (x);
  }

  void Break::
  DMXBreak (const DMXBreak_optional& x)
  {
    this->DMXBreak_ = x;
  }


  // DMXModes
  // 

  const DMXModes::DMXMode_sequence& DMXModes::
  DMXMode () const
  {
    return this->DMXMode_;
  }

  DMXModes::DMXMode_sequence& DMXModes::
  DMXMode ()
  {
    return this->DMXMode_;
  }

  void DMXModes::
  DMXMode (const DMXMode_sequence& s)
  {
    this->DMXMode_ = s;
  }


  // DMXMode
  // 

  const DMXMode::DMXChannels_sequence& DMXMode::
  DMXChannels () const
  {
    return this->DMXChannels_;
  }

  DMXMode::DMXChannels_sequence& DMXMode::
  DMXChannels ()
  {
    return this->DMXChannels_;
  }

  void DMXMode::
  DMXChannels (const DMXChannels_sequence& s)
  {
    this->DMXChannels_ = s;
  }

  const DMXMode::Relations_sequence& DMXMode::
  Relations () const
  {
    return this->Relations_;
  }

  DMXMode::Relations_sequence& DMXMode::
  Relations ()
  {
    return this->Relations_;
  }

  void DMXMode::
  Relations (const Relations_sequence& s)
  {
    this->Relations_ = s;
  }

  const DMXMode::FTMacros_sequence& DMXMode::
  FTMacros () const
  {
    return this->FTMacros_;
  }

  DMXMode::FTMacros_sequence& DMXMode::
  FTMacros ()
  {
    return this->FTMacros_;
  }

  void DMXMode::
  FTMacros (const FTMacros_sequence& s)
  {
    this->FTMacros_ = s;
  }

  const DMXMode::Name_type& DMXMode::
  Name () const
  {
    return this->Name_.get ();
  }

  DMXMode::Name_type& DMXMode::
  Name ()
  {
    return this->Name_.get ();
  }

  void DMXMode::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void DMXMode::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const DMXMode::Geometry_optional& DMXMode::
  Geometry () const
  {
    return this->Geometry_;
  }

  DMXMode::Geometry_optional& DMXMode::
  Geometry ()
  {
    return this->Geometry_;
  }

  void DMXMode::
  Geometry (const Geometry_type& x)
  {
    this->Geometry_.set (x);
  }

  void DMXMode::
  Geometry (const Geometry_optional& x)
  {
    this->Geometry_ = x;
  }

  void DMXMode::
  Geometry (::std::unique_ptr< Geometry_type > x)
  {
    this->Geometry_.set (std::move (x));
  }


  // DMXChannels
  // 

  const DMXChannels::DMXChannel_sequence& DMXChannels::
  DMXChannel () const
  {
    return this->DMXChannel_;
  }

  DMXChannels::DMXChannel_sequence& DMXChannels::
  DMXChannel ()
  {
    return this->DMXChannel_;
  }

  void DMXChannels::
  DMXChannel (const DMXChannel_sequence& s)
  {
    this->DMXChannel_ = s;
  }


  // DMXChannel
  // 

  const DMXChannel::LogicalChannel_type& DMXChannel::
  LogicalChannel () const
  {
    return this->LogicalChannel_.get ();
  }

  DMXChannel::LogicalChannel_type& DMXChannel::
  LogicalChannel ()
  {
    return this->LogicalChannel_.get ();
  }

  void DMXChannel::
  LogicalChannel (const LogicalChannel_type& x)
  {
    this->LogicalChannel_.set (x);
  }

  void DMXChannel::
  LogicalChannel (::std::unique_ptr< LogicalChannel_type > x)
  {
    this->LogicalChannel_.set (std::move (x));
  }

  const DMXChannel::Name_optional& DMXChannel::
  Name () const
  {
    return this->Name_;
  }

  DMXChannel::Name_optional& DMXChannel::
  Name ()
  {
    return this->Name_;
  }

  void DMXChannel::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void DMXChannel::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void DMXChannel::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const DMXChannel::DMXBreak_optional& DMXChannel::
  DMXBreak () const
  {
    return this->DMXBreak_;
  }

  DMXChannel::DMXBreak_optional& DMXChannel::
  DMXBreak ()
  {
    return this->DMXBreak_;
  }

  void DMXChannel::
  DMXBreak (const DMXBreak_type& x)
  {
    this->DMXBreak_.set (x);
  }

  void DMXChannel::
  DMXBreak (const DMXBreak_optional& x)
  {
    this->DMXBreak_ = x;
  }

  const DMXChannel::Offset_optional& DMXChannel::
  Offset () const
  {
    return this->Offset_;
  }

  DMXChannel::Offset_optional& DMXChannel::
  Offset ()
  {
    return this->Offset_;
  }

  void DMXChannel::
  Offset (const Offset_type& x)
  {
    this->Offset_.set (x);
  }

  void DMXChannel::
  Offset (const Offset_optional& x)
  {
    this->Offset_ = x;
  }

  void DMXChannel::
  Offset (::std::unique_ptr< Offset_type > x)
  {
    this->Offset_.set (std::move (x));
  }

  const DMXChannel::Default_optional& DMXChannel::
  Default () const
  {
    return this->Default_;
  }

  DMXChannel::Default_optional& DMXChannel::
  Default ()
  {
    return this->Default_;
  }

  void DMXChannel::
  Default (const Default_type& x)
  {
    this->Default_.set (x);
  }

  void DMXChannel::
  Default (const Default_optional& x)
  {
    this->Default_ = x;
  }

  void DMXChannel::
  Default (::std::unique_ptr< Default_type > x)
  {
    this->Default_.set (std::move (x));
  }

  const DMXChannel::Highlight_optional& DMXChannel::
  Highlight () const
  {
    return this->Highlight_;
  }

  DMXChannel::Highlight_optional& DMXChannel::
  Highlight ()
  {
    return this->Highlight_;
  }

  void DMXChannel::
  Highlight (const Highlight_type& x)
  {
    this->Highlight_.set (x);
  }

  void DMXChannel::
  Highlight (const Highlight_optional& x)
  {
    this->Highlight_ = x;
  }

  void DMXChannel::
  Highlight (::std::unique_ptr< Highlight_type > x)
  {
    this->Highlight_.set (std::move (x));
  }

  const DMXChannel::Geometry_optional& DMXChannel::
  Geometry () const
  {
    return this->Geometry_;
  }

  DMXChannel::Geometry_optional& DMXChannel::
  Geometry ()
  {
    return this->Geometry_;
  }

  void DMXChannel::
  Geometry (const Geometry_type& x)
  {
    this->Geometry_.set (x);
  }

  void DMXChannel::
  Geometry (const Geometry_optional& x)
  {
    this->Geometry_ = x;
  }

  void DMXChannel::
  Geometry (::std::unique_ptr< Geometry_type > x)
  {
    this->Geometry_.set (std::move (x));
  }


  // LogicalChannel
  // 

  const LogicalChannel::ChannelFunction_sequence& LogicalChannel::
  ChannelFunction () const
  {
    return this->ChannelFunction_;
  }

  LogicalChannel::ChannelFunction_sequence& LogicalChannel::
  ChannelFunction ()
  {
    return this->ChannelFunction_;
  }

  void LogicalChannel::
  ChannelFunction (const ChannelFunction_sequence& s)
  {
    this->ChannelFunction_ = s;
  }

  const LogicalChannel::Name_optional& LogicalChannel::
  Name () const
  {
    return this->Name_;
  }

  LogicalChannel::Name_optional& LogicalChannel::
  Name ()
  {
    return this->Name_;
  }

  void LogicalChannel::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void LogicalChannel::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void LogicalChannel::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const LogicalChannel::Attribute_type& LogicalChannel::
  Attribute () const
  {
    return this->Attribute_.get ();
  }

  LogicalChannel::Attribute_type& LogicalChannel::
  Attribute ()
  {
    return this->Attribute_.get ();
  }

  void LogicalChannel::
  Attribute (const Attribute_type& x)
  {
    this->Attribute_.set (x);
  }

  void LogicalChannel::
  Attribute (::std::unique_ptr< Attribute_type > x)
  {
    this->Attribute_.set (std::move (x));
  }

  const LogicalChannel::Snap_optional& LogicalChannel::
  Snap () const
  {
    return this->Snap_;
  }

  LogicalChannel::Snap_optional& LogicalChannel::
  Snap ()
  {
    return this->Snap_;
  }

  void LogicalChannel::
  Snap (const Snap_type& x)
  {
    this->Snap_.set (x);
  }

  void LogicalChannel::
  Snap (const Snap_optional& x)
  {
    this->Snap_ = x;
  }

  void LogicalChannel::
  Snap (::std::unique_ptr< Snap_type > x)
  {
    this->Snap_.set (std::move (x));
  }

  const LogicalChannel::Master_optional& LogicalChannel::
  Master () const
  {
    return this->Master_;
  }

  LogicalChannel::Master_optional& LogicalChannel::
  Master ()
  {
    return this->Master_;
  }

  void LogicalChannel::
  Master (const Master_type& x)
  {
    this->Master_.set (x);
  }

  void LogicalChannel::
  Master (const Master_optional& x)
  {
    this->Master_ = x;
  }

  void LogicalChannel::
  Master (::std::unique_ptr< Master_type > x)
  {
    this->Master_.set (std::move (x));
  }

  const LogicalChannel::MibFade_optional& LogicalChannel::
  MibFade () const
  {
    return this->MibFade_;
  }

  LogicalChannel::MibFade_optional& LogicalChannel::
  MibFade ()
  {
    return this->MibFade_;
  }

  void LogicalChannel::
  MibFade (const MibFade_type& x)
  {
    this->MibFade_.set (x);
  }

  void LogicalChannel::
  MibFade (const MibFade_optional& x)
  {
    this->MibFade_ = x;
  }

  const LogicalChannel::DMXChangeTimeLimit_optional& LogicalChannel::
  DMXChangeTimeLimit () const
  {
    return this->DMXChangeTimeLimit_;
  }

  LogicalChannel::DMXChangeTimeLimit_optional& LogicalChannel::
  DMXChangeTimeLimit ()
  {
    return this->DMXChangeTimeLimit_;
  }

  void LogicalChannel::
  DMXChangeTimeLimit (const DMXChangeTimeLimit_type& x)
  {
    this->DMXChangeTimeLimit_.set (x);
  }

  void LogicalChannel::
  DMXChangeTimeLimit (const DMXChangeTimeLimit_optional& x)
  {
    this->DMXChangeTimeLimit_ = x;
  }


  // ChannelFunction
  // 

  const ChannelFunction::ChannelSet_sequence& ChannelFunction::
  ChannelSet () const
  {
    return this->ChannelSet_;
  }

  ChannelFunction::ChannelSet_sequence& ChannelFunction::
  ChannelSet ()
  {
    return this->ChannelSet_;
  }

  void ChannelFunction::
  ChannelSet (const ChannelSet_sequence& s)
  {
    this->ChannelSet_ = s;
  }

  const ChannelFunction::Name_optional& ChannelFunction::
  Name () const
  {
    return this->Name_;
  }

  ChannelFunction::Name_optional& ChannelFunction::
  Name ()
  {
    return this->Name_;
  }

  void ChannelFunction::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void ChannelFunction::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void ChannelFunction::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const ChannelFunction::Attribute_type& ChannelFunction::
  Attribute () const
  {
    return this->Attribute_.get ();
  }

  ChannelFunction::Attribute_type& ChannelFunction::
  Attribute ()
  {
    return this->Attribute_.get ();
  }

  void ChannelFunction::
  Attribute (const Attribute_type& x)
  {
    this->Attribute_.set (x);
  }

  void ChannelFunction::
  Attribute (::std::unique_ptr< Attribute_type > x)
  {
    this->Attribute_.set (std::move (x));
  }

  const ChannelFunction::OriginalAttribute_optional& ChannelFunction::
  OriginalAttribute () const
  {
    return this->OriginalAttribute_;
  }

  ChannelFunction::OriginalAttribute_optional& ChannelFunction::
  OriginalAttribute ()
  {
    return this->OriginalAttribute_;
  }

  void ChannelFunction::
  OriginalAttribute (const OriginalAttribute_type& x)
  {
    this->OriginalAttribute_.set (x);
  }

  void ChannelFunction::
  OriginalAttribute (const OriginalAttribute_optional& x)
  {
    this->OriginalAttribute_ = x;
  }

  void ChannelFunction::
  OriginalAttribute (::std::unique_ptr< OriginalAttribute_type > x)
  {
    this->OriginalAttribute_.set (std::move (x));
  }

  const ChannelFunction::DMXFrom_optional& ChannelFunction::
  DMXFrom () const
  {
    return this->DMXFrom_;
  }

  ChannelFunction::DMXFrom_optional& ChannelFunction::
  DMXFrom ()
  {
    return this->DMXFrom_;
  }

  void ChannelFunction::
  DMXFrom (const DMXFrom_type& x)
  {
    this->DMXFrom_.set (x);
  }

  void ChannelFunction::
  DMXFrom (const DMXFrom_optional& x)
  {
    this->DMXFrom_ = x;
  }

  void ChannelFunction::
  DMXFrom (::std::unique_ptr< DMXFrom_type > x)
  {
    this->DMXFrom_.set (std::move (x));
  }

  const ChannelFunction::PhysicalFrom_optional& ChannelFunction::
  PhysicalFrom () const
  {
    return this->PhysicalFrom_;
  }

  ChannelFunction::PhysicalFrom_optional& ChannelFunction::
  PhysicalFrom ()
  {
    return this->PhysicalFrom_;
  }

  void ChannelFunction::
  PhysicalFrom (const PhysicalFrom_type& x)
  {
    this->PhysicalFrom_.set (x);
  }

  void ChannelFunction::
  PhysicalFrom (const PhysicalFrom_optional& x)
  {
    this->PhysicalFrom_ = x;
  }

  const ChannelFunction::PhysicalTo_optional& ChannelFunction::
  PhysicalTo () const
  {
    return this->PhysicalTo_;
  }

  ChannelFunction::PhysicalTo_optional& ChannelFunction::
  PhysicalTo ()
  {
    return this->PhysicalTo_;
  }

  void ChannelFunction::
  PhysicalTo (const PhysicalTo_type& x)
  {
    this->PhysicalTo_.set (x);
  }

  void ChannelFunction::
  PhysicalTo (const PhysicalTo_optional& x)
  {
    this->PhysicalTo_ = x;
  }

  const ChannelFunction::RealFade_optional& ChannelFunction::
  RealFade () const
  {
    return this->RealFade_;
  }

  ChannelFunction::RealFade_optional& ChannelFunction::
  RealFade ()
  {
    return this->RealFade_;
  }

  void ChannelFunction::
  RealFade (const RealFade_type& x)
  {
    this->RealFade_.set (x);
  }

  void ChannelFunction::
  RealFade (const RealFade_optional& x)
  {
    this->RealFade_ = x;
  }

  const ChannelFunction::Wheel_optional& ChannelFunction::
  Wheel () const
  {
    return this->Wheel_;
  }

  ChannelFunction::Wheel_optional& ChannelFunction::
  Wheel ()
  {
    return this->Wheel_;
  }

  void ChannelFunction::
  Wheel (const Wheel_type& x)
  {
    this->Wheel_.set (x);
  }

  void ChannelFunction::
  Wheel (const Wheel_optional& x)
  {
    this->Wheel_ = x;
  }

  void ChannelFunction::
  Wheel (::std::unique_ptr< Wheel_type > x)
  {
    this->Wheel_.set (std::move (x));
  }

  const ChannelFunction::Emitter_optional& ChannelFunction::
  Emitter () const
  {
    return this->Emitter_;
  }

  ChannelFunction::Emitter_optional& ChannelFunction::
  Emitter ()
  {
    return this->Emitter_;
  }

  void ChannelFunction::
  Emitter (const Emitter_type& x)
  {
    this->Emitter_.set (x);
  }

  void ChannelFunction::
  Emitter (const Emitter_optional& x)
  {
    this->Emitter_ = x;
  }

  void ChannelFunction::
  Emitter (::std::unique_ptr< Emitter_type > x)
  {
    this->Emitter_.set (std::move (x));
  }

  const ChannelFunction::Filter_optional& ChannelFunction::
  Filter () const
  {
    return this->Filter_;
  }

  ChannelFunction::Filter_optional& ChannelFunction::
  Filter ()
  {
    return this->Filter_;
  }

  void ChannelFunction::
  Filter (const Filter_type& x)
  {
    this->Filter_.set (x);
  }

  void ChannelFunction::
  Filter (const Filter_optional& x)
  {
    this->Filter_ = x;
  }

  void ChannelFunction::
  Filter (::std::unique_ptr< Filter_type > x)
  {
    this->Filter_.set (std::move (x));
  }

  const ChannelFunction::ModeMaster_optional& ChannelFunction::
  ModeMaster () const
  {
    return this->ModeMaster_;
  }

  ChannelFunction::ModeMaster_optional& ChannelFunction::
  ModeMaster ()
  {
    return this->ModeMaster_;
  }

  void ChannelFunction::
  ModeMaster (const ModeMaster_type& x)
  {
    this->ModeMaster_.set (x);
  }

  void ChannelFunction::
  ModeMaster (const ModeMaster_optional& x)
  {
    this->ModeMaster_ = x;
  }

  void ChannelFunction::
  ModeMaster (::std::unique_ptr< ModeMaster_type > x)
  {
    this->ModeMaster_.set (std::move (x));
  }

  const ChannelFunction::ModeFrom_type& ChannelFunction::
  ModeFrom () const
  {
    return this->ModeFrom_.get ();
  }

  ChannelFunction::ModeFrom_type& ChannelFunction::
  ModeFrom ()
  {
    return this->ModeFrom_.get ();
  }

  void ChannelFunction::
  ModeFrom (const ModeFrom_type& x)
  {
    this->ModeFrom_.set (x);
  }

  void ChannelFunction::
  ModeFrom (::std::unique_ptr< ModeFrom_type > x)
  {
    this->ModeFrom_.set (std::move (x));
  }

  const ChannelFunction::ModeFrom_type& ChannelFunction::
  ModeFrom_default_value ()
  {
    return ModeFrom_default_value_;
  }

  const ChannelFunction::ModeTo_optional& ChannelFunction::
  ModeTo () const
  {
    return this->ModeTo_;
  }

  ChannelFunction::ModeTo_optional& ChannelFunction::
  ModeTo ()
  {
    return this->ModeTo_;
  }

  void ChannelFunction::
  ModeTo (const ModeTo_type& x)
  {
    this->ModeTo_.set (x);
  }

  void ChannelFunction::
  ModeTo (const ModeTo_optional& x)
  {
    this->ModeTo_ = x;
  }

  void ChannelFunction::
  ModeTo (::std::unique_ptr< ModeTo_type > x)
  {
    this->ModeTo_.set (std::move (x));
  }


  // ChannelSet
  // 

  const ChannelSet::Name_optional& ChannelSet::
  Name () const
  {
    return this->Name_;
  }

  ChannelSet::Name_optional& ChannelSet::
  Name ()
  {
    return this->Name_;
  }

  void ChannelSet::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void ChannelSet::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void ChannelSet::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const ChannelSet::DMXFrom_optional& ChannelSet::
  DMXFrom () const
  {
    return this->DMXFrom_;
  }

  ChannelSet::DMXFrom_optional& ChannelSet::
  DMXFrom ()
  {
    return this->DMXFrom_;
  }

  void ChannelSet::
  DMXFrom (const DMXFrom_type& x)
  {
    this->DMXFrom_.set (x);
  }

  void ChannelSet::
  DMXFrom (const DMXFrom_optional& x)
  {
    this->DMXFrom_ = x;
  }

  void ChannelSet::
  DMXFrom (::std::unique_ptr< DMXFrom_type > x)
  {
    this->DMXFrom_.set (std::move (x));
  }

  const ChannelSet::DMXTo_optional& ChannelSet::
  DMXTo () const
  {
    return this->DMXTo_;
  }

  ChannelSet::DMXTo_optional& ChannelSet::
  DMXTo ()
  {
    return this->DMXTo_;
  }

  void ChannelSet::
  DMXTo (const DMXTo_type& x)
  {
    this->DMXTo_.set (x);
  }

  void ChannelSet::
  DMXTo (const DMXTo_optional& x)
  {
    this->DMXTo_ = x;
  }

  void ChannelSet::
  DMXTo (::std::unique_ptr< DMXTo_type > x)
  {
    this->DMXTo_.set (std::move (x));
  }

  const ChannelSet::PhysicalFrom_optional& ChannelSet::
  PhysicalFrom () const
  {
    return this->PhysicalFrom_;
  }

  ChannelSet::PhysicalFrom_optional& ChannelSet::
  PhysicalFrom ()
  {
    return this->PhysicalFrom_;
  }

  void ChannelSet::
  PhysicalFrom (const PhysicalFrom_type& x)
  {
    this->PhysicalFrom_.set (x);
  }

  void ChannelSet::
  PhysicalFrom (const PhysicalFrom_optional& x)
  {
    this->PhysicalFrom_ = x;
  }

  const ChannelSet::PhysicalTo_optional& ChannelSet::
  PhysicalTo () const
  {
    return this->PhysicalTo_;
  }

  ChannelSet::PhysicalTo_optional& ChannelSet::
  PhysicalTo ()
  {
    return this->PhysicalTo_;
  }

  void ChannelSet::
  PhysicalTo (const PhysicalTo_type& x)
  {
    this->PhysicalTo_.set (x);
  }

  void ChannelSet::
  PhysicalTo (const PhysicalTo_optional& x)
  {
    this->PhysicalTo_ = x;
  }

  const ChannelSet::WheelSlotIndex_optional& ChannelSet::
  WheelSlotIndex () const
  {
    return this->WheelSlotIndex_;
  }

  ChannelSet::WheelSlotIndex_optional& ChannelSet::
  WheelSlotIndex ()
  {
    return this->WheelSlotIndex_;
  }

  void ChannelSet::
  WheelSlotIndex (const WheelSlotIndex_type& x)
  {
    this->WheelSlotIndex_.set (x);
  }

  void ChannelSet::
  WheelSlotIndex (const WheelSlotIndex_optional& x)
  {
    this->WheelSlotIndex_ = x;
  }


  // Relations
  // 

  const Relations::Relation_sequence& Relations::
  Relation () const
  {
    return this->Relation_;
  }

  Relations::Relation_sequence& Relations::
  Relation ()
  {
    return this->Relation_;
  }

  void Relations::
  Relation (const Relation_sequence& s)
  {
    this->Relation_ = s;
  }


  // Relation
  // 

  const Relation::Name_type& Relation::
  Name () const
  {
    return this->Name_.get ();
  }

  Relation::Name_type& Relation::
  Name ()
  {
    return this->Name_.get ();
  }

  void Relation::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Relation::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const Relation::Master_type& Relation::
  Master () const
  {
    return this->Master_.get ();
  }

  Relation::Master_type& Relation::
  Master ()
  {
    return this->Master_.get ();
  }

  void Relation::
  Master (const Master_type& x)
  {
    this->Master_.set (x);
  }

  void Relation::
  Master (::std::unique_ptr< Master_type > x)
  {
    this->Master_.set (std::move (x));
  }

  const Relation::Follower_type& Relation::
  Follower () const
  {
    return this->Follower_.get ();
  }

  Relation::Follower_type& Relation::
  Follower ()
  {
    return this->Follower_.get ();
  }

  void Relation::
  Follower (const Follower_type& x)
  {
    this->Follower_.set (x);
  }

  void Relation::
  Follower (::std::unique_ptr< Follower_type > x)
  {
    this->Follower_.set (std::move (x));
  }

  const Relation::Type_type& Relation::
  Type () const
  {
    return this->Type_.get ();
  }

  Relation::Type_type& Relation::
  Type ()
  {
    return this->Type_.get ();
  }

  void Relation::
  Type (const Type_type& x)
  {
    this->Type_.set (x);
  }

  void Relation::
  Type (::std::unique_ptr< Type_type > x)
  {
    this->Type_.set (std::move (x));
  }


  // Revisions
  // 

  const Revisions::Revision_sequence& Revisions::
  Revision () const
  {
    return this->Revision_;
  }

  Revisions::Revision_sequence& Revisions::
  Revision ()
  {
    return this->Revision_;
  }

  void Revisions::
  Revision (const Revision_sequence& s)
  {
    this->Revision_ = s;
  }


  // Revision
  // 

  const Revision::Text_optional& Revision::
  Text () const
  {
    return this->Text_;
  }

  Revision::Text_optional& Revision::
  Text ()
  {
    return this->Text_;
  }

  void Revision::
  Text (const Text_type& x)
  {
    this->Text_.set (x);
  }

  void Revision::
  Text (const Text_optional& x)
  {
    this->Text_ = x;
  }

  void Revision::
  Text (::std::unique_ptr< Text_type > x)
  {
    this->Text_.set (std::move (x));
  }

  const Revision::Date_optional& Revision::
  Date () const
  {
    return this->Date_;
  }

  Revision::Date_optional& Revision::
  Date ()
  {
    return this->Date_;
  }

  void Revision::
  Date (const Date_type& x)
  {
    this->Date_.set (x);
  }

  void Revision::
  Date (const Date_optional& x)
  {
    this->Date_ = x;
  }

  void Revision::
  Date (::std::unique_ptr< Date_type > x)
  {
    this->Date_.set (std::move (x));
  }

  const Revision::UserID_optional& Revision::
  UserID () const
  {
    return this->UserID_;
  }

  Revision::UserID_optional& Revision::
  UserID ()
  {
    return this->UserID_;
  }

  void Revision::
  UserID (const UserID_type& x)
  {
    this->UserID_.set (x);
  }

  void Revision::
  UserID (const UserID_optional& x)
  {
    this->UserID_ = x;
  }


  // FTPresets
  // 

  const FTPresets::FTPreset_sequence& FTPresets::
  FTPreset () const
  {
    return this->FTPreset_;
  }

  FTPresets::FTPreset_sequence& FTPresets::
  FTPreset ()
  {
    return this->FTPreset_;
  }

  void FTPresets::
  FTPreset (const FTPreset_sequence& s)
  {
    this->FTPreset_ = s;
  }


  // FTPreset
  // 


  // FTMacros
  // 

  const FTMacros::FTMacro_sequence& FTMacros::
  FTMacro () const
  {
    return this->FTMacro_;
  }

  FTMacros::FTMacro_sequence& FTMacros::
  FTMacro ()
  {
    return this->FTMacro_;
  }

  void FTMacros::
  FTMacro (const FTMacro_sequence& s)
  {
    this->FTMacro_ = s;
  }


  // FTMacro
  // 

  const FTMacro::MacroDMX_sequence& FTMacro::
  MacroDMX () const
  {
    return this->MacroDMX_;
  }

  FTMacro::MacroDMX_sequence& FTMacro::
  MacroDMX ()
  {
    return this->MacroDMX_;
  }

  void FTMacro::
  MacroDMX (const MacroDMX_sequence& s)
  {
    this->MacroDMX_ = s;
  }

  const FTMacro::MacroVisual_sequence& FTMacro::
  MacroVisual () const
  {
    return this->MacroVisual_;
  }

  FTMacro::MacroVisual_sequence& FTMacro::
  MacroVisual ()
  {
    return this->MacroVisual_;
  }

  void FTMacro::
  MacroVisual (const MacroVisual_sequence& s)
  {
    this->MacroVisual_ = s;
  }

  const FTMacro::Name_optional& FTMacro::
  Name () const
  {
    return this->Name_;
  }

  FTMacro::Name_optional& FTMacro::
  Name ()
  {
    return this->Name_;
  }

  void FTMacro::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void FTMacro::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void FTMacro::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }


  // MacroDMX
  // 

  const MacroDMX::DMXStep_sequence& MacroDMX::
  DMXStep () const
  {
    return this->DMXStep_;
  }

  MacroDMX::DMXStep_sequence& MacroDMX::
  DMXStep ()
  {
    return this->DMXStep_;
  }

  void MacroDMX::
  DMXStep (const DMXStep_sequence& s)
  {
    this->DMXStep_ = s;
  }


  // DMXStep
  // 

  const DMXStep::DMXValue_sequence& DMXStep::
  DMXValue () const
  {
    return this->DMXValue_;
  }

  DMXStep::DMXValue_sequence& DMXStep::
  DMXValue ()
  {
    return this->DMXValue_;
  }

  void DMXStep::
  DMXValue (const DMXValue_sequence& s)
  {
    this->DMXValue_ = s;
  }

  const DMXStep::Duration_optional& DMXStep::
  Duration () const
  {
    return this->Duration_;
  }

  DMXStep::Duration_optional& DMXStep::
  Duration ()
  {
    return this->Duration_;
  }

  void DMXStep::
  Duration (const Duration_type& x)
  {
    this->Duration_.set (x);
  }

  void DMXStep::
  Duration (const Duration_optional& x)
  {
    this->Duration_ = x;
  }


  // DMXValue
  // 

  const DMXValue::Value_optional& DMXValue::
  Value () const
  {
    return this->Value_;
  }

  DMXValue::Value_optional& DMXValue::
  Value ()
  {
    return this->Value_;
  }

  void DMXValue::
  Value (const Value_type& x)
  {
    this->Value_.set (x);
  }

  void DMXValue::
  Value (const Value_optional& x)
  {
    this->Value_ = x;
  }

  void DMXValue::
  Value (::std::unique_ptr< Value_type > x)
  {
    this->Value_.set (std::move (x));
  }

  const DMXValue::DMXChannel_optional& DMXValue::
  DMXChannel () const
  {
    return this->DMXChannel_;
  }

  DMXValue::DMXChannel_optional& DMXValue::
  DMXChannel ()
  {
    return this->DMXChannel_;
  }

  void DMXValue::
  DMXChannel (const DMXChannel_type& x)
  {
    this->DMXChannel_.set (x);
  }

  void DMXValue::
  DMXChannel (const DMXChannel_optional& x)
  {
    this->DMXChannel_ = x;
  }

  void DMXValue::
  DMXChannel (::std::unique_ptr< DMXChannel_type > x)
  {
    this->DMXChannel_.set (std::move (x));
  }


  // MacroVisual
  // 

  const MacroVisual::VisualStep_sequence& MacroVisual::
  VisualStep () const
  {
    return this->VisualStep_;
  }

  MacroVisual::VisualStep_sequence& MacroVisual::
  VisualStep ()
  {
    return this->VisualStep_;
  }

  void MacroVisual::
  VisualStep (const VisualStep_sequence& s)
  {
    this->VisualStep_ = s;
  }


  // VisualStep
  // 

  const VisualStep::VisualValue_sequence& VisualStep::
  VisualValue () const
  {
    return this->VisualValue_;
  }

  VisualStep::VisualValue_sequence& VisualStep::
  VisualValue ()
  {
    return this->VisualValue_;
  }

  void VisualStep::
  VisualValue (const VisualValue_sequence& s)
  {
    this->VisualValue_ = s;
  }

  const VisualStep::Duration_optional& VisualStep::
  Duration () const
  {
    return this->Duration_;
  }

  VisualStep::Duration_optional& VisualStep::
  Duration ()
  {
    return this->Duration_;
  }

  void VisualStep::
  Duration (const Duration_type& x)
  {
    this->Duration_.set (x);
  }

  void VisualStep::
  Duration (const Duration_optional& x)
  {
    this->Duration_ = x;
  }

  const VisualStep::Fade_optional& VisualStep::
  Fade () const
  {
    return this->Fade_;
  }

  VisualStep::Fade_optional& VisualStep::
  Fade ()
  {
    return this->Fade_;
  }

  void VisualStep::
  Fade (const Fade_type& x)
  {
    this->Fade_.set (x);
  }

  void VisualStep::
  Fade (const Fade_optional& x)
  {
    this->Fade_ = x;
  }

  void VisualStep::
  Fade (::std::unique_ptr< Fade_type > x)
  {
    this->Fade_.set (std::move (x));
  }

  const VisualStep::Delay_optional& VisualStep::
  Delay () const
  {
    return this->Delay_;
  }

  VisualStep::Delay_optional& VisualStep::
  Delay ()
  {
    return this->Delay_;
  }

  void VisualStep::
  Delay (const Delay_type& x)
  {
    this->Delay_.set (x);
  }

  void VisualStep::
  Delay (const Delay_optional& x)
  {
    this->Delay_ = x;
  }

  void VisualStep::
  Delay (::std::unique_ptr< Delay_type > x)
  {
    this->Delay_.set (std::move (x));
  }


  // VisualValue
  // 

  const VisualValue::Value_optional& VisualValue::
  Value () const
  {
    return this->Value_;
  }

  VisualValue::Value_optional& VisualValue::
  Value ()
  {
    return this->Value_;
  }

  void VisualValue::
  Value (const Value_type& x)
  {
    this->Value_.set (x);
  }

  void VisualValue::
  Value (const Value_optional& x)
  {
    this->Value_ = x;
  }

  void VisualValue::
  Value (::std::unique_ptr< Value_type > x)
  {
    this->Value_.set (std::move (x));
  }

  const VisualValue::ChannelFunction_optional& VisualValue::
  ChannelFunction () const
  {
    return this->ChannelFunction_;
  }

  VisualValue::ChannelFunction_optional& VisualValue::
  ChannelFunction ()
  {
    return this->ChannelFunction_;
  }

  void VisualValue::
  ChannelFunction (const ChannelFunction_type& x)
  {
    this->ChannelFunction_.set (x);
  }

  void VisualValue::
  ChannelFunction (const ChannelFunction_optional& x)
  {
    this->ChannelFunction_ = x;
  }

  void VisualValue::
  ChannelFunction (::std::unique_ptr< ChannelFunction_type > x)
  {
    this->ChannelFunction_.set (std::move (x));
  }


  // PhysicalDescriptions
  // 

  const PhysicalDescriptions::Emitters_sequence& PhysicalDescriptions::
  Emitters () const
  {
    return this->Emitters_;
  }

  PhysicalDescriptions::Emitters_sequence& PhysicalDescriptions::
  Emitters ()
  {
    return this->Emitters_;
  }

  void PhysicalDescriptions::
  Emitters (const Emitters_sequence& s)
  {
    this->Emitters_ = s;
  }

  const PhysicalDescriptions::Filters_sequence& PhysicalDescriptions::
  Filters () const
  {
    return this->Filters_;
  }

  PhysicalDescriptions::Filters_sequence& PhysicalDescriptions::
  Filters ()
  {
    return this->Filters_;
  }

  void PhysicalDescriptions::
  Filters (const Filters_sequence& s)
  {
    this->Filters_ = s;
  }

  const PhysicalDescriptions::ColorSpace_sequence& PhysicalDescriptions::
  ColorSpace () const
  {
    return this->ColorSpace_;
  }

  PhysicalDescriptions::ColorSpace_sequence& PhysicalDescriptions::
  ColorSpace ()
  {
    return this->ColorSpace_;
  }

  void PhysicalDescriptions::
  ColorSpace (const ColorSpace_sequence& s)
  {
    this->ColorSpace_ = s;
  }

  const PhysicalDescriptions::DMXProfiles_sequence& PhysicalDescriptions::
  DMXProfiles () const
  {
    return this->DMXProfiles_;
  }

  PhysicalDescriptions::DMXProfiles_sequence& PhysicalDescriptions::
  DMXProfiles ()
  {
    return this->DMXProfiles_;
  }

  void PhysicalDescriptions::
  DMXProfiles (const DMXProfiles_sequence& s)
  {
    this->DMXProfiles_ = s;
  }

  const PhysicalDescriptions::CRIs_sequence& PhysicalDescriptions::
  CRIs () const
  {
    return this->CRIs_;
  }

  PhysicalDescriptions::CRIs_sequence& PhysicalDescriptions::
  CRIs ()
  {
    return this->CRIs_;
  }

  void PhysicalDescriptions::
  CRIs (const CRIs_sequence& s)
  {
    this->CRIs_ = s;
  }


  // Emitters
  // 

  const Emitters::Emitter_sequence& Emitters::
  Emitter () const
  {
    return this->Emitter_;
  }

  Emitters::Emitter_sequence& Emitters::
  Emitter ()
  {
    return this->Emitter_;
  }

  void Emitters::
  Emitter (const Emitter_sequence& s)
  {
    this->Emitter_ = s;
  }


  // Emitter
  // 

  const Emitter::Measurement_sequence& Emitter::
  Measurement () const
  {
    return this->Measurement_;
  }

  Emitter::Measurement_sequence& Emitter::
  Measurement ()
  {
    return this->Measurement_;
  }

  void Emitter::
  Measurement (const Measurement_sequence& s)
  {
    this->Measurement_ = s;
  }

  const Emitter::Name_optional& Emitter::
  Name () const
  {
    return this->Name_;
  }

  Emitter::Name_optional& Emitter::
  Name ()
  {
    return this->Name_;
  }

  void Emitter::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Emitter::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void Emitter::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const Emitter::Color_optional& Emitter::
  Color () const
  {
    return this->Color_;
  }

  Emitter::Color_optional& Emitter::
  Color ()
  {
    return this->Color_;
  }

  void Emitter::
  Color (const Color_type& x)
  {
    this->Color_.set (x);
  }

  void Emitter::
  Color (const Color_optional& x)
  {
    this->Color_ = x;
  }

  void Emitter::
  Color (::std::unique_ptr< Color_type > x)
  {
    this->Color_.set (std::move (x));
  }

  const Emitter::DominantWaveLength_optional& Emitter::
  DominantWaveLength () const
  {
    return this->DominantWaveLength_;
  }

  Emitter::DominantWaveLength_optional& Emitter::
  DominantWaveLength ()
  {
    return this->DominantWaveLength_;
  }

  void Emitter::
  DominantWaveLength (const DominantWaveLength_type& x)
  {
    this->DominantWaveLength_.set (x);
  }

  void Emitter::
  DominantWaveLength (const DominantWaveLength_optional& x)
  {
    this->DominantWaveLength_ = x;
  }

  const Emitter::DiodePart_optional& Emitter::
  DiodePart () const
  {
    return this->DiodePart_;
  }

  Emitter::DiodePart_optional& Emitter::
  DiodePart ()
  {
    return this->DiodePart_;
  }

  void Emitter::
  DiodePart (const DiodePart_type& x)
  {
    this->DiodePart_.set (x);
  }

  void Emitter::
  DiodePart (const DiodePart_optional& x)
  {
    this->DiodePart_ = x;
  }

  void Emitter::
  DiodePart (::std::unique_ptr< DiodePart_type > x)
  {
    this->DiodePart_.set (std::move (x));
  }


  // Filters
  // 

  const Filters::Filter_sequence& Filters::
  Filter () const
  {
    return this->Filter_;
  }

  Filters::Filter_sequence& Filters::
  Filter ()
  {
    return this->Filter_;
  }

  void Filters::
  Filter (const Filter_sequence& s)
  {
    this->Filter_ = s;
  }


  // Filter
  // 

  const Filter::Measurement_sequence& Filter::
  Measurement () const
  {
    return this->Measurement_;
  }

  Filter::Measurement_sequence& Filter::
  Measurement ()
  {
    return this->Measurement_;
  }

  void Filter::
  Measurement (const Measurement_sequence& s)
  {
    this->Measurement_ = s;
  }

  const Filter::Name_optional& Filter::
  Name () const
  {
    return this->Name_;
  }

  Filter::Name_optional& Filter::
  Name ()
  {
    return this->Name_;
  }

  void Filter::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Filter::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void Filter::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const Filter::Color_optional& Filter::
  Color () const
  {
    return this->Color_;
  }

  Filter::Color_optional& Filter::
  Color ()
  {
    return this->Color_;
  }

  void Filter::
  Color (const Color_type& x)
  {
    this->Color_.set (x);
  }

  void Filter::
  Color (const Color_optional& x)
  {
    this->Color_ = x;
  }

  void Filter::
  Color (::std::unique_ptr< Color_type > x)
  {
    this->Color_.set (std::move (x));
  }


  // Measurement
  // 

  const Measurement::MeasurementPoint_sequence& Measurement::
  MeasurementPoint () const
  {
    return this->MeasurementPoint_;
  }

  Measurement::MeasurementPoint_sequence& Measurement::
  MeasurementPoint ()
  {
    return this->MeasurementPoint_;
  }

  void Measurement::
  MeasurementPoint (const MeasurementPoint_sequence& s)
  {
    this->MeasurementPoint_ = s;
  }

  const Measurement::Physical_optional& Measurement::
  Physical () const
  {
    return this->Physical_;
  }

  Measurement::Physical_optional& Measurement::
  Physical ()
  {
    return this->Physical_;
  }

  void Measurement::
  Physical (const Physical_type& x)
  {
    this->Physical_.set (x);
  }

  void Measurement::
  Physical (const Physical_optional& x)
  {
    this->Physical_ = x;
  }

  const Measurement::LuminousIntensity_optional& Measurement::
  LuminousIntensity () const
  {
    return this->LuminousIntensity_;
  }

  Measurement::LuminousIntensity_optional& Measurement::
  LuminousIntensity ()
  {
    return this->LuminousIntensity_;
  }

  void Measurement::
  LuminousIntensity (const LuminousIntensity_type& x)
  {
    this->LuminousIntensity_.set (x);
  }

  void Measurement::
  LuminousIntensity (const LuminousIntensity_optional& x)
  {
    this->LuminousIntensity_ = x;
  }

  const Measurement::Transmission_optional& Measurement::
  Transmission () const
  {
    return this->Transmission_;
  }

  Measurement::Transmission_optional& Measurement::
  Transmission ()
  {
    return this->Transmission_;
  }

  void Measurement::
  Transmission (const Transmission_type& x)
  {
    this->Transmission_.set (x);
  }

  void Measurement::
  Transmission (const Transmission_optional& x)
  {
    this->Transmission_ = x;
  }

  const Measurement::InterpolationTo_optional& Measurement::
  InterpolationTo () const
  {
    return this->InterpolationTo_;
  }

  Measurement::InterpolationTo_optional& Measurement::
  InterpolationTo ()
  {
    return this->InterpolationTo_;
  }

  void Measurement::
  InterpolationTo (const InterpolationTo_type& x)
  {
    this->InterpolationTo_.set (x);
  }

  void Measurement::
  InterpolationTo (const InterpolationTo_optional& x)
  {
    this->InterpolationTo_ = x;
  }

  void Measurement::
  InterpolationTo (::std::unique_ptr< InterpolationTo_type > x)
  {
    this->InterpolationTo_.set (std::move (x));
  }


  // MeasurementPoint
  // 

  const MeasurementPoint::WaveLength_optional& MeasurementPoint::
  WaveLength () const
  {
    return this->WaveLength_;
  }

  MeasurementPoint::WaveLength_optional& MeasurementPoint::
  WaveLength ()
  {
    return this->WaveLength_;
  }

  void MeasurementPoint::
  WaveLength (const WaveLength_type& x)
  {
    this->WaveLength_.set (x);
  }

  void MeasurementPoint::
  WaveLength (const WaveLength_optional& x)
  {
    this->WaveLength_ = x;
  }

  const MeasurementPoint::Energy_optional& MeasurementPoint::
  Energy () const
  {
    return this->Energy_;
  }

  MeasurementPoint::Energy_optional& MeasurementPoint::
  Energy ()
  {
    return this->Energy_;
  }

  void MeasurementPoint::
  Energy (const Energy_type& x)
  {
    this->Energy_.set (x);
  }

  void MeasurementPoint::
  Energy (const Energy_optional& x)
  {
    this->Energy_ = x;
  }


  // ColorSpace
  // 

  const ColorSpace::ColorSpace1_optional& ColorSpace::
  ColorSpace1 () const
  {
    return this->ColorSpace1_;
  }

  ColorSpace::ColorSpace1_optional& ColorSpace::
  ColorSpace1 ()
  {
    return this->ColorSpace1_;
  }

  void ColorSpace::
  ColorSpace1 (const ColorSpace1_type& x)
  {
    this->ColorSpace1_.set (x);
  }

  void ColorSpace::
  ColorSpace1 (const ColorSpace1_optional& x)
  {
    this->ColorSpace1_ = x;
  }

  void ColorSpace::
  ColorSpace1 (::std::unique_ptr< ColorSpace1_type > x)
  {
    this->ColorSpace1_.set (std::move (x));
  }

  const ColorSpace::Red_optional& ColorSpace::
  Red () const
  {
    return this->Red_;
  }

  ColorSpace::Red_optional& ColorSpace::
  Red ()
  {
    return this->Red_;
  }

  void ColorSpace::
  Red (const Red_type& x)
  {
    this->Red_.set (x);
  }

  void ColorSpace::
  Red (const Red_optional& x)
  {
    this->Red_ = x;
  }

  void ColorSpace::
  Red (::std::unique_ptr< Red_type > x)
  {
    this->Red_.set (std::move (x));
  }

  const ColorSpace::Green_optional& ColorSpace::
  Green () const
  {
    return this->Green_;
  }

  ColorSpace::Green_optional& ColorSpace::
  Green ()
  {
    return this->Green_;
  }

  void ColorSpace::
  Green (const Green_type& x)
  {
    this->Green_.set (x);
  }

  void ColorSpace::
  Green (const Green_optional& x)
  {
    this->Green_ = x;
  }

  void ColorSpace::
  Green (::std::unique_ptr< Green_type > x)
  {
    this->Green_.set (std::move (x));
  }

  const ColorSpace::Blue_optional& ColorSpace::
  Blue () const
  {
    return this->Blue_;
  }

  ColorSpace::Blue_optional& ColorSpace::
  Blue ()
  {
    return this->Blue_;
  }

  void ColorSpace::
  Blue (const Blue_type& x)
  {
    this->Blue_.set (x);
  }

  void ColorSpace::
  Blue (const Blue_optional& x)
  {
    this->Blue_ = x;
  }

  void ColorSpace::
  Blue (::std::unique_ptr< Blue_type > x)
  {
    this->Blue_.set (std::move (x));
  }

  const ColorSpace::WhitePoint_optional& ColorSpace::
  WhitePoint () const
  {
    return this->WhitePoint_;
  }

  ColorSpace::WhitePoint_optional& ColorSpace::
  WhitePoint ()
  {
    return this->WhitePoint_;
  }

  void ColorSpace::
  WhitePoint (const WhitePoint_type& x)
  {
    this->WhitePoint_.set (x);
  }

  void ColorSpace::
  WhitePoint (const WhitePoint_optional& x)
  {
    this->WhitePoint_ = x;
  }

  void ColorSpace::
  WhitePoint (::std::unique_ptr< WhitePoint_type > x)
  {
    this->WhitePoint_.set (std::move (x));
  }


  // DMXProfiles
  // 

  const DMXProfiles::DMXProfile_sequence& DMXProfiles::
  DMXProfile () const
  {
    return this->DMXProfile_;
  }

  DMXProfiles::DMXProfile_sequence& DMXProfiles::
  DMXProfile ()
  {
    return this->DMXProfile_;
  }

  void DMXProfiles::
  DMXProfile (const DMXProfile_sequence& s)
  {
    this->DMXProfile_ = s;
  }


  // DMXProfile
  // 


  // CRIs
  // 

  const CRIs::CRI_sequence& CRIs::
  CRI () const
  {
    return this->CRI_;
  }

  CRIs::CRI_sequence& CRIs::
  CRI ()
  {
    return this->CRI_;
  }

  void CRIs::
  CRI (const CRI_sequence& s)
  {
    this->CRI_ = s;
  }


  // CRI
  // 

  const CRI::CES_optional& CRI::
  CES () const
  {
    return this->CES_;
  }

  CRI::CES_optional& CRI::
  CES ()
  {
    return this->CES_;
  }

  void CRI::
  CES (const CES_type& x)
  {
    this->CES_.set (x);
  }

  void CRI::
  CES (const CES_optional& x)
  {
    this->CES_ = x;
  }

  void CRI::
  CES (::std::unique_ptr< CES_type > x)
  {
    this->CES_.set (std::move (x));
  }

  const CRI::ColorRenderingIndex_optional& CRI::
  ColorRenderingIndex () const
  {
    return this->ColorRenderingIndex_;
  }

  CRI::ColorRenderingIndex_optional& CRI::
  ColorRenderingIndex ()
  {
    return this->ColorRenderingIndex_;
  }

  void CRI::
  ColorRenderingIndex (const ColorRenderingIndex_type& x)
  {
    this->ColorRenderingIndex_.set (x);
  }

  void CRI::
  ColorRenderingIndex (const ColorRenderingIndex_optional& x)
  {
    this->ColorRenderingIndex_ = x;
  }


  // Protocols
  // 

  const Protocols::RDM_sequence& Protocols::
  RDM () const
  {
    return this->RDM_;
  }

  Protocols::RDM_sequence& Protocols::
  RDM ()
  {
    return this->RDM_;
  }

  void Protocols::
  RDM (const RDM_sequence& s)
  {
    this->RDM_ = s;
  }

  const Protocols::Art_Net_sequence& Protocols::
  Art_Net () const
  {
    return this->Art_Net_;
  }

  Protocols::Art_Net_sequence& Protocols::
  Art_Net ()
  {
    return this->Art_Net_;
  }

  void Protocols::
  Art_Net (const Art_Net_sequence& s)
  {
    this->Art_Net_ = s;
  }

  const Protocols::sACN_sequence& Protocols::
  sACN () const
  {
    return this->sACN_;
  }

  Protocols::sACN_sequence& Protocols::
  sACN ()
  {
    return this->sACN_;
  }

  void Protocols::
  sACN (const sACN_sequence& s)
  {
    this->sACN_ = s;
  }

  const Protocols::KiNET_sequence& Protocols::
  KiNET () const
  {
    return this->KiNET_;
  }

  Protocols::KiNET_sequence& Protocols::
  KiNET ()
  {
    return this->KiNET_;
  }

  void Protocols::
  KiNET (const KiNET_sequence& s)
  {
    this->KiNET_ = s;
  }

  const Protocols::PosiStageNet_sequence& Protocols::
  PosiStageNet () const
  {
    return this->PosiStageNet_;
  }

  Protocols::PosiStageNet_sequence& Protocols::
  PosiStageNet ()
  {
    return this->PosiStageNet_;
  }

  void Protocols::
  PosiStageNet (const PosiStageNet_sequence& s)
  {
    this->PosiStageNet_ = s;
  }

  const Protocols::OpenSoundControl_sequence& Protocols::
  OpenSoundControl () const
  {
    return this->OpenSoundControl_;
  }

  Protocols::OpenSoundControl_sequence& Protocols::
  OpenSoundControl ()
  {
    return this->OpenSoundControl_;
  }

  void Protocols::
  OpenSoundControl (const OpenSoundControl_sequence& s)
  {
    this->OpenSoundControl_ = s;
  }

  const Protocols::CITP_sequence& Protocols::
  CITP () const
  {
    return this->CITP_;
  }

  Protocols::CITP_sequence& Protocols::
  CITP ()
  {
    return this->CITP_;
  }

  void Protocols::
  CITP (const CITP_sequence& s)
  {
    this->CITP_ = s;
  }


  // Art_Net
  // 


  // sACN
  // 


  // KiNET
  // 


  // PosiStageNet
  // 


  // OpenSoundControl
  // 


  // CITP
  // 


  // RDM
  // 

  const RDM::SoftwareVersionID_sequence& RDM::
  SoftwareVersionID () const
  {
    return this->SoftwareVersionID_;
  }

  RDM::SoftwareVersionID_sequence& RDM::
  SoftwareVersionID ()
  {
    return this->SoftwareVersionID_;
  }

  void RDM::
  SoftwareVersionID (const SoftwareVersionID_sequence& s)
  {
    this->SoftwareVersionID_ = s;
  }

  const RDM::ManufacturerID_optional& RDM::
  ManufacturerID () const
  {
    return this->ManufacturerID_;
  }

  RDM::ManufacturerID_optional& RDM::
  ManufacturerID ()
  {
    return this->ManufacturerID_;
  }

  void RDM::
  ManufacturerID (const ManufacturerID_type& x)
  {
    this->ManufacturerID_.set (x);
  }

  void RDM::
  ManufacturerID (const ManufacturerID_optional& x)
  {
    this->ManufacturerID_ = x;
  }

  void RDM::
  ManufacturerID (::std::unique_ptr< ManufacturerID_type > x)
  {
    this->ManufacturerID_.set (std::move (x));
  }

  const RDM::DeviceModelID_optional& RDM::
  DeviceModelID () const
  {
    return this->DeviceModelID_;
  }

  RDM::DeviceModelID_optional& RDM::
  DeviceModelID ()
  {
    return this->DeviceModelID_;
  }

  void RDM::
  DeviceModelID (const DeviceModelID_type& x)
  {
    this->DeviceModelID_.set (x);
  }

  void RDM::
  DeviceModelID (const DeviceModelID_optional& x)
  {
    this->DeviceModelID_ = x;
  }

  void RDM::
  DeviceModelID (::std::unique_ptr< DeviceModelID_type > x)
  {
    this->DeviceModelID_.set (std::move (x));
  }


  // SoftwareVersionID
  // 

  const SoftwareVersionID::DMXPersonality_sequence& SoftwareVersionID::
  DMXPersonality () const
  {
    return this->DMXPersonality_;
  }

  SoftwareVersionID::DMXPersonality_sequence& SoftwareVersionID::
  DMXPersonality ()
  {
    return this->DMXPersonality_;
  }

  void SoftwareVersionID::
  DMXPersonality (const DMXPersonality_sequence& s)
  {
    this->DMXPersonality_ = s;
  }

  const SoftwareVersionID::Value_optional& SoftwareVersionID::
  Value () const
  {
    return this->Value_;
  }

  SoftwareVersionID::Value_optional& SoftwareVersionID::
  Value ()
  {
    return this->Value_;
  }

  void SoftwareVersionID::
  Value (const Value_type& x)
  {
    this->Value_.set (x);
  }

  void SoftwareVersionID::
  Value (const Value_optional& x)
  {
    this->Value_ = x;
  }

  void SoftwareVersionID::
  Value (::std::unique_ptr< Value_type > x)
  {
    this->Value_.set (std::move (x));
  }


  // DMXPersonality
  // 

  const DMXPersonality::Value_optional& DMXPersonality::
  Value () const
  {
    return this->Value_;
  }

  DMXPersonality::Value_optional& DMXPersonality::
  Value ()
  {
    return this->Value_;
  }

  void DMXPersonality::
  Value (const Value_type& x)
  {
    this->Value_.set (x);
  }

  void DMXPersonality::
  Value (const Value_optional& x)
  {
    this->Value_ = x;
  }

  void DMXPersonality::
  Value (::std::unique_ptr< Value_type > x)
  {
    this->Value_.set (std::move (x));
  }

  const DMXPersonality::DMXMode_optional& DMXPersonality::
  DMXMode () const
  {
    return this->DMXMode_;
  }

  DMXPersonality::DMXMode_optional& DMXPersonality::
  DMXMode ()
  {
    return this->DMXMode_;
  }

  void DMXPersonality::
  DMXMode (const DMXMode_type& x)
  {
    this->DMXMode_.set (x);
  }

  void DMXPersonality::
  DMXMode (const DMXMode_optional& x)
  {
    this->DMXMode_ = x;
  }

  void DMXPersonality::
  DMXMode (::std::unique_ptr< DMXMode_type > x)
  {
    this->DMXMode_.set (std::move (x));
  }


  // AttributeDefinitions
  // 

  const AttributeDefinitions::ActivationGroups_optional& AttributeDefinitions::
  ActivationGroups () const
  {
    return this->ActivationGroups_;
  }

  AttributeDefinitions::ActivationGroups_optional& AttributeDefinitions::
  ActivationGroups ()
  {
    return this->ActivationGroups_;
  }

  void AttributeDefinitions::
  ActivationGroups (const ActivationGroups_type& x)
  {
    this->ActivationGroups_.set (x);
  }

  void AttributeDefinitions::
  ActivationGroups (const ActivationGroups_optional& x)
  {
    this->ActivationGroups_ = x;
  }

  void AttributeDefinitions::
  ActivationGroups (::std::unique_ptr< ActivationGroups_type > x)
  {
    this->ActivationGroups_.set (std::move (x));
  }

  const AttributeDefinitions::FeatureGroups_type& AttributeDefinitions::
  FeatureGroups () const
  {
    return this->FeatureGroups_.get ();
  }

  AttributeDefinitions::FeatureGroups_type& AttributeDefinitions::
  FeatureGroups ()
  {
    return this->FeatureGroups_.get ();
  }

  void AttributeDefinitions::
  FeatureGroups (const FeatureGroups_type& x)
  {
    this->FeatureGroups_.set (x);
  }

  void AttributeDefinitions::
  FeatureGroups (::std::unique_ptr< FeatureGroups_type > x)
  {
    this->FeatureGroups_.set (std::move (x));
  }

  const AttributeDefinitions::Attributes_type& AttributeDefinitions::
  Attributes () const
  {
    return this->Attributes_.get ();
  }

  AttributeDefinitions::Attributes_type& AttributeDefinitions::
  Attributes ()
  {
    return this->Attributes_.get ();
  }

  void AttributeDefinitions::
  Attributes (const Attributes_type& x)
  {
    this->Attributes_.set (x);
  }

  void AttributeDefinitions::
  Attributes (::std::unique_ptr< Attributes_type > x)
  {
    this->Attributes_.set (std::move (x));
  }


  // ActivationGroups
  // 

  const ActivationGroups::ActivationGroup_sequence& ActivationGroups::
  ActivationGroup () const
  {
    return this->ActivationGroup_;
  }

  ActivationGroups::ActivationGroup_sequence& ActivationGroups::
  ActivationGroup ()
  {
    return this->ActivationGroup_;
  }

  void ActivationGroups::
  ActivationGroup (const ActivationGroup_sequence& s)
  {
    this->ActivationGroup_ = s;
  }


  // FeatureGroups
  // 

  const FeatureGroups::FeatureGroup_sequence& FeatureGroups::
  FeatureGroup () const
  {
    return this->FeatureGroup_;
  }

  FeatureGroups::FeatureGroup_sequence& FeatureGroups::
  FeatureGroup ()
  {
    return this->FeatureGroup_;
  }

  void FeatureGroups::
  FeatureGroup (const FeatureGroup_sequence& s)
  {
    this->FeatureGroup_ = s;
  }


  // ActivationGroup
  // 

  const ActivationGroup::Name_optional& ActivationGroup::
  Name () const
  {
    return this->Name_;
  }

  ActivationGroup::Name_optional& ActivationGroup::
  Name ()
  {
    return this->Name_;
  }

  void ActivationGroup::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void ActivationGroup::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void ActivationGroup::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }


  // FeatureGroup
  // 

  const FeatureGroup::Feature_sequence& FeatureGroup::
  Feature () const
  {
    return this->Feature_;
  }

  FeatureGroup::Feature_sequence& FeatureGroup::
  Feature ()
  {
    return this->Feature_;
  }

  void FeatureGroup::
  Feature (const Feature_sequence& s)
  {
    this->Feature_ = s;
  }

  const FeatureGroup::Name_type& FeatureGroup::
  Name () const
  {
    return this->Name_.get ();
  }

  FeatureGroup::Name_type& FeatureGroup::
  Name ()
  {
    return this->Name_.get ();
  }

  void FeatureGroup::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void FeatureGroup::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const FeatureGroup::Pretty_type& FeatureGroup::
  Pretty () const
  {
    return this->Pretty_.get ();
  }

  FeatureGroup::Pretty_type& FeatureGroup::
  Pretty ()
  {
    return this->Pretty_.get ();
  }

  void FeatureGroup::
  Pretty (const Pretty_type& x)
  {
    this->Pretty_.set (x);
  }

  void FeatureGroup::
  Pretty (::std::unique_ptr< Pretty_type > x)
  {
    this->Pretty_.set (std::move (x));
  }


  // Feature
  // 

  const Feature::Name_optional& Feature::
  Name () const
  {
    return this->Name_;
  }

  Feature::Name_optional& Feature::
  Name ()
  {
    return this->Name_;
  }

  void Feature::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Feature::
  Name (const Name_optional& x)
  {
    this->Name_ = x;
  }

  void Feature::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }


  // Attributes
  // 

  const Attributes::Attribute_sequence& Attributes::
  Attribute () const
  {
    return this->Attribute_;
  }

  Attributes::Attribute_sequence& Attributes::
  Attribute ()
  {
    return this->Attribute_;
  }

  void Attributes::
  Attribute (const Attribute_sequence& s)
  {
    this->Attribute_ = s;
  }


  // Attribute
  // 

  const Attribute::Name_type& Attribute::
  Name () const
  {
    return this->Name_.get ();
  }

  Attribute::Name_type& Attribute::
  Name ()
  {
    return this->Name_.get ();
  }

  void Attribute::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void Attribute::
  Name (::std::unique_ptr< Name_type > x)
  {
    this->Name_.set (std::move (x));
  }

  const Attribute::Pretty_type& Attribute::
  Pretty () const
  {
    return this->Pretty_.get ();
  }

  Attribute::Pretty_type& Attribute::
  Pretty ()
  {
    return this->Pretty_.get ();
  }

  void Attribute::
  Pretty (const Pretty_type& x)
  {
    this->Pretty_.set (x);
  }

  void Attribute::
  Pretty (::std::unique_ptr< Pretty_type > x)
  {
    this->Pretty_.set (std::move (x));
  }

  const Attribute::ActivationGroup_optional& Attribute::
  ActivationGroup () const
  {
    return this->ActivationGroup_;
  }

  Attribute::ActivationGroup_optional& Attribute::
  ActivationGroup ()
  {
    return this->ActivationGroup_;
  }

  void Attribute::
  ActivationGroup (const ActivationGroup_type& x)
  {
    this->ActivationGroup_.set (x);
  }

  void Attribute::
  ActivationGroup (const ActivationGroup_optional& x)
  {
    this->ActivationGroup_ = x;
  }

  void Attribute::
  ActivationGroup (::std::unique_ptr< ActivationGroup_type > x)
  {
    this->ActivationGroup_.set (std::move (x));
  }

  const Attribute::PhysicalUnit_optional& Attribute::
  PhysicalUnit () const
  {
    return this->PhysicalUnit_;
  }

  Attribute::PhysicalUnit_optional& Attribute::
  PhysicalUnit ()
  {
    return this->PhysicalUnit_;
  }

  void Attribute::
  PhysicalUnit (const PhysicalUnit_type& x)
  {
    this->PhysicalUnit_.set (x);
  }

  void Attribute::
  PhysicalUnit (const PhysicalUnit_optional& x)
  {
    this->PhysicalUnit_ = x;
  }

  void Attribute::
  PhysicalUnit (::std::unique_ptr< PhysicalUnit_type > x)
  {
    this->PhysicalUnit_.set (std::move (x));
  }

  const Attribute::Color_optional& Attribute::
  Color () const
  {
    return this->Color_;
  }

  Attribute::Color_optional& Attribute::
  Color ()
  {
    return this->Color_;
  }

  void Attribute::
  Color (const Color_type& x)
  {
    this->Color_.set (x);
  }

  void Attribute::
  Color (const Color_optional& x)
  {
    this->Color_ = x;
  }

  void Attribute::
  Color (::std::unique_ptr< Color_type > x)
  {
    this->Color_.set (std::move (x));
  }

  const Attribute::Feature_optional& Attribute::
  Feature () const
  {
    return this->Feature_;
  }

  Attribute::Feature_optional& Attribute::
  Feature ()
  {
    return this->Feature_;
  }

  void Attribute::
  Feature (const Feature_type& x)
  {
    this->Feature_.set (x);
  }

  void Attribute::
  Feature (const Feature_optional& x)
  {
    this->Feature_ = x;
  }

  void Attribute::
  Feature (::std::unique_ptr< Feature_type > x)
  {
    this->Feature_.set (std::move (x));
  }

  const Attribute::MainAttribute_optional& Attribute::
  MainAttribute () const
  {
    return this->MainAttribute_;
  }

  Attribute::MainAttribute_optional& Attribute::
  MainAttribute ()
  {
    return this->MainAttribute_;
  }

  void Attribute::
  MainAttribute (const MainAttribute_type& x)
  {
    this->MainAttribute_.set (x);
  }

  void Attribute::
  MainAttribute (const MainAttribute_optional& x)
  {
    this->MainAttribute_ = x;
  }

  void Attribute::
  MainAttribute (::std::unique_ptr< MainAttribute_type > x)
  {
    this->MainAttribute_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace device
{
  // matrixtype
  //

  matrixtype::
  matrixtype ()
  : ::xml_schema::string ()
  {
  }

  matrixtype::
  matrixtype (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  matrixtype::
  matrixtype (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  matrixtype::
  matrixtype (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  matrixtype::
  matrixtype (const matrixtype& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  matrixtype::
  matrixtype (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  matrixtype::
  matrixtype (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  matrixtype::
  matrixtype (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  matrixtype* matrixtype::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class matrixtype (*this, f, c);
  }

  matrixtype::
  ~matrixtype ()
  {
  }

  // colorcietype
  //

  colorcietype::
  colorcietype ()
  : ::xml_schema::string ()
  {
  }

  colorcietype::
  colorcietype (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  colorcietype::
  colorcietype (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  colorcietype::
  colorcietype (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  colorcietype::
  colorcietype (const colorcietype& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  colorcietype::
  colorcietype (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  colorcietype::
  colorcietype (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  colorcietype::
  colorcietype (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  colorcietype* colorcietype::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class colorcietype (*this, f, c);
  }

  colorcietype::
  ~colorcietype ()
  {
  }

  // offsettype
  //

  offsettype::
  offsettype ()
  : ::xml_schema::string ()
  {
  }

  offsettype::
  offsettype (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  offsettype::
  offsettype (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  offsettype::
  offsettype (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  offsettype::
  offsettype (const offsettype& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  offsettype::
  offsettype (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  offsettype::
  offsettype (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  offsettype::
  offsettype (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  offsettype* offsettype::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class offsettype (*this, f, c);
  }

  offsettype::
  ~offsettype ()
  {
  }

  // dmxtype
  //

  dmxtype::
  dmxtype ()
  : ::xml_schema::string ()
  {
  }

  dmxtype::
  dmxtype (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  dmxtype::
  dmxtype (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  dmxtype::
  dmxtype (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  dmxtype::
  dmxtype (const dmxtype& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  dmxtype::
  dmxtype (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  dmxtype::
  dmxtype (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  dmxtype::
  dmxtype (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  dmxtype* dmxtype::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dmxtype (*this, f, c);
  }

  dmxtype::
  ~dmxtype ()
  {
  }

  // dmxvalue
  //

  dmxvalue::
  dmxvalue ()
  : ::xml_schema::string ()
  {
  }

  dmxvalue::
  dmxvalue (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  dmxvalue::
  dmxvalue (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  dmxvalue::
  dmxvalue (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  dmxvalue::
  dmxvalue (const dmxvalue& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  dmxvalue::
  dmxvalue (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  dmxvalue::
  dmxvalue (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  dmxvalue::
  dmxvalue (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  dmxvalue* dmxvalue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dmxvalue (*this, f, c);
  }

  dmxvalue::
  ~dmxvalue ()
  {
  }

  // nametype
  //

  nametype::
  nametype ()
  : ::xml_schema::string ()
  {
  }

  nametype::
  nametype (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  nametype::
  nametype (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  nametype::
  nametype (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  nametype::
  nametype (const nametype& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  nametype::
  nametype (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  nametype::
  nametype (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  nametype::
  nametype (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  nametype* nametype::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class nametype (*this, f, c);
  }

  nametype::
  ~nametype ()
  {
  }

  // dataversion
  //

  dataversion::
  dataversion (const ::xml_schema::float_& _xsd_float__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base)
  {
  }

  dataversion::
  dataversion (const dataversion& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  dataversion::
  dataversion (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  dataversion::
  dataversion (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  dataversion::
  dataversion (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  dataversion* dataversion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dataversion (*this, f, c);
  }

  dataversion::
  ~dataversion ()
  {
  }

  // guidtype
  //

  guidtype::
  guidtype ()
  : ::xml_schema::string ()
  {
  }

  guidtype::
  guidtype (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  guidtype::
  guidtype (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  guidtype::
  guidtype (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  guidtype::
  guidtype (const guidtype& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  guidtype::
  guidtype (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  guidtype::
  guidtype (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  guidtype::
  guidtype (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  guidtype* guidtype::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class guidtype (*this, f, c);
  }

  guidtype::
  ~guidtype ()
  {
  }

  // PhysicalUnitEnum
  //

  PhysicalUnitEnum::
  PhysicalUnitEnum (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_PhysicalUnitEnum_convert ();
  }

  PhysicalUnitEnum::
  PhysicalUnitEnum (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_PhysicalUnitEnum_convert ();
  }

  PhysicalUnitEnum::
  PhysicalUnitEnum (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_PhysicalUnitEnum_convert ();
  }

  PhysicalUnitEnum* PhysicalUnitEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalUnitEnum (*this, f, c);
  }

  PhysicalUnitEnum::value PhysicalUnitEnum::
  _xsd_PhysicalUnitEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PhysicalUnitEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_PhysicalUnitEnum_indexes_,
                      _xsd_PhysicalUnitEnum_indexes_ + 22,
                      *this,
                      c));

    if (i == _xsd_PhysicalUnitEnum_indexes_ + 22 || _xsd_PhysicalUnitEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PhysicalUnitEnum::
  _xsd_PhysicalUnitEnum_literals_[22] =
  {
    "None",
    "Percent",
    "Length",
    "Mass",
    "Time",
    "Temperature",
    "LuminousIntensity",
    "Angle",
    "Force",
    "Frequency",
    "Current",
    "Voltage",
    "Power",
    "Energy",
    "Area",
    "Volume",
    "Speed",
    "Acceleration",
    "AngularSpeed",
    "AngularAccc",
    "WaveLength",
    "ColorComponent"
  };

  const PhysicalUnitEnum::value PhysicalUnitEnum::
  _xsd_PhysicalUnitEnum_indexes_[22] =
  {
    ::device::PhysicalUnitEnum::Acceleration,
    ::device::PhysicalUnitEnum::Angle,
    ::device::PhysicalUnitEnum::AngularAccc,
    ::device::PhysicalUnitEnum::AngularSpeed,
    ::device::PhysicalUnitEnum::Area,
    ::device::PhysicalUnitEnum::ColorComponent,
    ::device::PhysicalUnitEnum::Current,
    ::device::PhysicalUnitEnum::Energy,
    ::device::PhysicalUnitEnum::Force,
    ::device::PhysicalUnitEnum::Frequency,
    ::device::PhysicalUnitEnum::Length,
    ::device::PhysicalUnitEnum::LuminousIntensity,
    ::device::PhysicalUnitEnum::Mass,
    ::device::PhysicalUnitEnum::None,
    ::device::PhysicalUnitEnum::Percent,
    ::device::PhysicalUnitEnum::Power,
    ::device::PhysicalUnitEnum::Speed,
    ::device::PhysicalUnitEnum::Temperature,
    ::device::PhysicalUnitEnum::Time,
    ::device::PhysicalUnitEnum::Voltage,
    ::device::PhysicalUnitEnum::Volume,
    ::device::PhysicalUnitEnum::WaveLength
  };

  // MasterEnum
  //

  MasterEnum::
  MasterEnum (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_MasterEnum_convert ();
  }

  MasterEnum::
  MasterEnum (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_MasterEnum_convert ();
  }

  MasterEnum::
  MasterEnum (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_MasterEnum_convert ();
  }

  MasterEnum* MasterEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MasterEnum (*this, f, c);
  }

  MasterEnum::value MasterEnum::
  _xsd_MasterEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MasterEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_MasterEnum_indexes_,
                      _xsd_MasterEnum_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_MasterEnum_indexes_ + 3 || _xsd_MasterEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MasterEnum::
  _xsd_MasterEnum_literals_[3] =
  {
    "None",
    "Grand",
    "Group"
  };

  const MasterEnum::value MasterEnum::
  _xsd_MasterEnum_indexes_[3] =
  {
    ::device::MasterEnum::Grand,
    ::device::MasterEnum::Group,
    ::device::MasterEnum::None
  };

  // PrimitiveTypeEnum
  //

  PrimitiveTypeEnum::
  PrimitiveTypeEnum (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_PrimitiveTypeEnum_convert ();
  }

  PrimitiveTypeEnum::
  PrimitiveTypeEnum (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_PrimitiveTypeEnum_convert ();
  }

  PrimitiveTypeEnum::
  PrimitiveTypeEnum (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_PrimitiveTypeEnum_convert ();
  }

  PrimitiveTypeEnum* PrimitiveTypeEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PrimitiveTypeEnum (*this, f, c);
  }

  PrimitiveTypeEnum::value PrimitiveTypeEnum::
  _xsd_PrimitiveTypeEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PrimitiveTypeEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_PrimitiveTypeEnum_indexes_,
                      _xsd_PrimitiveTypeEnum_indexes_ + 9,
                      *this,
                      c));

    if (i == _xsd_PrimitiveTypeEnum_indexes_ + 9 || _xsd_PrimitiveTypeEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PrimitiveTypeEnum::
  _xsd_PrimitiveTypeEnum_literals_[9] =
  {
    "Undefined",
    "Cube",
    "Cylinder",
    "Sphere",
    "Base",
    "Yoke",
    "Head",
    "Scanner",
    "Conventional"
  };

  const PrimitiveTypeEnum::value PrimitiveTypeEnum::
  _xsd_PrimitiveTypeEnum_indexes_[9] =
  {
    ::device::PrimitiveTypeEnum::Base,
    ::device::PrimitiveTypeEnum::Conventional,
    ::device::PrimitiveTypeEnum::Cube,
    ::device::PrimitiveTypeEnum::Cylinder,
    ::device::PrimitiveTypeEnum::Head,
    ::device::PrimitiveTypeEnum::Scanner,
    ::device::PrimitiveTypeEnum::Sphere,
    ::device::PrimitiveTypeEnum::Undefined,
    ::device::PrimitiveTypeEnum::Yoke
  };

  // LampTypeEnum
  //

  LampTypeEnum::
  LampTypeEnum (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_LampTypeEnum_convert ();
  }

  LampTypeEnum::
  LampTypeEnum (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_LampTypeEnum_convert ();
  }

  LampTypeEnum::
  LampTypeEnum (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_LampTypeEnum_convert ();
  }

  LampTypeEnum* LampTypeEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LampTypeEnum (*this, f, c);
  }

  LampTypeEnum::value LampTypeEnum::
  _xsd_LampTypeEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LampTypeEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_LampTypeEnum_indexes_,
                      _xsd_LampTypeEnum_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_LampTypeEnum_indexes_ + 4 || _xsd_LampTypeEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const LampTypeEnum::
  _xsd_LampTypeEnum_literals_[4] =
  {
    "Discharge",
    "Tungsten",
    "Halogen",
    "LED"
  };

  const LampTypeEnum::value LampTypeEnum::
  _xsd_LampTypeEnum_indexes_[4] =
  {
    ::device::LampTypeEnum::Discharge,
    ::device::LampTypeEnum::Halogen,
    ::device::LampTypeEnum::LED,
    ::device::LampTypeEnum::Tungsten
  };

  // BeamTypeEnum
  //

  BeamTypeEnum::
  BeamTypeEnum (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_BeamTypeEnum_convert ();
  }

  BeamTypeEnum::
  BeamTypeEnum (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_BeamTypeEnum_convert ();
  }

  BeamTypeEnum::
  BeamTypeEnum (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_BeamTypeEnum_convert ();
  }

  BeamTypeEnum* BeamTypeEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BeamTypeEnum (*this, f, c);
  }

  BeamTypeEnum::value BeamTypeEnum::
  _xsd_BeamTypeEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BeamTypeEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_BeamTypeEnum_indexes_,
                      _xsd_BeamTypeEnum_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_BeamTypeEnum_indexes_ + 3 || _xsd_BeamTypeEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const BeamTypeEnum::
  _xsd_BeamTypeEnum_literals_[3] =
  {
    "Wash",
    "Spot",
    "None"
  };

  const BeamTypeEnum::value BeamTypeEnum::
  _xsd_BeamTypeEnum_indexes_[3] =
  {
    ::device::BeamTypeEnum::None,
    ::device::BeamTypeEnum::Spot,
    ::device::BeamTypeEnum::Wash
  };

  // ColorSpaceEnum
  //

  ColorSpaceEnum::
  ColorSpaceEnum (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ColorSpaceEnum_convert ();
  }

  ColorSpaceEnum::
  ColorSpaceEnum (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ColorSpaceEnum_convert ();
  }

  ColorSpaceEnum::
  ColorSpaceEnum (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ColorSpaceEnum_convert ();
  }

  ColorSpaceEnum* ColorSpaceEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ColorSpaceEnum (*this, f, c);
  }

  ColorSpaceEnum::value ColorSpaceEnum::
  _xsd_ColorSpaceEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ColorSpaceEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ColorSpaceEnum_indexes_,
                      _xsd_ColorSpaceEnum_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_ColorSpaceEnum_indexes_ + 4 || _xsd_ColorSpaceEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ColorSpaceEnum::
  _xsd_ColorSpaceEnum_literals_[4] =
  {
    "Custom",
    "sRGB",
    "ProPhoto",
    "ANSI"
  };

  const ColorSpaceEnum::value ColorSpaceEnum::
  _xsd_ColorSpaceEnum_indexes_[4] =
  {
    ::device::ColorSpaceEnum::ANSI,
    ::device::ColorSpaceEnum::Custom,
    ::device::ColorSpaceEnum::ProPhoto,
    ::device::ColorSpaceEnum::sRGB
  };

  // InterpolationToEnum
  //

  InterpolationToEnum::
  InterpolationToEnum (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_InterpolationToEnum_convert ();
  }

  InterpolationToEnum::
  InterpolationToEnum (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_InterpolationToEnum_convert ();
  }

  InterpolationToEnum::
  InterpolationToEnum (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_InterpolationToEnum_convert ();
  }

  InterpolationToEnum* InterpolationToEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InterpolationToEnum (*this, f, c);
  }

  InterpolationToEnum::value InterpolationToEnum::
  _xsd_InterpolationToEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InterpolationToEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_InterpolationToEnum_indexes_,
                      _xsd_InterpolationToEnum_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_InterpolationToEnum_indexes_ + 3 || _xsd_InterpolationToEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const InterpolationToEnum::
  _xsd_InterpolationToEnum_literals_[3] =
  {
    "Linear",
    "Step",
    "Log"
  };

  const InterpolationToEnum::value InterpolationToEnum::
  _xsd_InterpolationToEnum_indexes_[3] =
  {
    ::device::InterpolationToEnum::Linear,
    ::device::InterpolationToEnum::Log,
    ::device::InterpolationToEnum::Step
  };

  // SnapEnum
  //

  SnapEnum::
  SnapEnum (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_SnapEnum_convert ();
  }

  SnapEnum::
  SnapEnum (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_SnapEnum_convert ();
  }

  SnapEnum::
  SnapEnum (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_SnapEnum_convert ();
  }

  SnapEnum* SnapEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SnapEnum (*this, f, c);
  }

  SnapEnum::value SnapEnum::
  _xsd_SnapEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SnapEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_SnapEnum_indexes_,
                      _xsd_SnapEnum_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_SnapEnum_indexes_ + 4 || _xsd_SnapEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const SnapEnum::
  _xsd_SnapEnum_literals_[4] =
  {
    "Yes",
    "No",
    "On",
    "Off"
  };

  const SnapEnum::value SnapEnum::
  _xsd_SnapEnum_indexes_[4] =
  {
    ::device::SnapEnum::No,
    ::device::SnapEnum::Off,
    ::device::SnapEnum::On,
    ::device::SnapEnum::Yes
  };

  // YesNoEnum
  //

  YesNoEnum::
  YesNoEnum (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_YesNoEnum_convert ();
  }

  YesNoEnum::
  YesNoEnum (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_YesNoEnum_convert ();
  }

  YesNoEnum::
  YesNoEnum (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_YesNoEnum_convert ();
  }

  YesNoEnum* YesNoEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class YesNoEnum (*this, f, c);
  }

  YesNoEnum::value YesNoEnum::
  _xsd_YesNoEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_YesNoEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_YesNoEnum_indexes_,
                      _xsd_YesNoEnum_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_YesNoEnum_indexes_ + 2 || _xsd_YesNoEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const YesNoEnum::
  _xsd_YesNoEnum_literals_[2] =
  {
    "Yes",
    "No"
  };

  const YesNoEnum::value YesNoEnum::
  _xsd_YesNoEnum_indexes_[2] =
  {
    ::device::YesNoEnum::No,
    ::device::YesNoEnum::Yes
  };

  // RelationTypesEnum
  //

  RelationTypesEnum::
  RelationTypesEnum (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RelationTypesEnum_convert ();
  }

  RelationTypesEnum::
  RelationTypesEnum (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RelationTypesEnum_convert ();
  }

  RelationTypesEnum::
  RelationTypesEnum (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RelationTypesEnum_convert ();
  }

  RelationTypesEnum* RelationTypesEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RelationTypesEnum (*this, f, c);
  }

  RelationTypesEnum::value RelationTypesEnum::
  _xsd_RelationTypesEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RelationTypesEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RelationTypesEnum_indexes_,
                      _xsd_RelationTypesEnum_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_RelationTypesEnum_indexes_ + 2 || _xsd_RelationTypesEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RelationTypesEnum::
  _xsd_RelationTypesEnum_literals_[2] =
  {
    "Multiply",
    "Override"
  };

  const RelationTypesEnum::value RelationTypesEnum::
  _xsd_RelationTypesEnum_indexes_[2] =
  {
    ::device::RelationTypesEnum::Multiply,
    ::device::RelationTypesEnum::Override
  };

  // RDMParameterTypeEnum
  //

  RDMParameterTypeEnum::
  RDMParameterTypeEnum (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RDMParameterTypeEnum_convert ();
  }

  RDMParameterTypeEnum::
  RDMParameterTypeEnum (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RDMParameterTypeEnum_convert ();
  }

  RDMParameterTypeEnum::
  RDMParameterTypeEnum (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RDMParameterTypeEnum_convert ();
  }

  RDMParameterTypeEnum* RDMParameterTypeEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RDMParameterTypeEnum (*this, f, c);
  }

  RDMParameterTypeEnum::value RDMParameterTypeEnum::
  _xsd_RDMParameterTypeEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RDMParameterTypeEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RDMParameterTypeEnum_indexes_,
                      _xsd_RDMParameterTypeEnum_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_RDMParameterTypeEnum_indexes_ + 3 || _xsd_RDMParameterTypeEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RDMParameterTypeEnum::
  _xsd_RDMParameterTypeEnum_literals_[3] =
  {
    "RDM",
    "FixtureType",
    "Fixture"
  };

  const RDMParameterTypeEnum::value RDMParameterTypeEnum::
  _xsd_RDMParameterTypeEnum_indexes_[3] =
  {
    ::device::RDMParameterTypeEnum::Fixture,
    ::device::RDMParameterTypeEnum::FixtureType,
    ::device::RDMParameterTypeEnum::RDM
  };

  // ThresholdOperatorEnum
  //

  ThresholdOperatorEnum::
  ThresholdOperatorEnum (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ThresholdOperatorEnum_convert ();
  }

  ThresholdOperatorEnum::
  ThresholdOperatorEnum (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ThresholdOperatorEnum_convert ();
  }

  ThresholdOperatorEnum::
  ThresholdOperatorEnum (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ThresholdOperatorEnum_convert ();
  }

  ThresholdOperatorEnum* ThresholdOperatorEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ThresholdOperatorEnum (*this, f, c);
  }

  ThresholdOperatorEnum::value ThresholdOperatorEnum::
  _xsd_ThresholdOperatorEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ThresholdOperatorEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ThresholdOperatorEnum_indexes_,
                      _xsd_ThresholdOperatorEnum_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_ThresholdOperatorEnum_indexes_ + 4 || _xsd_ThresholdOperatorEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ThresholdOperatorEnum::
  _xsd_ThresholdOperatorEnum_literals_[4] =
  {
    "Is",
    "IsNot",
    "Greater",
    "Less"
  };

  const ThresholdOperatorEnum::value ThresholdOperatorEnum::
  _xsd_ThresholdOperatorEnum_indexes_[4] =
  {
    ::device::ThresholdOperatorEnum::Greater,
    ::device::ThresholdOperatorEnum::Is,
    ::device::ThresholdOperatorEnum::IsNot,
    ::device::ThresholdOperatorEnum::Less
  };

  // RDMParameterDataTypeEnum
  //

  RDMParameterDataTypeEnum::
  RDMParameterDataTypeEnum (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RDMParameterDataTypeEnum_convert ();
  }

  RDMParameterDataTypeEnum::
  RDMParameterDataTypeEnum (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RDMParameterDataTypeEnum_convert ();
  }

  RDMParameterDataTypeEnum::
  RDMParameterDataTypeEnum (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RDMParameterDataTypeEnum_convert ();
  }

  RDMParameterDataTypeEnum* RDMParameterDataTypeEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RDMParameterDataTypeEnum (*this, f, c);
  }

  RDMParameterDataTypeEnum::value RDMParameterDataTypeEnum::
  _xsd_RDMParameterDataTypeEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RDMParameterDataTypeEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RDMParameterDataTypeEnum_indexes_,
                      _xsd_RDMParameterDataTypeEnum_indexes_ + 10,
                      *this,
                      c));

    if (i == _xsd_RDMParameterDataTypeEnum_indexes_ + 10 || _xsd_RDMParameterDataTypeEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RDMParameterDataTypeEnum::
  _xsd_RDMParameterDataTypeEnum_literals_[10] =
  {
    "DS_NOT_DEFINED",
    "DS_BIT_FIELD",
    "DS_ASCII",
    "DS_UNSIGNED_BYTE",
    "DS_SIGNED_BYTE",
    "DS_UNSIGNED_WORD",
    "DS_SIGNED_WORD",
    "DS_UNSIGNED_DWORD",
    "DS_SIGNED_DWORD",
    "DS_MS"
  };

  const RDMParameterDataTypeEnum::value RDMParameterDataTypeEnum::
  _xsd_RDMParameterDataTypeEnum_indexes_[10] =
  {
    ::device::RDMParameterDataTypeEnum::DS_ASCII,
    ::device::RDMParameterDataTypeEnum::DS_BIT_FIELD,
    ::device::RDMParameterDataTypeEnum::DS_MS,
    ::device::RDMParameterDataTypeEnum::DS_NOT_DEFINED,
    ::device::RDMParameterDataTypeEnum::DS_SIGNED_BYTE,
    ::device::RDMParameterDataTypeEnum::DS_SIGNED_DWORD,
    ::device::RDMParameterDataTypeEnum::DS_SIGNED_WORD,
    ::device::RDMParameterDataTypeEnum::DS_UNSIGNED_BYTE,
    ::device::RDMParameterDataTypeEnum::DS_UNSIGNED_DWORD,
    ::device::RDMParameterDataTypeEnum::DS_UNSIGNED_WORD
  };

  // RDMParameterCommandEnum
  //

  RDMParameterCommandEnum::
  RDMParameterCommandEnum (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RDMParameterCommandEnum_convert ();
  }

  RDMParameterCommandEnum::
  RDMParameterCommandEnum (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RDMParameterCommandEnum_convert ();
  }

  RDMParameterCommandEnum::
  RDMParameterCommandEnum (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RDMParameterCommandEnum_convert ();
  }

  RDMParameterCommandEnum* RDMParameterCommandEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RDMParameterCommandEnum (*this, f, c);
  }

  RDMParameterCommandEnum::value RDMParameterCommandEnum::
  _xsd_RDMParameterCommandEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RDMParameterCommandEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RDMParameterCommandEnum_indexes_,
                      _xsd_RDMParameterCommandEnum_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_RDMParameterCommandEnum_indexes_ + 4 || _xsd_RDMParameterCommandEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RDMParameterCommandEnum::
  _xsd_RDMParameterCommandEnum_literals_[4] =
  {
    "None",
    "CC_GET",
    "CC_SET",
    "CC_GET_SET"
  };

  const RDMParameterCommandEnum::value RDMParameterCommandEnum::
  _xsd_RDMParameterCommandEnum_indexes_[4] =
  {
    ::device::RDMParameterCommandEnum::CC_GET,
    ::device::RDMParameterCommandEnum::CC_GET_SET,
    ::device::RDMParameterCommandEnum::CC_SET,
    ::device::RDMParameterCommandEnum::None
  };

  // RDMSensorTypeEnum
  //

  RDMSensorTypeEnum::
  RDMSensorTypeEnum (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RDMSensorTypeEnum_convert ();
  }

  RDMSensorTypeEnum::
  RDMSensorTypeEnum (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RDMSensorTypeEnum_convert ();
  }

  RDMSensorTypeEnum::
  RDMSensorTypeEnum (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RDMSensorTypeEnum_convert ();
  }

  RDMSensorTypeEnum* RDMSensorTypeEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RDMSensorTypeEnum (*this, f, c);
  }

  RDMSensorTypeEnum::value RDMSensorTypeEnum::
  _xsd_RDMSensorTypeEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RDMSensorTypeEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RDMSensorTypeEnum_indexes_,
                      _xsd_RDMSensorTypeEnum_indexes_ + 34,
                      *this,
                      c));

    if (i == _xsd_RDMSensorTypeEnum_indexes_ + 34 || _xsd_RDMSensorTypeEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RDMSensorTypeEnum::
  _xsd_RDMSensorTypeEnum_literals_[34] =
  {
    "SENS_VOLTAGE",
    "SENS_CURRENT",
    "SENS_FREQUENCY",
    "SENS_RESISTANCE",
    "SENS_POWER",
    "SENS_MASS",
    "SENS_LENGTH",
    "SENS_AREA",
    "SENS_VOLUME",
    "SENS_DENSITY",
    "SENS_VELOCITY",
    "SENS_ACCELERATION",
    "SENS_FORCE",
    "SENS_ENERGY",
    "SENS_PRESSURE",
    "SENS_TIME",
    "SENS_ANGLE",
    "SENS_POSITION_X",
    "SENS_POSITION_Y",
    "SENS_POSITION_Z",
    "SENS_ANGULAR_VELOCITY",
    "SENS_LUMINOUS_INTENSITY",
    "SENS_LUMINOUS_FLUX",
    "SENS_ILLUMINANCE",
    "SENS_CHROMINANCE_RED",
    "SENS_CHROMINANCE_GREEN",
    "SENS_CHROMINANCE_BLUE",
    "SENS_CONTACTS",
    "SENS_MEMORY",
    "SENS_ITEMS",
    "SENS_HUMIDITY",
    "SENS_COUNTER_16BIT",
    "SENS_OTHER",
    "SENS_MS"
  };

  const RDMSensorTypeEnum::value RDMSensorTypeEnum::
  _xsd_RDMSensorTypeEnum_indexes_[34] =
  {
    ::device::RDMSensorTypeEnum::SENS_ACCELERATION,
    ::device::RDMSensorTypeEnum::SENS_ANGLE,
    ::device::RDMSensorTypeEnum::SENS_ANGULAR_VELOCITY,
    ::device::RDMSensorTypeEnum::SENS_AREA,
    ::device::RDMSensorTypeEnum::SENS_CHROMINANCE_BLUE,
    ::device::RDMSensorTypeEnum::SENS_CHROMINANCE_GREEN,
    ::device::RDMSensorTypeEnum::SENS_CHROMINANCE_RED,
    ::device::RDMSensorTypeEnum::SENS_CONTACTS,
    ::device::RDMSensorTypeEnum::SENS_COUNTER_16BIT,
    ::device::RDMSensorTypeEnum::SENS_CURRENT,
    ::device::RDMSensorTypeEnum::SENS_DENSITY,
    ::device::RDMSensorTypeEnum::SENS_ENERGY,
    ::device::RDMSensorTypeEnum::SENS_FORCE,
    ::device::RDMSensorTypeEnum::SENS_FREQUENCY,
    ::device::RDMSensorTypeEnum::SENS_HUMIDITY,
    ::device::RDMSensorTypeEnum::SENS_ILLUMINANCE,
    ::device::RDMSensorTypeEnum::SENS_ITEMS,
    ::device::RDMSensorTypeEnum::SENS_LENGTH,
    ::device::RDMSensorTypeEnum::SENS_LUMINOUS_FLUX,
    ::device::RDMSensorTypeEnum::SENS_LUMINOUS_INTENSITY,
    ::device::RDMSensorTypeEnum::SENS_MASS,
    ::device::RDMSensorTypeEnum::SENS_MEMORY,
    ::device::RDMSensorTypeEnum::SENS_MS,
    ::device::RDMSensorTypeEnum::SENS_OTHER,
    ::device::RDMSensorTypeEnum::SENS_POSITION_X,
    ::device::RDMSensorTypeEnum::SENS_POSITION_Y,
    ::device::RDMSensorTypeEnum::SENS_POSITION_Z,
    ::device::RDMSensorTypeEnum::SENS_POWER,
    ::device::RDMSensorTypeEnum::SENS_PRESSURE,
    ::device::RDMSensorTypeEnum::SENS_RESISTANCE,
    ::device::RDMSensorTypeEnum::SENS_TIME,
    ::device::RDMSensorTypeEnum::SENS_VELOCITY,
    ::device::RDMSensorTypeEnum::SENS_VOLTAGE,
    ::device::RDMSensorTypeEnum::SENS_VOLUME
  };

  // RDMParameterSensorUnitEnum
  //

  RDMParameterSensorUnitEnum::
  RDMParameterSensorUnitEnum (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RDMParameterSensorUnitEnum_convert ();
  }

  RDMParameterSensorUnitEnum::
  RDMParameterSensorUnitEnum (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RDMParameterSensorUnitEnum_convert ();
  }

  RDMParameterSensorUnitEnum::
  RDMParameterSensorUnitEnum (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RDMParameterSensorUnitEnum_convert ();
  }

  RDMParameterSensorUnitEnum* RDMParameterSensorUnitEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RDMParameterSensorUnitEnum (*this, f, c);
  }

  RDMParameterSensorUnitEnum::value RDMParameterSensorUnitEnum::
  _xsd_RDMParameterSensorUnitEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RDMParameterSensorUnitEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RDMParameterSensorUnitEnum_indexes_,
                      _xsd_RDMParameterSensorUnitEnum_indexes_ + 30,
                      *this,
                      c));

    if (i == _xsd_RDMParameterSensorUnitEnum_indexes_ + 30 || _xsd_RDMParameterSensorUnitEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RDMParameterSensorUnitEnum::
  _xsd_RDMParameterSensorUnitEnum_literals_[30] =
  {
    "UNITS_NONE",
    "UNITS_CENTIGRADE",
    "UNITS_VOLTS_DC",
    "UNITS_VOLTS_AC_PEAK",
    "UNITS_VOLTS_AC_RMS",
    "UNITS_AMPERE_DC",
    "UNITS_AMPERE_AC_PEAK",
    "UNITS_AMPERE_AC_RMS",
    "UNITS_HERTZ",
    "UNITS_OHM",
    "UNITS_WATT",
    "UNITS_KILOGRAM",
    "UNITS_METERS",
    "UNITS_METERS_SQUARED",
    "UNITS_METERS_CUBED",
    "UNITS_KILOGRAMMES_PER_METER_CUBED",
    "UNITS_METERS_PER_SECOND",
    "UNITS_METERS_PER_SECOND_SQUARED",
    "UNITS_NEWTON",
    "UNITS_JOULE",
    "UNITS_PASCAL",
    "UNITS_SECOND",
    "UNITS_DEGREE",
    "UNITS_STERADIAN",
    "UNITS_CANDELA",
    "UNITS_LUMEN",
    "UNITS_LUX",
    "UNITS_IRE",
    "UNITS_BYTE",
    "UNITS_MS"
  };

  const RDMParameterSensorUnitEnum::value RDMParameterSensorUnitEnum::
  _xsd_RDMParameterSensorUnitEnum_indexes_[30] =
  {
    ::device::RDMParameterSensorUnitEnum::UNITS_AMPERE_AC_PEAK,
    ::device::RDMParameterSensorUnitEnum::UNITS_AMPERE_AC_RMS,
    ::device::RDMParameterSensorUnitEnum::UNITS_AMPERE_DC,
    ::device::RDMParameterSensorUnitEnum::UNITS_BYTE,
    ::device::RDMParameterSensorUnitEnum::UNITS_CANDELA,
    ::device::RDMParameterSensorUnitEnum::UNITS_CENTIGRADE,
    ::device::RDMParameterSensorUnitEnum::UNITS_DEGREE,
    ::device::RDMParameterSensorUnitEnum::UNITS_HERTZ,
    ::device::RDMParameterSensorUnitEnum::UNITS_IRE,
    ::device::RDMParameterSensorUnitEnum::UNITS_JOULE,
    ::device::RDMParameterSensorUnitEnum::UNITS_KILOGRAM,
    ::device::RDMParameterSensorUnitEnum::UNITS_KILOGRAMMES_PER_METER_CUBED,
    ::device::RDMParameterSensorUnitEnum::UNITS_LUMEN,
    ::device::RDMParameterSensorUnitEnum::UNITS_LUX,
    ::device::RDMParameterSensorUnitEnum::UNITS_METERS,
    ::device::RDMParameterSensorUnitEnum::UNITS_METERS_CUBED,
    ::device::RDMParameterSensorUnitEnum::UNITS_METERS_PER_SECOND,
    ::device::RDMParameterSensorUnitEnum::UNITS_METERS_PER_SECOND_SQUARED,
    ::device::RDMParameterSensorUnitEnum::UNITS_METERS_SQUARED,
    ::device::RDMParameterSensorUnitEnum::UNITS_MS,
    ::device::RDMParameterSensorUnitEnum::UNITS_NEWTON,
    ::device::RDMParameterSensorUnitEnum::UNITS_NONE,
    ::device::RDMParameterSensorUnitEnum::UNITS_OHM,
    ::device::RDMParameterSensorUnitEnum::UNITS_PASCAL,
    ::device::RDMParameterSensorUnitEnum::UNITS_SECOND,
    ::device::RDMParameterSensorUnitEnum::UNITS_STERADIAN,
    ::device::RDMParameterSensorUnitEnum::UNITS_VOLTS_AC_PEAK,
    ::device::RDMParameterSensorUnitEnum::UNITS_VOLTS_AC_RMS,
    ::device::RDMParameterSensorUnitEnum::UNITS_VOLTS_DC,
    ::device::RDMParameterSensorUnitEnum::UNITS_WATT
  };

  // RDMSlotInfoTypeEnum
  //

  RDMSlotInfoTypeEnum::
  RDMSlotInfoTypeEnum (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RDMSlotInfoTypeEnum_convert ();
  }

  RDMSlotInfoTypeEnum::
  RDMSlotInfoTypeEnum (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RDMSlotInfoTypeEnum_convert ();
  }

  RDMSlotInfoTypeEnum::
  RDMSlotInfoTypeEnum (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RDMSlotInfoTypeEnum_convert ();
  }

  RDMSlotInfoTypeEnum* RDMSlotInfoTypeEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RDMSlotInfoTypeEnum (*this, f, c);
  }

  RDMSlotInfoTypeEnum::value RDMSlotInfoTypeEnum::
  _xsd_RDMSlotInfoTypeEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RDMSlotInfoTypeEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RDMSlotInfoTypeEnum_indexes_,
                      _xsd_RDMSlotInfoTypeEnum_indexes_ + 9,
                      *this,
                      c));

    if (i == _xsd_RDMSlotInfoTypeEnum_indexes_ + 9 || _xsd_RDMSlotInfoTypeEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RDMSlotInfoTypeEnum::
  _xsd_RDMSlotInfoTypeEnum_literals_[9] =
  {
    "ST_PRIMARY",
    "ST_SEC_FINE",
    "ST_SEC_TIMING",
    "ST_SEC_SPEED",
    "ST_SEC_CONTROL",
    "ST_SEC_INDEX",
    "ST_SEC_ROTATION",
    "ST_SEC_INDEX_ROTATE",
    "ST_SEC_UNDEFINED"
  };

  const RDMSlotInfoTypeEnum::value RDMSlotInfoTypeEnum::
  _xsd_RDMSlotInfoTypeEnum_indexes_[9] =
  {
    ::device::RDMSlotInfoTypeEnum::ST_PRIMARY,
    ::device::RDMSlotInfoTypeEnum::ST_SEC_CONTROL,
    ::device::RDMSlotInfoTypeEnum::ST_SEC_FINE,
    ::device::RDMSlotInfoTypeEnum::ST_SEC_INDEX,
    ::device::RDMSlotInfoTypeEnum::ST_SEC_INDEX_ROTATE,
    ::device::RDMSlotInfoTypeEnum::ST_SEC_ROTATION,
    ::device::RDMSlotInfoTypeEnum::ST_SEC_SPEED,
    ::device::RDMSlotInfoTypeEnum::ST_SEC_TIMING,
    ::device::RDMSlotInfoTypeEnum::ST_SEC_UNDEFINED
  };

  // RDMSlotLabelIDEnum
  //

  RDMSlotLabelIDEnum::
  RDMSlotLabelIDEnum (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RDMSlotLabelIDEnum_convert ();
  }

  RDMSlotLabelIDEnum::
  RDMSlotLabelIDEnum (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RDMSlotLabelIDEnum_convert ();
  }

  RDMSlotLabelIDEnum::
  RDMSlotLabelIDEnum (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RDMSlotLabelIDEnum_convert ();
  }

  RDMSlotLabelIDEnum* RDMSlotLabelIDEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RDMSlotLabelIDEnum (*this, f, c);
  }

  RDMSlotLabelIDEnum::value RDMSlotLabelIDEnum::
  _xsd_RDMSlotLabelIDEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RDMSlotLabelIDEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RDMSlotLabelIDEnum_indexes_,
                      _xsd_RDMSlotLabelIDEnum_indexes_ + 43,
                      *this,
                      c));

    if (i == _xsd_RDMSlotLabelIDEnum_indexes_ + 43 || _xsd_RDMSlotLabelIDEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RDMSlotLabelIDEnum::
  _xsd_RDMSlotLabelIDEnum_literals_[43] =
  {
    "SD_INTENSITY",
    "SD_INTENSITY_MASTER",
    "SD_PAN",
    "SD_TILT",
    "SD_COLOR_WHEEL",
    "SD_COLOR_SUB_CYAN",
    "SD_COLOR_SUB_YELLOW",
    "SD_COLOR_SUB_MAGENTA",
    "SD_COLOR_ADD_RED",
    "SD_COLOR_ADD_GREEN",
    "SD_COLOR_ADD_BLUE",
    "SD_COLOR_CORRECTION",
    "SD_COLOR_SCROLL",
    "SD_COLOR_SEMAPHORE",
    "SD_COLOR_ADD_AMBER",
    "SD_COLOR_ADD_WHITE",
    "SD_COLOR_ADD_W ARM_WHITE",
    "SD_COLOR_ADD_COOL_WHITE",
    "SD_COLOR_SUB_UV",
    "SD_COLOR_HUE",
    "SD_COLOR_SATURATION",
    "SD_STATIC_GOBO_WHEEL",
    "SD_ROTO_GOBO_WHEEL",
    "SD_PRISM_WHEEL",
    "SD_EFFECTS_WHEEL",
    "SD_BEAM_SIZE_IRIS",
    "SD_EDGE",
    "SD_FROST",
    "SD_STROBE",
    "SD_ZOOM",
    "SD_FRAMING_SHUTTER",
    "SD_SHUTTER_ROTATE",
    "SD_DOUSER",
    "SD_BARN_DOOR",
    "SD_LAMP_CONTROL",
    "SD_FIXTURE_CONTROL",
    "SD_FIXTURE_SPEED",
    "SD_MACRO",
    "SD_POWER_CONTROL",
    "SD_FAN_CONTROL",
    "SD_HEATER_CONTROL",
    "SD_FOUNTAIN_CONTROL",
    "SD_UNDEFINED"
  };

  const RDMSlotLabelIDEnum::value RDMSlotLabelIDEnum::
  _xsd_RDMSlotLabelIDEnum_indexes_[43] =
  {
    ::device::RDMSlotLabelIDEnum::SD_BARN_DOOR,
    ::device::RDMSlotLabelIDEnum::SD_BEAM_SIZE_IRIS,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_ADD_AMBER,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_ADD_BLUE,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_ADD_COOL_WHITE,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_ADD_GREEN,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_ADD_RED,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_ADD_W_ARM_WHITE,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_ADD_WHITE,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_CORRECTION,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_HUE,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_SATURATION,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_SCROLL,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_SEMAPHORE,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_SUB_CYAN,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_SUB_MAGENTA,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_SUB_UV,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_SUB_YELLOW,
    ::device::RDMSlotLabelIDEnum::SD_COLOR_WHEEL,
    ::device::RDMSlotLabelIDEnum::SD_DOUSER,
    ::device::RDMSlotLabelIDEnum::SD_EDGE,
    ::device::RDMSlotLabelIDEnum::SD_EFFECTS_WHEEL,
    ::device::RDMSlotLabelIDEnum::SD_FAN_CONTROL,
    ::device::RDMSlotLabelIDEnum::SD_FIXTURE_CONTROL,
    ::device::RDMSlotLabelIDEnum::SD_FIXTURE_SPEED,
    ::device::RDMSlotLabelIDEnum::SD_FOUNTAIN_CONTROL,
    ::device::RDMSlotLabelIDEnum::SD_FRAMING_SHUTTER,
    ::device::RDMSlotLabelIDEnum::SD_FROST,
    ::device::RDMSlotLabelIDEnum::SD_HEATER_CONTROL,
    ::device::RDMSlotLabelIDEnum::SD_INTENSITY,
    ::device::RDMSlotLabelIDEnum::SD_INTENSITY_MASTER,
    ::device::RDMSlotLabelIDEnum::SD_LAMP_CONTROL,
    ::device::RDMSlotLabelIDEnum::SD_MACRO,
    ::device::RDMSlotLabelIDEnum::SD_PAN,
    ::device::RDMSlotLabelIDEnum::SD_POWER_CONTROL,
    ::device::RDMSlotLabelIDEnum::SD_PRISM_WHEEL,
    ::device::RDMSlotLabelIDEnum::SD_ROTO_GOBO_WHEEL,
    ::device::RDMSlotLabelIDEnum::SD_SHUTTER_ROTATE,
    ::device::RDMSlotLabelIDEnum::SD_STATIC_GOBO_WHEEL,
    ::device::RDMSlotLabelIDEnum::SD_STROBE,
    ::device::RDMSlotLabelIDEnum::SD_TILT,
    ::device::RDMSlotLabelIDEnum::SD_UNDEFINED,
    ::device::RDMSlotLabelIDEnum::SD_ZOOM
  };

  // RDMParameterSensorUnitPrefixEnum
  //

  RDMParameterSensorUnitPrefixEnum::
  RDMParameterSensorUnitPrefixEnum (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RDMParameterSensorUnitPrefixEnum_convert ();
  }

  RDMParameterSensorUnitPrefixEnum::
  RDMParameterSensorUnitPrefixEnum (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RDMParameterSensorUnitPrefixEnum_convert ();
  }

  RDMParameterSensorUnitPrefixEnum::
  RDMParameterSensorUnitPrefixEnum (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RDMParameterSensorUnitPrefixEnum_convert ();
  }

  RDMParameterSensorUnitPrefixEnum* RDMParameterSensorUnitPrefixEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RDMParameterSensorUnitPrefixEnum (*this, f, c);
  }

  RDMParameterSensorUnitPrefixEnum::value RDMParameterSensorUnitPrefixEnum::
  _xsd_RDMParameterSensorUnitPrefixEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RDMParameterSensorUnitPrefixEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RDMParameterSensorUnitPrefixEnum_indexes_,
                      _xsd_RDMParameterSensorUnitPrefixEnum_indexes_ + 21,
                      *this,
                      c));

    if (i == _xsd_RDMParameterSensorUnitPrefixEnum_indexes_ + 21 || _xsd_RDMParameterSensorUnitPrefixEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RDMParameterSensorUnitPrefixEnum::
  _xsd_RDMParameterSensorUnitPrefixEnum_literals_[21] =
  {
    "PREFIX_NONE",
    "PREFIX_DECI",
    "PREFIX_CENTI",
    "PREFIX_MILLI",
    "PREFIX_MICRO",
    "PREFIX_NANO",
    "PREFIX_PICO",
    "PREFIX_FEMPTO",
    "PREFIX_ATTO",
    "PREFIX_ZEPTO",
    "PREFIX_YOCTO",
    "PREFIX_DECA",
    "PREFIX_HECTO",
    "PREFIX_KILO",
    "PREFIX_MEGA",
    "PREFIX_GIGA",
    "PREFIX_TERRA",
    "PREFIX_PETA",
    "PREFIX_EXA",
    "PREFIX_ZETTA",
    "PREFIX_YOTTA"
  };

  const RDMParameterSensorUnitPrefixEnum::value RDMParameterSensorUnitPrefixEnum::
  _xsd_RDMParameterSensorUnitPrefixEnum_indexes_[21] =
  {
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_ATTO,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_CENTI,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_DECA,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_DECI,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_EXA,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_FEMPTO,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_GIGA,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_HECTO,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_KILO,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_MEGA,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_MICRO,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_MILLI,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_NANO,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_NONE,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_PETA,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_PICO,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_TERRA,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_YOCTO,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_YOTTA,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_ZEPTO,
    ::device::RDMParameterSensorUnitPrefixEnum::PREFIX_ZETTA
  };

  // CESEnum
  //

  CESEnum::
  CESEnum (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_CESEnum_convert ();
  }

  CESEnum::
  CESEnum (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_CESEnum_convert ();
  }

  CESEnum::
  CESEnum (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_CESEnum_convert ();
  }

  CESEnum* CESEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CESEnum (*this, f, c);
  }

  CESEnum::value CESEnum::
  _xsd_CESEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CESEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_CESEnum_indexes_,
                      _xsd_CESEnum_indexes_ + 99,
                      *this,
                      c));

    if (i == _xsd_CESEnum_indexes_ + 99 || _xsd_CESEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CESEnum::
  _xsd_CESEnum_literals_[99] =
  {
    "CES01",
    "CES02",
    "CES03",
    "CES04",
    "CES05",
    "CES06",
    "CES07",
    "CES08",
    "CES09",
    "CES10",
    "CES11",
    "CES12",
    "CES13",
    "CES14",
    "CES15",
    "CES16",
    "CES17",
    "CES18",
    "CES19",
    "CES20",
    "CES21",
    "CES22",
    "CES23",
    "CES24",
    "CES25",
    "CES26",
    "CES27",
    "CES28",
    "CES29",
    "CES30",
    "CES31",
    "CES32",
    "CES33",
    "CES34",
    "CES35",
    "CES36",
    "CES37",
    "CES38",
    "CES39",
    "CES40",
    "CES41",
    "CES42",
    "CES43",
    "CES44",
    "CES45",
    "CES46",
    "CES47",
    "CES48",
    "CES49",
    "CES50",
    "CES51",
    "CES52",
    "CES53",
    "CES54",
    "CES55",
    "CES56",
    "CES57",
    "CES58",
    "CES59",
    "CES60",
    "CES61",
    "CES62",
    "CES63",
    "CES64",
    "CES65",
    "CES66",
    "CES67",
    "CES68",
    "CES69",
    "CES70",
    "CES71",
    "CES72",
    "CES73",
    "CES74",
    "CES75",
    "CES76",
    "CES77",
    "CES78",
    "CES79",
    "CES80",
    "CES81",
    "CES82",
    "CES83",
    "CES84",
    "CES85",
    "CES86",
    "CES87",
    "CES88",
    "CES89",
    "CES90",
    "CES91",
    "CES92",
    "CES93",
    "CES94",
    "CES95",
    "CES96",
    "CES97",
    "CES98",
    "CES99"
  };

  const CESEnum::value CESEnum::
  _xsd_CESEnum_indexes_[99] =
  {
    ::device::CESEnum::CES01,
    ::device::CESEnum::CES02,
    ::device::CESEnum::CES03,
    ::device::CESEnum::CES04,
    ::device::CESEnum::CES05,
    ::device::CESEnum::CES06,
    ::device::CESEnum::CES07,
    ::device::CESEnum::CES08,
    ::device::CESEnum::CES09,
    ::device::CESEnum::CES10,
    ::device::CESEnum::CES11,
    ::device::CESEnum::CES12,
    ::device::CESEnum::CES13,
    ::device::CESEnum::CES14,
    ::device::CESEnum::CES15,
    ::device::CESEnum::CES16,
    ::device::CESEnum::CES17,
    ::device::CESEnum::CES18,
    ::device::CESEnum::CES19,
    ::device::CESEnum::CES20,
    ::device::CESEnum::CES21,
    ::device::CESEnum::CES22,
    ::device::CESEnum::CES23,
    ::device::CESEnum::CES24,
    ::device::CESEnum::CES25,
    ::device::CESEnum::CES26,
    ::device::CESEnum::CES27,
    ::device::CESEnum::CES28,
    ::device::CESEnum::CES29,
    ::device::CESEnum::CES30,
    ::device::CESEnum::CES31,
    ::device::CESEnum::CES32,
    ::device::CESEnum::CES33,
    ::device::CESEnum::CES34,
    ::device::CESEnum::CES35,
    ::device::CESEnum::CES36,
    ::device::CESEnum::CES37,
    ::device::CESEnum::CES38,
    ::device::CESEnum::CES39,
    ::device::CESEnum::CES40,
    ::device::CESEnum::CES41,
    ::device::CESEnum::CES42,
    ::device::CESEnum::CES43,
    ::device::CESEnum::CES44,
    ::device::CESEnum::CES45,
    ::device::CESEnum::CES46,
    ::device::CESEnum::CES47,
    ::device::CESEnum::CES48,
    ::device::CESEnum::CES49,
    ::device::CESEnum::CES50,
    ::device::CESEnum::CES51,
    ::device::CESEnum::CES52,
    ::device::CESEnum::CES53,
    ::device::CESEnum::CES54,
    ::device::CESEnum::CES55,
    ::device::CESEnum::CES56,
    ::device::CESEnum::CES57,
    ::device::CESEnum::CES58,
    ::device::CESEnum::CES59,
    ::device::CESEnum::CES60,
    ::device::CESEnum::CES61,
    ::device::CESEnum::CES62,
    ::device::CESEnum::CES63,
    ::device::CESEnum::CES64,
    ::device::CESEnum::CES65,
    ::device::CESEnum::CES66,
    ::device::CESEnum::CES67,
    ::device::CESEnum::CES68,
    ::device::CESEnum::CES69,
    ::device::CESEnum::CES70,
    ::device::CESEnum::CES71,
    ::device::CESEnum::CES72,
    ::device::CESEnum::CES73,
    ::device::CESEnum::CES74,
    ::device::CESEnum::CES75,
    ::device::CESEnum::CES76,
    ::device::CESEnum::CES77,
    ::device::CESEnum::CES78,
    ::device::CESEnum::CES79,
    ::device::CESEnum::CES80,
    ::device::CESEnum::CES81,
    ::device::CESEnum::CES82,
    ::device::CESEnum::CES83,
    ::device::CESEnum::CES84,
    ::device::CESEnum::CES85,
    ::device::CESEnum::CES86,
    ::device::CESEnum::CES87,
    ::device::CESEnum::CES88,
    ::device::CESEnum::CES89,
    ::device::CESEnum::CES90,
    ::device::CESEnum::CES91,
    ::device::CESEnum::CES92,
    ::device::CESEnum::CES93,
    ::device::CESEnum::CES94,
    ::device::CESEnum::CES95,
    ::device::CESEnum::CES96,
    ::device::CESEnum::CES97,
    ::device::CESEnum::CES98,
    ::device::CESEnum::CES99
  };

  // AttributeEnum
  //

  AttributeEnum::
  AttributeEnum (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_AttributeEnum_convert ();
  }

  AttributeEnum::
  AttributeEnum (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_AttributeEnum_convert ();
  }

  AttributeEnum::
  AttributeEnum (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_AttributeEnum_convert ();
  }

  AttributeEnum* AttributeEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AttributeEnum (*this, f, c);
  }

  AttributeEnum::value AttributeEnum::
  _xsd_AttributeEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AttributeEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_AttributeEnum_indexes_,
                      _xsd_AttributeEnum_indexes_ + 559,
                      *this,
                      c));

    if (i == _xsd_AttributeEnum_indexes_ + 559 || _xsd_AttributeEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AttributeEnum::
  _xsd_AttributeEnum_literals_[559] =
  {
    "AnimationWheel1",
    "AnimationWheel1Audio",
    "AnimationWheel1Macro",
    "AnimationWheel1Mode",
    "AnimationWheel1Pos",
    "AnimationWheel1PosRotate",
    "AnimationWheel1PosShake",
    "AnimationWheel1Random",
    "AnimationWheel1SelectEffects",
    "AnimationWheel1SelectShake",
    "AnimationWheel1SelectSpin",
    "AnimationWheel2",
    "AnimationWheel2Audio",
    "AnimationWheel2Macro",
    "AnimationWheel2Mode",
    "AnimationWheel2Pos",
    "AnimationWheel2PosRotate",
    "AnimationWheel2PosShake",
    "AnimationWheel2Random",
    "AnimationWheel2SelectEffects",
    "AnimationWheel2SelectShake",
    "AnimationWheel2SelectSpin",
    "AnimationWheel3",
    "AnimationWheel3Audio",
    "AnimationWheel3Macro",
    "AnimationWheel3Mode",
    "AnimationWheel3Pos",
    "AnimationWheel3PosRotate",
    "AnimationWheel3PosShake",
    "AnimationWheel3Random",
    "AnimationWheel3SelectEffects",
    "AnimationWheel3SelectShake",
    "AnimationWheel3SelectSpin",
    "AnimationWheel4",
    "AnimationWheel4Audio",
    "AnimationWheel4Macro",
    "AnimationWheel4Mode",
    "AnimationWheel4Pos",
    "AnimationWheel4PosRotate",
    "AnimationWheel4PosShake",
    "AnimationWheel4Random",
    "AnimationWheel4SelectEffects",
    "AnimationWheel4SelectShake",
    "AnimationWheel4SelectSpin",
    "AnimationWheel5",
    "AnimationWheel5Audio",
    "AnimationWheel5Macro",
    "AnimationWheel5Mode",
    "AnimationWheel5Pos",
    "AnimationWheel5PosRotate",
    "AnimationWheel5PosShake",
    "AnimationWheel5Random",
    "AnimationWheel5SelectEffects",
    "AnimationWheel5SelectShake",
    "AnimationWheel5SelectSpin",
    "AnimationWheelShortcutMode",
    "BeamEffectIndexRotateMode",
    "BeamReset",
    "BeamShaper",
    "BeamShaperMacro",
    "BeamShaperPos",
    "BeamShaperPosRotate",
    "BlackoutMode",
    "Blade1A",
    "Blade1B",
    "Blade1Rot",
    "Blade2A",
    "Blade2B",
    "Blade2Rot",
    "Blade3A",
    "Blade3B",
    "Blade3Rot",
    "Blade4A",
    "Blade4B",
    "Blade4Rot",
    "Blade5A",
    "Blade5B",
    "Blade5Rot",
    "Blower1",
    "Blower2",
    "Blower3",
    "Blower4",
    "Blower5",
    "CIE_Brightness",
    "CIE_X",
    "CIE_Y",
    "CRIMode",
    "CTB",
    "CTBReset",
    "CTC",
    "CTCReset",
    "CTO",
    "CTOReset",
    "ChromaticMode",
    "Color1",
    "Color1Mode",
    "Color1WheelAudio",
    "Color1WheelIndex",
    "Color1WheelRandom",
    "Color1WheelSpin",
    "Color2",
    "Color2Mode",
    "Color2WheelAudio",
    "Color2WheelIndex",
    "Color2WheelRandom",
    "Color2WheelSpin",
    "Color3",
    "Color3Mode",
    "Color3WheelAudio",
    "Color3WheelIndex",
    "Color3WheelRandom",
    "Color3WheelSpin",
    "Color4",
    "Color4Mode",
    "Color4WheelAudio",
    "Color4WheelIndex",
    "Color4WheelRandom",
    "Color4WheelSpin",
    "Color5",
    "Color5Mode",
    "Color5WheelAudio",
    "Color5WheelIndex",
    "Color5WheelRandom",
    "Color5WheelSpin",
    "ColorAdd_B",
    "ColorAdd_BC",
    "ColorAdd_BM",
    "ColorAdd_C",
    "ColorAdd_CW",
    "ColorAdd_G",
    "ColorAdd_GC",
    "ColorAdd_GY",
    "ColorAdd_M",
    "ColorAdd_R",
    "ColorAdd_RM",
    "ColorAdd_RY",
    "ColorAdd_UV",
    "ColorAdd_W",
    "ColorAdd_WW",
    "ColorAdd_Y",
    "ColorCalibrationMode",
    "ColorConsistency",
    "ColorControl",
    "ColorEffects1",
    "ColorEffects2",
    "ColorEffects3",
    "ColorEffects4",
    "ColorEffects5",
    "ColorMacro1",
    "ColorMacro2",
    "ColorMacro3",
    "ColorMacro4",
    "ColorMacro5",
    "ColorMixMSpeed",
    "ColorMixMode",
    "ColorMixReset",
    "ColorModelMode",
    "ColorRGB_Blue",
    "ColorRGB_Cyan",
    "ColorRGB_Green",
    "ColorRGB_Magenta",
    "ColorRGB_Quality",
    "ColorRGB_Red",
    "ColorRGB_Yellow",
    "ColorSettingsReset",
    "ColorSub_B",
    "ColorSub_C",
    "ColorSub_G",
    "ColorSub_M",
    "ColorSub_R",
    "ColorSub_Y",
    "ColorUniformity",
    "ColorWheelReset",
    "ColorWheelSelectMSpeed",
    "ColorWheelShortcutMode",
    "Control1",
    "Control2",
    "Control3",
    "Control4",
    "Control5",
    "CustomColor",
    "CyanMode",
    "DMXInput",
    "Dimmer",
    "DimmerCurve",
    "DimmerMode",
    "DisplayIntensity",
    "Dummy",
    "Effects1",
    "Effects1Adjust1",
    "Effects1Adjust2",
    "Effects1Adjust3",
    "Effects1Adjust4",
    "Effects1Adjust5",
    "Effects1Fade",
    "Effects1Pos",
    "Effects1PosRotate",
    "Effects1Rate",
    "Effects2",
    "Effects2Adjust1",
    "Effects2Adjust2",
    "Effects2Adjust3",
    "Effects2Adjust4",
    "Effects2Adjust5",
    "Effects2Fade",
    "Effects2Pos",
    "Effects2PosRotate",
    "Effects2Rate",
    "Effects3",
    "Effects3Adjust1",
    "Effects3Adjust2",
    "Effects3Adjust3",
    "Effects3Adjust4",
    "Effects3Adjust5",
    "Effects3Fade",
    "Effects3Pos",
    "Effects3PosRotate",
    "Effects3Rate",
    "Effects4",
    "Effects4Adjust1",
    "Effects4Adjust2",
    "Effects4Adjust3",
    "Effects4Adjust4",
    "Effects4Adjust5",
    "Effects4Fade",
    "Effects4Pos",
    "Effects4PosRotate",
    "Effects4Rate",
    "Effects5",
    "Effects5Adjust1",
    "Effects5Adjust2",
    "Effects5Adjust3",
    "Effects5Adjust4",
    "Effects5Adjust5",
    "Effects5Fade",
    "Effects5Pos",
    "Effects5PosRotate",
    "Effects5Rate",
    "EffectsSync",
    "Fan1",
    "Fan2",
    "Fan3",
    "Fan4",
    "Fan5",
    "FanMode",
    "Fans",
    "FixtureCalibrationReset",
    "FixtureGlobalReset",
    "Focus1",
    "Focus1Adjust",
    "Focus1Distance",
    "Focus2",
    "Focus2Adjust",
    "Focus2Distance",
    "Focus3",
    "Focus3Adjust",
    "Focus3Distance",
    "Focus4",
    "Focus4Adjust",
    "Focus4Distance",
    "Focus5",
    "Focus5Adjust",
    "Focus5Distance",
    "FocusMSpeed",
    "FocusMode",
    "FocusReset",
    "Fog1",
    "Fog2",
    "Fog3",
    "Fog4",
    "Fog5",
    "FollowSpotMode",
    "FrameMSpeed",
    "FrameReset",
    "Frost1",
    "Frost1MSpeed",
    "Frost2",
    "Frost2MSpeed",
    "Frost3",
    "Frost3MSpeed",
    "Frost4",
    "Frost4MSpeed",
    "Frost5",
    "Frost5MSpeed",
    "Function",
    "GlobalMSpeed",
    "Gobo1",
    "Gobo1Pos",
    "Gobo1PosRotate",
    "Gobo1PosShake",
    "Gobo1SelectEffects",
    "Gobo1SelectShake",
    "Gobo1SelectSpin",
    "Gobo1WheelAudio",
    "Gobo1WheelIndex",
    "Gobo1WheelMode",
    "Gobo1WheelRandom",
    "Gobo1WheelShake",
    "Gobo1WheelSpin",
    "Gobo2",
    "Gobo2Pos",
    "Gobo2PosRotate",
    "Gobo2PosShake",
    "Gobo2SelectEffects",
    "Gobo2SelectShake",
    "Gobo2SelectSpin",
    "Gobo2WheelAudio",
    "Gobo2WheelIndex",
    "Gobo2WheelMode",
    "Gobo2WheelRandom",
    "Gobo2WheelShake",
    "Gobo2WheelSpin",
    "Gobo3",
    "Gobo3Pos",
    "Gobo3PosRotate",
    "Gobo3PosShake",
    "Gobo3SelectEffects",
    "Gobo3SelectShake",
    "Gobo3SelectSpin",
    "Gobo3WheelAudio",
    "Gobo3WheelIndex",
    "Gobo3WheelMode",
    "Gobo3WheelRandom",
    "Gobo3WheelShake",
    "Gobo3WheelSpin",
    "Gobo4",
    "Gobo4Pos",
    "Gobo4PosRotate",
    "Gobo4PosShake",
    "Gobo4SelectEffects",
    "Gobo4SelectShake",
    "Gobo4SelectSpin",
    "Gobo4WheelAudio",
    "Gobo4WheelIndex",
    "Gobo4WheelMode",
    "Gobo4WheelRandom",
    "Gobo4WheelShake",
    "Gobo4WheelSpin",
    "Gobo5",
    "Gobo5Pos",
    "Gobo5PosRotate",
    "Gobo5PosShake",
    "Gobo5SelectEffects",
    "Gobo5SelectShake",
    "Gobo5SelectSpin",
    "Gobo5WheelAudio",
    "Gobo5WheelIndex",
    "Gobo5WheelMode",
    "Gobo5WheelRandom",
    "Gobo5WheelShake",
    "Gobo5WheelSpin",
    "GoboWheel1MSpeed",
    "GoboWheel2MSpeed",
    "GoboWheel3MSpeed",
    "GoboWheel4MSpeed",
    "GoboWheel5MSpeed",
    "GoboWheelReset",
    "HSB_Brightness",
    "HSB_Hue",
    "HSB_Quality",
    "HSB_Saturation",
    "Haze1",
    "Haze2",
    "Haze3",
    "Haze4",
    "Haze5",
    "IntensityMSpeed",
    "IntensityReset",
    "Iris",
    "IrisMSpeed",
    "IrisMode",
    "IrisPulseClose",
    "IrisPulseOpen",
    "IrisReset",
    "IrisStrobe",
    "IrisStrobeRandom",
    "LEDFrequency",
    "LEDZoneMode",
    "LampControl",
    "LampPowerMode",
    "MagentaMode",
    "MediaContent",
    "MediaFolder",
    "NoFeature",
    "NoFeature1",
    "NoFeature2",
    "NoFeature3",
    "Pan",
    "PanMode",
    "PanReset",
    "PanTiltMode",
    "PixelMode",
    "Playmode",
    "PositionEffect",
    "PositionEffectFade",
    "PositionEffectRate",
    "PositionMSpeed",
    "PositionModes",
    "PositionReset",
    "Prism1",
    "Prism1MSpeed",
    "Prism1Macro",
    "Prism1Pos",
    "Prism1PosRotate",
    "Prism1SelectSpin",
    "Prism2",
    "Prism2MSpeed",
    "Prism2Macro",
    "Prism2Pos",
    "Prism2PosRotate",
    "Prism2SelectSpin",
    "Prism3",
    "Prism3MSpeed",
    "Prism3Macro",
    "Prism3Pos",
    "Prism3PosRotate",
    "Prism3SelectSpin",
    "Prism4",
    "Prism4MSpeed",
    "Prism4Macro",
    "Prism4Pos",
    "Prism4PosRotate",
    "Prism4SelectSpin",
    "Prism5",
    "Prism5MSpeed",
    "Prism5Macro",
    "Prism5Pos",
    "Prism5PosRotate",
    "Prism5SelectSpin",
    "ReflectorAdjust",
    "ShaperMacros",
    "ShaperMacrosSpeed",
    "ShaperRot",
    "Shutter1",
    "Shutter1Strobe",
    "Shutter1StrobeEffect",
    "Shutter1StrobePulse",
    "Shutter1StrobePulseClose",
    "Shutter1StrobePulseOpen",
    "Shutter1StrobeRandom",
    "Shutter1StrobeRandomPulse",
    "Shutter1StrobeRandomPulseClose",
    "Shutter1StrobeRandomPulseOpen",
    "Shutter2",
    "Shutter2Strobe",
    "Shutter2StrobeEffect",
    "Shutter2StrobePulse",
    "Shutter2StrobePulseClose",
    "Shutter2StrobePulseOpen",
    "Shutter2StrobeRandom",
    "Shutter2StrobeRandomPulse",
    "Shutter2StrobeRandomPulseClose",
    "Shutter2StrobeRandomPulseOpen",
    "Shutter3",
    "Shutter3Strobe",
    "Shutter3StrobeEffect",
    "Shutter3StrobePulse",
    "Shutter3StrobePulseClose",
    "Shutter3StrobePulseOpen",
    "Shutter3StrobeRandom",
    "Shutter3StrobeRandomPulse",
    "Shutter3StrobeRandomPulseClose",
    "Shutter3StrobeRandomPulseOpen",
    "Shutter4",
    "Shutter4Strobe",
    "Shutter4StrobeEffect",
    "Shutter4StrobePulse",
    "Shutter4StrobePulseClose",
    "Shutter4StrobePulseOpen",
    "Shutter4StrobeRandom",
    "Shutter4StrobeRandomPulse",
    "Shutter4StrobeRandomPulseClose",
    "Shutter4StrobeRandomPulseOpen",
    "Shutter5",
    "Shutter5Strobe",
    "Shutter5StrobeEffect",
    "Shutter5StrobePulse",
    "Shutter5StrobePulseClose",
    "Shutter5StrobePulseOpen",
    "Shutter5StrobeRandom",
    "Shutter5StrobeRandomPulse",
    "Shutter5StrobeRandomPulseClose",
    "Shutter5StrobeRandomPulseOpen",
    "ShutterReset",
    "StrobeDuration",
    "StrobeMode",
    "StrobeRate",
    "Tilt",
    "TiltMode",
    "TiltReset",
    "UVStability",
    "Video",
    "VideoCamera1",
    "VideoCamera2",
    "VideoCamera3",
    "VideoCamera4",
    "VideoCamera5",
    "VideoEffect1Parameter1",
    "VideoEffect1Parameter2",
    "VideoEffect1Parameter3",
    "VideoEffect1Parameter4",
    "VideoEffect1Parameter5",
    "VideoEffect1Type",
    "VideoEffect2Parameter1",
    "VideoEffect2Parameter2",
    "VideoEffect2Parameter3",
    "VideoEffect2Parameter4",
    "VideoEffect2Parameter5",
    "VideoEffect2Type",
    "VideoEffect3Parameter1",
    "VideoEffect3Parameter2",
    "VideoEffect3Parameter3",
    "VideoEffect3Parameter4",
    "VideoEffect3Parameter5",
    "VideoEffect3Type",
    "VideoEffect4Parameter1",
    "VideoEffect4Parameter2",
    "VideoEffect4Parameter3",
    "VideoEffect4Parameter4",
    "VideoEffect4Parameter5",
    "VideoEffect4Type",
    "VideoEffect5Parameter1",
    "VideoEffect5Parameter2",
    "VideoEffect5Parameter3",
    "VideoEffect5Parameter4",
    "VideoEffect5Parameter5",
    "VideoEffect5Type",
    "VideoScale1_All",
    "VideoScale1_X",
    "VideoScale1_Y",
    "VideoScale1_Z",
    "VideoScale2_All",
    "VideoScale2_X",
    "VideoScale2_Y",
    "VideoScale2_Z",
    "VideoScale3_All",
    "VideoScale3_X",
    "VideoScale3_Y",
    "VideoScale3_Z",
    "VideoScale4_All",
    "VideoScale4_X",
    "VideoScale4_Y",
    "VideoScale4_Z",
    "VideoScale5_All",
    "VideoScale5_X",
    "VideoScale5_Y",
    "VideoScale5_Z",
    "WavelengthCorrection",
    "WhiteCount",
    "XYZ_X",
    "XYZ_Y",
    "XYZ_Z",
    "YellowMode",
    "Zoom",
    "ZoomMSpeed",
    "ZoomMode",
    "ZoomModeBeam",
    "ZoomModeSpot",
    "ZoomReset"
  };

  const AttributeEnum::value AttributeEnum::
  _xsd_AttributeEnum_indexes_[559] =
  {
    ::device::AttributeEnum::AnimationWheel1,
    ::device::AttributeEnum::AnimationWheel1Audio,
    ::device::AttributeEnum::AnimationWheel1Macro,
    ::device::AttributeEnum::AnimationWheel1Mode,
    ::device::AttributeEnum::AnimationWheel1Pos,
    ::device::AttributeEnum::AnimationWheel1PosRotate,
    ::device::AttributeEnum::AnimationWheel1PosShake,
    ::device::AttributeEnum::AnimationWheel1Random,
    ::device::AttributeEnum::AnimationWheel1SelectEffects,
    ::device::AttributeEnum::AnimationWheel1SelectShake,
    ::device::AttributeEnum::AnimationWheel1SelectSpin,
    ::device::AttributeEnum::AnimationWheel2,
    ::device::AttributeEnum::AnimationWheel2Audio,
    ::device::AttributeEnum::AnimationWheel2Macro,
    ::device::AttributeEnum::AnimationWheel2Mode,
    ::device::AttributeEnum::AnimationWheel2Pos,
    ::device::AttributeEnum::AnimationWheel2PosRotate,
    ::device::AttributeEnum::AnimationWheel2PosShake,
    ::device::AttributeEnum::AnimationWheel2Random,
    ::device::AttributeEnum::AnimationWheel2SelectEffects,
    ::device::AttributeEnum::AnimationWheel2SelectShake,
    ::device::AttributeEnum::AnimationWheel2SelectSpin,
    ::device::AttributeEnum::AnimationWheel3,
    ::device::AttributeEnum::AnimationWheel3Audio,
    ::device::AttributeEnum::AnimationWheel3Macro,
    ::device::AttributeEnum::AnimationWheel3Mode,
    ::device::AttributeEnum::AnimationWheel3Pos,
    ::device::AttributeEnum::AnimationWheel3PosRotate,
    ::device::AttributeEnum::AnimationWheel3PosShake,
    ::device::AttributeEnum::AnimationWheel3Random,
    ::device::AttributeEnum::AnimationWheel3SelectEffects,
    ::device::AttributeEnum::AnimationWheel3SelectShake,
    ::device::AttributeEnum::AnimationWheel3SelectSpin,
    ::device::AttributeEnum::AnimationWheel4,
    ::device::AttributeEnum::AnimationWheel4Audio,
    ::device::AttributeEnum::AnimationWheel4Macro,
    ::device::AttributeEnum::AnimationWheel4Mode,
    ::device::AttributeEnum::AnimationWheel4Pos,
    ::device::AttributeEnum::AnimationWheel4PosRotate,
    ::device::AttributeEnum::AnimationWheel4PosShake,
    ::device::AttributeEnum::AnimationWheel4Random,
    ::device::AttributeEnum::AnimationWheel4SelectEffects,
    ::device::AttributeEnum::AnimationWheel4SelectShake,
    ::device::AttributeEnum::AnimationWheel4SelectSpin,
    ::device::AttributeEnum::AnimationWheel5,
    ::device::AttributeEnum::AnimationWheel5Audio,
    ::device::AttributeEnum::AnimationWheel5Macro,
    ::device::AttributeEnum::AnimationWheel5Mode,
    ::device::AttributeEnum::AnimationWheel5Pos,
    ::device::AttributeEnum::AnimationWheel5PosRotate,
    ::device::AttributeEnum::AnimationWheel5PosShake,
    ::device::AttributeEnum::AnimationWheel5Random,
    ::device::AttributeEnum::AnimationWheel5SelectEffects,
    ::device::AttributeEnum::AnimationWheel5SelectShake,
    ::device::AttributeEnum::AnimationWheel5SelectSpin,
    ::device::AttributeEnum::AnimationWheelShortcutMode,
    ::device::AttributeEnum::BeamEffectIndexRotateMode,
    ::device::AttributeEnum::BeamReset,
    ::device::AttributeEnum::BeamShaper,
    ::device::AttributeEnum::BeamShaperMacro,
    ::device::AttributeEnum::BeamShaperPos,
    ::device::AttributeEnum::BeamShaperPosRotate,
    ::device::AttributeEnum::BlackoutMode,
    ::device::AttributeEnum::Blade1A,
    ::device::AttributeEnum::Blade1B,
    ::device::AttributeEnum::Blade1Rot,
    ::device::AttributeEnum::Blade2A,
    ::device::AttributeEnum::Blade2B,
    ::device::AttributeEnum::Blade2Rot,
    ::device::AttributeEnum::Blade3A,
    ::device::AttributeEnum::Blade3B,
    ::device::AttributeEnum::Blade3Rot,
    ::device::AttributeEnum::Blade4A,
    ::device::AttributeEnum::Blade4B,
    ::device::AttributeEnum::Blade4Rot,
    ::device::AttributeEnum::Blade5A,
    ::device::AttributeEnum::Blade5B,
    ::device::AttributeEnum::Blade5Rot,
    ::device::AttributeEnum::Blower1,
    ::device::AttributeEnum::Blower2,
    ::device::AttributeEnum::Blower3,
    ::device::AttributeEnum::Blower4,
    ::device::AttributeEnum::Blower5,
    ::device::AttributeEnum::CIE_Brightness,
    ::device::AttributeEnum::CIE_X,
    ::device::AttributeEnum::CIE_Y,
    ::device::AttributeEnum::CRIMode,
    ::device::AttributeEnum::CTB,
    ::device::AttributeEnum::CTBReset,
    ::device::AttributeEnum::CTC,
    ::device::AttributeEnum::CTCReset,
    ::device::AttributeEnum::CTO,
    ::device::AttributeEnum::CTOReset,
    ::device::AttributeEnum::ChromaticMode,
    ::device::AttributeEnum::Color1,
    ::device::AttributeEnum::Color1Mode,
    ::device::AttributeEnum::Color1WheelAudio,
    ::device::AttributeEnum::Color1WheelIndex,
    ::device::AttributeEnum::Color1WheelRandom,
    ::device::AttributeEnum::Color1WheelSpin,
    ::device::AttributeEnum::Color2,
    ::device::AttributeEnum::Color2Mode,
    ::device::AttributeEnum::Color2WheelAudio,
    ::device::AttributeEnum::Color2WheelIndex,
    ::device::AttributeEnum::Color2WheelRandom,
    ::device::AttributeEnum::Color2WheelSpin,
    ::device::AttributeEnum::Color3,
    ::device::AttributeEnum::Color3Mode,
    ::device::AttributeEnum::Color3WheelAudio,
    ::device::AttributeEnum::Color3WheelIndex,
    ::device::AttributeEnum::Color3WheelRandom,
    ::device::AttributeEnum::Color3WheelSpin,
    ::device::AttributeEnum::Color4,
    ::device::AttributeEnum::Color4Mode,
    ::device::AttributeEnum::Color4WheelAudio,
    ::device::AttributeEnum::Color4WheelIndex,
    ::device::AttributeEnum::Color4WheelRandom,
    ::device::AttributeEnum::Color4WheelSpin,
    ::device::AttributeEnum::Color5,
    ::device::AttributeEnum::Color5Mode,
    ::device::AttributeEnum::Color5WheelAudio,
    ::device::AttributeEnum::Color5WheelIndex,
    ::device::AttributeEnum::Color5WheelRandom,
    ::device::AttributeEnum::Color5WheelSpin,
    ::device::AttributeEnum::ColorAdd_B,
    ::device::AttributeEnum::ColorAdd_BC,
    ::device::AttributeEnum::ColorAdd_BM,
    ::device::AttributeEnum::ColorAdd_C,
    ::device::AttributeEnum::ColorAdd_CW,
    ::device::AttributeEnum::ColorAdd_G,
    ::device::AttributeEnum::ColorAdd_GC,
    ::device::AttributeEnum::ColorAdd_GY,
    ::device::AttributeEnum::ColorAdd_M,
    ::device::AttributeEnum::ColorAdd_R,
    ::device::AttributeEnum::ColorAdd_RM,
    ::device::AttributeEnum::ColorAdd_RY,
    ::device::AttributeEnum::ColorAdd_UV,
    ::device::AttributeEnum::ColorAdd_W,
    ::device::AttributeEnum::ColorAdd_WW,
    ::device::AttributeEnum::ColorAdd_Y,
    ::device::AttributeEnum::ColorCalibrationMode,
    ::device::AttributeEnum::ColorConsistency,
    ::device::AttributeEnum::ColorControl,
    ::device::AttributeEnum::ColorEffects1,
    ::device::AttributeEnum::ColorEffects2,
    ::device::AttributeEnum::ColorEffects3,
    ::device::AttributeEnum::ColorEffects4,
    ::device::AttributeEnum::ColorEffects5,
    ::device::AttributeEnum::ColorMacro1,
    ::device::AttributeEnum::ColorMacro2,
    ::device::AttributeEnum::ColorMacro3,
    ::device::AttributeEnum::ColorMacro4,
    ::device::AttributeEnum::ColorMacro5,
    ::device::AttributeEnum::ColorMixMSpeed,
    ::device::AttributeEnum::ColorMixMode,
    ::device::AttributeEnum::ColorMixReset,
    ::device::AttributeEnum::ColorModelMode,
    ::device::AttributeEnum::ColorRGB_Blue,
    ::device::AttributeEnum::ColorRGB_Cyan,
    ::device::AttributeEnum::ColorRGB_Green,
    ::device::AttributeEnum::ColorRGB_Magenta,
    ::device::AttributeEnum::ColorRGB_Quality,
    ::device::AttributeEnum::ColorRGB_Red,
    ::device::AttributeEnum::ColorRGB_Yellow,
    ::device::AttributeEnum::ColorSettingsReset,
    ::device::AttributeEnum::ColorSub_B,
    ::device::AttributeEnum::ColorSub_C,
    ::device::AttributeEnum::ColorSub_G,
    ::device::AttributeEnum::ColorSub_M,
    ::device::AttributeEnum::ColorSub_R,
    ::device::AttributeEnum::ColorSub_Y,
    ::device::AttributeEnum::ColorUniformity,
    ::device::AttributeEnum::ColorWheelReset,
    ::device::AttributeEnum::ColorWheelSelectMSpeed,
    ::device::AttributeEnum::ColorWheelShortcutMode,
    ::device::AttributeEnum::Control1,
    ::device::AttributeEnum::Control2,
    ::device::AttributeEnum::Control3,
    ::device::AttributeEnum::Control4,
    ::device::AttributeEnum::Control5,
    ::device::AttributeEnum::CustomColor,
    ::device::AttributeEnum::CyanMode,
    ::device::AttributeEnum::DMXInput,
    ::device::AttributeEnum::Dimmer,
    ::device::AttributeEnum::DimmerCurve,
    ::device::AttributeEnum::DimmerMode,
    ::device::AttributeEnum::DisplayIntensity,
    ::device::AttributeEnum::Dummy,
    ::device::AttributeEnum::Effects1,
    ::device::AttributeEnum::Effects1Adjust1,
    ::device::AttributeEnum::Effects1Adjust2,
    ::device::AttributeEnum::Effects1Adjust3,
    ::device::AttributeEnum::Effects1Adjust4,
    ::device::AttributeEnum::Effects1Adjust5,
    ::device::AttributeEnum::Effects1Fade,
    ::device::AttributeEnum::Effects1Pos,
    ::device::AttributeEnum::Effects1PosRotate,
    ::device::AttributeEnum::Effects1Rate,
    ::device::AttributeEnum::Effects2,
    ::device::AttributeEnum::Effects2Adjust1,
    ::device::AttributeEnum::Effects2Adjust2,
    ::device::AttributeEnum::Effects2Adjust3,
    ::device::AttributeEnum::Effects2Adjust4,
    ::device::AttributeEnum::Effects2Adjust5,
    ::device::AttributeEnum::Effects2Fade,
    ::device::AttributeEnum::Effects2Pos,
    ::device::AttributeEnum::Effects2PosRotate,
    ::device::AttributeEnum::Effects2Rate,
    ::device::AttributeEnum::Effects3,
    ::device::AttributeEnum::Effects3Adjust1,
    ::device::AttributeEnum::Effects3Adjust2,
    ::device::AttributeEnum::Effects3Adjust3,
    ::device::AttributeEnum::Effects3Adjust4,
    ::device::AttributeEnum::Effects3Adjust5,
    ::device::AttributeEnum::Effects3Fade,
    ::device::AttributeEnum::Effects3Pos,
    ::device::AttributeEnum::Effects3PosRotate,
    ::device::AttributeEnum::Effects3Rate,
    ::device::AttributeEnum::Effects4,
    ::device::AttributeEnum::Effects4Adjust1,
    ::device::AttributeEnum::Effects4Adjust2,
    ::device::AttributeEnum::Effects4Adjust3,
    ::device::AttributeEnum::Effects4Adjust4,
    ::device::AttributeEnum::Effects4Adjust5,
    ::device::AttributeEnum::Effects4Fade,
    ::device::AttributeEnum::Effects4Pos,
    ::device::AttributeEnum::Effects4PosRotate,
    ::device::AttributeEnum::Effects4Rate,
    ::device::AttributeEnum::Effects5,
    ::device::AttributeEnum::Effects5Adjust1,
    ::device::AttributeEnum::Effects5Adjust2,
    ::device::AttributeEnum::Effects5Adjust3,
    ::device::AttributeEnum::Effects5Adjust4,
    ::device::AttributeEnum::Effects5Adjust5,
    ::device::AttributeEnum::Effects5Fade,
    ::device::AttributeEnum::Effects5Pos,
    ::device::AttributeEnum::Effects5PosRotate,
    ::device::AttributeEnum::Effects5Rate,
    ::device::AttributeEnum::EffectsSync,
    ::device::AttributeEnum::Fan1,
    ::device::AttributeEnum::Fan2,
    ::device::AttributeEnum::Fan3,
    ::device::AttributeEnum::Fan4,
    ::device::AttributeEnum::Fan5,
    ::device::AttributeEnum::FanMode,
    ::device::AttributeEnum::Fans,
    ::device::AttributeEnum::FixtureCalibrationReset,
    ::device::AttributeEnum::FixtureGlobalReset,
    ::device::AttributeEnum::Focus1,
    ::device::AttributeEnum::Focus1Adjust,
    ::device::AttributeEnum::Focus1Distance,
    ::device::AttributeEnum::Focus2,
    ::device::AttributeEnum::Focus2Adjust,
    ::device::AttributeEnum::Focus2Distance,
    ::device::AttributeEnum::Focus3,
    ::device::AttributeEnum::Focus3Adjust,
    ::device::AttributeEnum::Focus3Distance,
    ::device::AttributeEnum::Focus4,
    ::device::AttributeEnum::Focus4Adjust,
    ::device::AttributeEnum::Focus4Distance,
    ::device::AttributeEnum::Focus5,
    ::device::AttributeEnum::Focus5Adjust,
    ::device::AttributeEnum::Focus5Distance,
    ::device::AttributeEnum::FocusMSpeed,
    ::device::AttributeEnum::FocusMode,
    ::device::AttributeEnum::FocusReset,
    ::device::AttributeEnum::Fog1,
    ::device::AttributeEnum::Fog2,
    ::device::AttributeEnum::Fog3,
    ::device::AttributeEnum::Fog4,
    ::device::AttributeEnum::Fog5,
    ::device::AttributeEnum::FollowSpotMode,
    ::device::AttributeEnum::FrameMSpeed,
    ::device::AttributeEnum::FrameReset,
    ::device::AttributeEnum::Frost1,
    ::device::AttributeEnum::Frost1MSpeed,
    ::device::AttributeEnum::Frost2,
    ::device::AttributeEnum::Frost2MSpeed,
    ::device::AttributeEnum::Frost3,
    ::device::AttributeEnum::Frost3MSpeed,
    ::device::AttributeEnum::Frost4,
    ::device::AttributeEnum::Frost4MSpeed,
    ::device::AttributeEnum::Frost5,
    ::device::AttributeEnum::Frost5MSpeed,
    ::device::AttributeEnum::Function,
    ::device::AttributeEnum::GlobalMSpeed,
    ::device::AttributeEnum::Gobo1,
    ::device::AttributeEnum::Gobo1Pos,
    ::device::AttributeEnum::Gobo1PosRotate,
    ::device::AttributeEnum::Gobo1PosShake,
    ::device::AttributeEnum::Gobo1SelectEffects,
    ::device::AttributeEnum::Gobo1SelectShake,
    ::device::AttributeEnum::Gobo1SelectSpin,
    ::device::AttributeEnum::Gobo1WheelAudio,
    ::device::AttributeEnum::Gobo1WheelIndex,
    ::device::AttributeEnum::Gobo1WheelMode,
    ::device::AttributeEnum::Gobo1WheelRandom,
    ::device::AttributeEnum::Gobo1WheelShake,
    ::device::AttributeEnum::Gobo1WheelSpin,
    ::device::AttributeEnum::Gobo2,
    ::device::AttributeEnum::Gobo2Pos,
    ::device::AttributeEnum::Gobo2PosRotate,
    ::device::AttributeEnum::Gobo2PosShake,
    ::device::AttributeEnum::Gobo2SelectEffects,
    ::device::AttributeEnum::Gobo2SelectShake,
    ::device::AttributeEnum::Gobo2SelectSpin,
    ::device::AttributeEnum::Gobo2WheelAudio,
    ::device::AttributeEnum::Gobo2WheelIndex,
    ::device::AttributeEnum::Gobo2WheelMode,
    ::device::AttributeEnum::Gobo2WheelRandom,
    ::device::AttributeEnum::Gobo2WheelShake,
    ::device::AttributeEnum::Gobo2WheelSpin,
    ::device::AttributeEnum::Gobo3,
    ::device::AttributeEnum::Gobo3Pos,
    ::device::AttributeEnum::Gobo3PosRotate,
    ::device::AttributeEnum::Gobo3PosShake,
    ::device::AttributeEnum::Gobo3SelectEffects,
    ::device::AttributeEnum::Gobo3SelectShake,
    ::device::AttributeEnum::Gobo3SelectSpin,
    ::device::AttributeEnum::Gobo3WheelAudio,
    ::device::AttributeEnum::Gobo3WheelIndex,
    ::device::AttributeEnum::Gobo3WheelMode,
    ::device::AttributeEnum::Gobo3WheelRandom,
    ::device::AttributeEnum::Gobo3WheelShake,
    ::device::AttributeEnum::Gobo3WheelSpin,
    ::device::AttributeEnum::Gobo4,
    ::device::AttributeEnum::Gobo4Pos,
    ::device::AttributeEnum::Gobo4PosRotate,
    ::device::AttributeEnum::Gobo4PosShake,
    ::device::AttributeEnum::Gobo4SelectEffects,
    ::device::AttributeEnum::Gobo4SelectShake,
    ::device::AttributeEnum::Gobo4SelectSpin,
    ::device::AttributeEnum::Gobo4WheelAudio,
    ::device::AttributeEnum::Gobo4WheelIndex,
    ::device::AttributeEnum::Gobo4WheelMode,
    ::device::AttributeEnum::Gobo4WheelRandom,
    ::device::AttributeEnum::Gobo4WheelShake,
    ::device::AttributeEnum::Gobo4WheelSpin,
    ::device::AttributeEnum::Gobo5,
    ::device::AttributeEnum::Gobo5Pos,
    ::device::AttributeEnum::Gobo5PosRotate,
    ::device::AttributeEnum::Gobo5PosShake,
    ::device::AttributeEnum::Gobo5SelectEffects,
    ::device::AttributeEnum::Gobo5SelectShake,
    ::device::AttributeEnum::Gobo5SelectSpin,
    ::device::AttributeEnum::Gobo5WheelAudio,
    ::device::AttributeEnum::Gobo5WheelIndex,
    ::device::AttributeEnum::Gobo5WheelMode,
    ::device::AttributeEnum::Gobo5WheelRandom,
    ::device::AttributeEnum::Gobo5WheelShake,
    ::device::AttributeEnum::Gobo5WheelSpin,
    ::device::AttributeEnum::GoboWheel1MSpeed,
    ::device::AttributeEnum::GoboWheel2MSpeed,
    ::device::AttributeEnum::GoboWheel3MSpeed,
    ::device::AttributeEnum::GoboWheel4MSpeed,
    ::device::AttributeEnum::GoboWheel5MSpeed,
    ::device::AttributeEnum::GoboWheelReset,
    ::device::AttributeEnum::HSB_Brightness,
    ::device::AttributeEnum::HSB_Hue,
    ::device::AttributeEnum::HSB_Quality,
    ::device::AttributeEnum::HSB_Saturation,
    ::device::AttributeEnum::Haze1,
    ::device::AttributeEnum::Haze2,
    ::device::AttributeEnum::Haze3,
    ::device::AttributeEnum::Haze4,
    ::device::AttributeEnum::Haze5,
    ::device::AttributeEnum::IntensityMSpeed,
    ::device::AttributeEnum::IntensityReset,
    ::device::AttributeEnum::Iris,
    ::device::AttributeEnum::IrisMSpeed,
    ::device::AttributeEnum::IrisMode,
    ::device::AttributeEnum::IrisPulseClose,
    ::device::AttributeEnum::IrisPulseOpen,
    ::device::AttributeEnum::IrisReset,
    ::device::AttributeEnum::IrisStrobe,
    ::device::AttributeEnum::IrisStrobeRandom,
    ::device::AttributeEnum::LEDFrequency,
    ::device::AttributeEnum::LEDZoneMode,
    ::device::AttributeEnum::LampControl,
    ::device::AttributeEnum::LampPowerMode,
    ::device::AttributeEnum::MagentaMode,
    ::device::AttributeEnum::MediaContent,
    ::device::AttributeEnum::MediaFolder,
    ::device::AttributeEnum::NoFeature,
    ::device::AttributeEnum::NoFeature1,
    ::device::AttributeEnum::NoFeature2,
    ::device::AttributeEnum::NoFeature3,
    ::device::AttributeEnum::Pan,
    ::device::AttributeEnum::PanMode,
    ::device::AttributeEnum::PanReset,
    ::device::AttributeEnum::PanTiltMode,
    ::device::AttributeEnum::PixelMode,
    ::device::AttributeEnum::Playmode,
    ::device::AttributeEnum::PositionEffect,
    ::device::AttributeEnum::PositionEffectFade,
    ::device::AttributeEnum::PositionEffectRate,
    ::device::AttributeEnum::PositionMSpeed,
    ::device::AttributeEnum::PositionModes,
    ::device::AttributeEnum::PositionReset,
    ::device::AttributeEnum::Prism1,
    ::device::AttributeEnum::Prism1MSpeed,
    ::device::AttributeEnum::Prism1Macro,
    ::device::AttributeEnum::Prism1Pos,
    ::device::AttributeEnum::Prism1PosRotate,
    ::device::AttributeEnum::Prism1SelectSpin,
    ::device::AttributeEnum::Prism2,
    ::device::AttributeEnum::Prism2MSpeed,
    ::device::AttributeEnum::Prism2Macro,
    ::device::AttributeEnum::Prism2Pos,
    ::device::AttributeEnum::Prism2PosRotate,
    ::device::AttributeEnum::Prism2SelectSpin,
    ::device::AttributeEnum::Prism3,
    ::device::AttributeEnum::Prism3MSpeed,
    ::device::AttributeEnum::Prism3Macro,
    ::device::AttributeEnum::Prism3Pos,
    ::device::AttributeEnum::Prism3PosRotate,
    ::device::AttributeEnum::Prism3SelectSpin,
    ::device::AttributeEnum::Prism4,
    ::device::AttributeEnum::Prism4MSpeed,
    ::device::AttributeEnum::Prism4Macro,
    ::device::AttributeEnum::Prism4Pos,
    ::device::AttributeEnum::Prism4PosRotate,
    ::device::AttributeEnum::Prism4SelectSpin,
    ::device::AttributeEnum::Prism5,
    ::device::AttributeEnum::Prism5MSpeed,
    ::device::AttributeEnum::Prism5Macro,
    ::device::AttributeEnum::Prism5Pos,
    ::device::AttributeEnum::Prism5PosRotate,
    ::device::AttributeEnum::Prism5SelectSpin,
    ::device::AttributeEnum::ReflectorAdjust,
    ::device::AttributeEnum::ShaperMacros,
    ::device::AttributeEnum::ShaperMacrosSpeed,
    ::device::AttributeEnum::ShaperRot,
    ::device::AttributeEnum::Shutter1,
    ::device::AttributeEnum::Shutter1Strobe,
    ::device::AttributeEnum::Shutter1StrobeEffect,
    ::device::AttributeEnum::Shutter1StrobePulse,
    ::device::AttributeEnum::Shutter1StrobePulseClose,
    ::device::AttributeEnum::Shutter1StrobePulseOpen,
    ::device::AttributeEnum::Shutter1StrobeRandom,
    ::device::AttributeEnum::Shutter1StrobeRandomPulse,
    ::device::AttributeEnum::Shutter1StrobeRandomPulseClose,
    ::device::AttributeEnum::Shutter1StrobeRandomPulseOpen,
    ::device::AttributeEnum::Shutter2,
    ::device::AttributeEnum::Shutter2Strobe,
    ::device::AttributeEnum::Shutter2StrobeEffect,
    ::device::AttributeEnum::Shutter2StrobePulse,
    ::device::AttributeEnum::Shutter2StrobePulseClose,
    ::device::AttributeEnum::Shutter2StrobePulseOpen,
    ::device::AttributeEnum::Shutter2StrobeRandom,
    ::device::AttributeEnum::Shutter2StrobeRandomPulse,
    ::device::AttributeEnum::Shutter2StrobeRandomPulseClose,
    ::device::AttributeEnum::Shutter2StrobeRandomPulseOpen,
    ::device::AttributeEnum::Shutter3,
    ::device::AttributeEnum::Shutter3Strobe,
    ::device::AttributeEnum::Shutter3StrobeEffect,
    ::device::AttributeEnum::Shutter3StrobePulse,
    ::device::AttributeEnum::Shutter3StrobePulseClose,
    ::device::AttributeEnum::Shutter3StrobePulseOpen,
    ::device::AttributeEnum::Shutter3StrobeRandom,
    ::device::AttributeEnum::Shutter3StrobeRandomPulse,
    ::device::AttributeEnum::Shutter3StrobeRandomPulseClose,
    ::device::AttributeEnum::Shutter3StrobeRandomPulseOpen,
    ::device::AttributeEnum::Shutter4,
    ::device::AttributeEnum::Shutter4Strobe,
    ::device::AttributeEnum::Shutter4StrobeEffect,
    ::device::AttributeEnum::Shutter4StrobePulse,
    ::device::AttributeEnum::Shutter4StrobePulseClose,
    ::device::AttributeEnum::Shutter4StrobePulseOpen,
    ::device::AttributeEnum::Shutter4StrobeRandom,
    ::device::AttributeEnum::Shutter4StrobeRandomPulse,
    ::device::AttributeEnum::Shutter4StrobeRandomPulseClose,
    ::device::AttributeEnum::Shutter4StrobeRandomPulseOpen,
    ::device::AttributeEnum::Shutter5,
    ::device::AttributeEnum::Shutter5Strobe,
    ::device::AttributeEnum::Shutter5StrobeEffect,
    ::device::AttributeEnum::Shutter5StrobePulse,
    ::device::AttributeEnum::Shutter5StrobePulseClose,
    ::device::AttributeEnum::Shutter5StrobePulseOpen,
    ::device::AttributeEnum::Shutter5StrobeRandom,
    ::device::AttributeEnum::Shutter5StrobeRandomPulse,
    ::device::AttributeEnum::Shutter5StrobeRandomPulseClose,
    ::device::AttributeEnum::Shutter5StrobeRandomPulseOpen,
    ::device::AttributeEnum::ShutterReset,
    ::device::AttributeEnum::StrobeDuration,
    ::device::AttributeEnum::StrobeMode,
    ::device::AttributeEnum::StrobeRate,
    ::device::AttributeEnum::Tilt,
    ::device::AttributeEnum::TiltMode,
    ::device::AttributeEnum::TiltReset,
    ::device::AttributeEnum::UVStability,
    ::device::AttributeEnum::Video,
    ::device::AttributeEnum::VideoCamera1,
    ::device::AttributeEnum::VideoCamera2,
    ::device::AttributeEnum::VideoCamera3,
    ::device::AttributeEnum::VideoCamera4,
    ::device::AttributeEnum::VideoCamera5,
    ::device::AttributeEnum::VideoEffect1Parameter1,
    ::device::AttributeEnum::VideoEffect1Parameter2,
    ::device::AttributeEnum::VideoEffect1Parameter3,
    ::device::AttributeEnum::VideoEffect1Parameter4,
    ::device::AttributeEnum::VideoEffect1Parameter5,
    ::device::AttributeEnum::VideoEffect1Type,
    ::device::AttributeEnum::VideoEffect2Parameter1,
    ::device::AttributeEnum::VideoEffect2Parameter2,
    ::device::AttributeEnum::VideoEffect2Parameter3,
    ::device::AttributeEnum::VideoEffect2Parameter4,
    ::device::AttributeEnum::VideoEffect2Parameter5,
    ::device::AttributeEnum::VideoEffect2Type,
    ::device::AttributeEnum::VideoEffect3Parameter1,
    ::device::AttributeEnum::VideoEffect3Parameter2,
    ::device::AttributeEnum::VideoEffect3Parameter3,
    ::device::AttributeEnum::VideoEffect3Parameter4,
    ::device::AttributeEnum::VideoEffect3Parameter5,
    ::device::AttributeEnum::VideoEffect3Type,
    ::device::AttributeEnum::VideoEffect4Parameter1,
    ::device::AttributeEnum::VideoEffect4Parameter2,
    ::device::AttributeEnum::VideoEffect4Parameter3,
    ::device::AttributeEnum::VideoEffect4Parameter4,
    ::device::AttributeEnum::VideoEffect4Parameter5,
    ::device::AttributeEnum::VideoEffect4Type,
    ::device::AttributeEnum::VideoEffect5Parameter1,
    ::device::AttributeEnum::VideoEffect5Parameter2,
    ::device::AttributeEnum::VideoEffect5Parameter3,
    ::device::AttributeEnum::VideoEffect5Parameter4,
    ::device::AttributeEnum::VideoEffect5Parameter5,
    ::device::AttributeEnum::VideoEffect5Type,
    ::device::AttributeEnum::VideoScale1_All,
    ::device::AttributeEnum::VideoScale1_X,
    ::device::AttributeEnum::VideoScale1_Y,
    ::device::AttributeEnum::VideoScale1_Z,
    ::device::AttributeEnum::VideoScale2_All,
    ::device::AttributeEnum::VideoScale2_X,
    ::device::AttributeEnum::VideoScale2_Y,
    ::device::AttributeEnum::VideoScale2_Z,
    ::device::AttributeEnum::VideoScale3_All,
    ::device::AttributeEnum::VideoScale3_X,
    ::device::AttributeEnum::VideoScale3_Y,
    ::device::AttributeEnum::VideoScale3_Z,
    ::device::AttributeEnum::VideoScale4_All,
    ::device::AttributeEnum::VideoScale4_X,
    ::device::AttributeEnum::VideoScale4_Y,
    ::device::AttributeEnum::VideoScale4_Z,
    ::device::AttributeEnum::VideoScale5_All,
    ::device::AttributeEnum::VideoScale5_X,
    ::device::AttributeEnum::VideoScale5_Y,
    ::device::AttributeEnum::VideoScale5_Z,
    ::device::AttributeEnum::WavelengthCorrection,
    ::device::AttributeEnum::WhiteCount,
    ::device::AttributeEnum::XYZ_X,
    ::device::AttributeEnum::XYZ_Y,
    ::device::AttributeEnum::XYZ_Z,
    ::device::AttributeEnum::YellowMode,
    ::device::AttributeEnum::Zoom,
    ::device::AttributeEnum::ZoomMSpeed,
    ::device::AttributeEnum::ZoomMode,
    ::device::AttributeEnum::ZoomModeBeam,
    ::device::AttributeEnum::ZoomModeSpot,
    ::device::AttributeEnum::ZoomReset
  };

  // GDTF
  //

  GDTF::
  GDTF (const FixtureType_type& FixtureType,
        const DataVersion_type& DataVersion)
  : ::xml_schema::type (),
    FixtureType_ (FixtureType, this),
    DataVersion_ (DataVersion, this)
  {
  }

  GDTF::
  GDTF (::std::unique_ptr< FixtureType_type > FixtureType,
        const DataVersion_type& DataVersion)
  : ::xml_schema::type (),
    FixtureType_ (std::move (FixtureType), this),
    DataVersion_ (DataVersion, this)
  {
  }

  GDTF::
  GDTF (const GDTF& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FixtureType_ (x.FixtureType_, f, this),
    DataVersion_ (x.DataVersion_, f, this)
  {
  }

  GDTF::
  GDTF (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FixtureType_ (this),
    DataVersion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GDTF::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FixtureType
      //
      if (n.name () == "FixtureType" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FixtureType_type > r (
          FixtureType_traits::create (i, f, this));

        if (!FixtureType_.present ())
        {
          this->FixtureType_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!FixtureType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FixtureType",
        "http://schemas.gdtf-share.com/device");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "DataVersion" && n.namespace_ ().empty ())
      {
        this->DataVersion_.set (DataVersion_traits::create (i, f, this));
        continue;
      }
    }

    if (!DataVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "DataVersion",
        "");
    }
  }

  GDTF* GDTF::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GDTF (*this, f, c);
  }

  GDTF& GDTF::
  operator= (const GDTF& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FixtureType_ = x.FixtureType_;
      this->DataVersion_ = x.DataVersion_;
    }

    return *this;
  }

  GDTF::
  ~GDTF ()
  {
  }

  // FixtureType
  //

  FixtureType::
  FixtureType (const Name_type& Name,
               const Manufacturer_type& Manufacturer,
               const Description_type& Description,
               const FixtureTypeID_type& FixtureTypeID)
  : ::xml_schema::type (),
    AttributeDefinitions_ (this),
    Wheels_ (this),
    PhysicalDescriptions_ (this),
    Models_ (this),
    Geometries_ (this),
    DMXModes_ (this),
    Revisions_ (this),
    FTPresets_ (this),
    Protocols_ (this),
    Name_ (Name, this),
    ShortName_ (this),
    LongName_ (this),
    Manufacturer_ (Manufacturer, this),
    Description_ (Description, this),
    FixtureTypeID_ (FixtureTypeID, this),
    Thumbnail_ (this),
    RefFT_ (this)
  {
  }

  FixtureType::
  FixtureType (const FixtureType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AttributeDefinitions_ (x.AttributeDefinitions_, f, this),
    Wheels_ (x.Wheels_, f, this),
    PhysicalDescriptions_ (x.PhysicalDescriptions_, f, this),
    Models_ (x.Models_, f, this),
    Geometries_ (x.Geometries_, f, this),
    DMXModes_ (x.DMXModes_, f, this),
    Revisions_ (x.Revisions_, f, this),
    FTPresets_ (x.FTPresets_, f, this),
    Protocols_ (x.Protocols_, f, this),
    Name_ (x.Name_, f, this),
    ShortName_ (x.ShortName_, f, this),
    LongName_ (x.LongName_, f, this),
    Manufacturer_ (x.Manufacturer_, f, this),
    Description_ (x.Description_, f, this),
    FixtureTypeID_ (x.FixtureTypeID_, f, this),
    Thumbnail_ (x.Thumbnail_, f, this),
    RefFT_ (x.RefFT_, f, this)
  {
  }

  FixtureType::
  FixtureType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AttributeDefinitions_ (this),
    Wheels_ (this),
    PhysicalDescriptions_ (this),
    Models_ (this),
    Geometries_ (this),
    DMXModes_ (this),
    Revisions_ (this),
    FTPresets_ (this),
    Protocols_ (this),
    Name_ (this),
    ShortName_ (this),
    LongName_ (this),
    Manufacturer_ (this),
    Description_ (this),
    FixtureTypeID_ (this),
    Thumbnail_ (this),
    RefFT_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FixtureType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AttributeDefinitions
      //
      if (n.name () == "AttributeDefinitions" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< AttributeDefinitions_type > r (
          AttributeDefinitions_traits::create (i, f, this));

        this->AttributeDefinitions_.push_back (::std::move (r));
        continue;
      }

      // Wheels
      //
      if (n.name () == "Wheels" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Wheels_type > r (
          Wheels_traits::create (i, f, this));

        this->Wheels_.push_back (::std::move (r));
        continue;
      }

      // PhysicalDescriptions
      //
      if (n.name () == "PhysicalDescriptions" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< PhysicalDescriptions_type > r (
          PhysicalDescriptions_traits::create (i, f, this));

        this->PhysicalDescriptions_.push_back (::std::move (r));
        continue;
      }

      // Models
      //
      if (n.name () == "Models" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Models_type > r (
          Models_traits::create (i, f, this));

        this->Models_.push_back (::std::move (r));
        continue;
      }

      // Geometries
      //
      if (n.name () == "Geometries" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Geometries_type > r (
          Geometries_traits::create (i, f, this));

        this->Geometries_.push_back (::std::move (r));
        continue;
      }

      // DMXModes
      //
      if (n.name () == "DMXModes" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< DMXModes_type > r (
          DMXModes_traits::create (i, f, this));

        this->DMXModes_.push_back (::std::move (r));
        continue;
      }

      // Revisions
      //
      if (n.name () == "Revisions" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Revisions_type > r (
          Revisions_traits::create (i, f, this));

        this->Revisions_.push_back (::std::move (r));
        continue;
      }

      // FTPresets
      //
      if (n.name () == "FTPresets" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FTPresets_type > r (
          FTPresets_traits::create (i, f, this));

        this->FTPresets_.push_back (::std::move (r));
        continue;
      }

      // Protocols
      //
      if (n.name () == "Protocols" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Protocols_type > r (
          Protocols_traits::create (i, f, this));

        this->Protocols_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ShortName" && n.namespace_ ().empty ())
      {
        this->ShortName_.set (ShortName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "LongName" && n.namespace_ ().empty ())
      {
        this->LongName_.set (LongName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Manufacturer" && n.namespace_ ().empty ())
      {
        this->Manufacturer_.set (Manufacturer_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Description" && n.namespace_ ().empty ())
      {
        this->Description_.set (Description_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "FixtureTypeID" && n.namespace_ ().empty ())
      {
        this->FixtureTypeID_.set (FixtureTypeID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Thumbnail" && n.namespace_ ().empty ())
      {
        this->Thumbnail_.set (Thumbnail_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "RefFT" && n.namespace_ ().empty ())
      {
        this->RefFT_.set (RefFT_traits::create (i, f, this));
        continue;
      }
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Name",
        "");
    }

    if (!Manufacturer_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Manufacturer",
        "");
    }

    if (!Description_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Description",
        "");
    }

    if (!FixtureTypeID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "FixtureTypeID",
        "");
    }
  }

  FixtureType* FixtureType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FixtureType (*this, f, c);
  }

  FixtureType& FixtureType::
  operator= (const FixtureType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AttributeDefinitions_ = x.AttributeDefinitions_;
      this->Wheels_ = x.Wheels_;
      this->PhysicalDescriptions_ = x.PhysicalDescriptions_;
      this->Models_ = x.Models_;
      this->Geometries_ = x.Geometries_;
      this->DMXModes_ = x.DMXModes_;
      this->Revisions_ = x.Revisions_;
      this->FTPresets_ = x.FTPresets_;
      this->Protocols_ = x.Protocols_;
      this->Name_ = x.Name_;
      this->ShortName_ = x.ShortName_;
      this->LongName_ = x.LongName_;
      this->Manufacturer_ = x.Manufacturer_;
      this->Description_ = x.Description_;
      this->FixtureTypeID_ = x.FixtureTypeID_;
      this->Thumbnail_ = x.Thumbnail_;
      this->RefFT_ = x.RefFT_;
    }

    return *this;
  }

  FixtureType::
  ~FixtureType ()
  {
  }

  // Wheels
  //

  Wheels::
  Wheels ()
  : ::xml_schema::type (),
    Wheel_ (this)
  {
  }

  Wheels::
  Wheels (const Wheels& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Wheel_ (x.Wheel_, f, this)
  {
  }

  Wheels::
  Wheels (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Wheel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Wheels::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Wheel
      //
      if (n.name () == "Wheel" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Wheel_type > r (
          Wheel_traits::create (i, f, this));

        this->Wheel_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Wheels* Wheels::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Wheels (*this, f, c);
  }

  Wheels& Wheels::
  operator= (const Wheels& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Wheel_ = x.Wheel_;
    }

    return *this;
  }

  Wheels::
  ~Wheels ()
  {
  }

  // Wheel
  //

  Wheel::
  Wheel ()
  : ::xml_schema::type (),
    Slot_ (this),
    Name_ (this)
  {
  }

  Wheel::
  Wheel (const Wheel& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Slot_ (x.Slot_, f, this),
    Name_ (x.Name_, f, this)
  {
  }

  Wheel::
  Wheel (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Slot_ (this),
    Name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Wheel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Slot
      //
      if (n.name () == "Slot" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Slot_type > r (
          Slot_traits::create (i, f, this));

        this->Slot_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }
    }
  }

  Wheel* Wheel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Wheel (*this, f, c);
  }

  Wheel& Wheel::
  operator= (const Wheel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Slot_ = x.Slot_;
      this->Name_ = x.Name_;
    }

    return *this;
  }

  Wheel::
  ~Wheel ()
  {
  }

  // Slot
  //

  Slot::
  Slot (const Name_type& Name)
  : ::xml_schema::type (),
    Facet_ (this),
    Name_ (Name, this),
    Color_ (this),
    Filter_ (this),
    MediaFileName_ (this)
  {
  }

  Slot::
  Slot (const Slot& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Facet_ (x.Facet_, f, this),
    Name_ (x.Name_, f, this),
    Color_ (x.Color_, f, this),
    Filter_ (x.Filter_, f, this),
    MediaFileName_ (x.MediaFileName_, f, this)
  {
  }

  Slot::
  Slot (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Facet_ (this),
    Name_ (this),
    Color_ (this),
    Filter_ (this),
    MediaFileName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Slot::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Facet
      //
      if (n.name () == "Facet" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Facet_type > r (
          Facet_traits::create (i, f, this));

        this->Facet_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Color" && n.namespace_ ().empty ())
      {
        this->Color_.set (Color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Filter" && n.namespace_ ().empty ())
      {
        this->Filter_.set (Filter_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "MediaFileName" && n.namespace_ ().empty ())
      {
        this->MediaFileName_.set (MediaFileName_traits::create (i, f, this));
        continue;
      }
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Name",
        "");
    }
  }

  Slot* Slot::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Slot (*this, f, c);
  }

  Slot& Slot::
  operator= (const Slot& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Facet_ = x.Facet_;
      this->Name_ = x.Name_;
      this->Color_ = x.Color_;
      this->Filter_ = x.Filter_;
      this->MediaFileName_ = x.MediaFileName_;
    }

    return *this;
  }

  Slot::
  ~Slot ()
  {
  }

  // Facet
  //

  Facet::
  Facet ()
  : ::xml_schema::type (),
    Color_ (this),
    Rotation_ (this)
  {
  }

  Facet::
  Facet (const Facet& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Color_ (x.Color_, f, this),
    Rotation_ (x.Rotation_, f, this)
  {
  }

  Facet::
  Facet (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Color_ (this),
    Rotation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Facet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Color" && n.namespace_ ().empty ())
      {
        this->Color_.set (Color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Rotation" && n.namespace_ ().empty ())
      {
        this->Rotation_.set (Rotation_traits::create (i, f, this));
        continue;
      }
    }
  }

  Facet* Facet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Facet (*this, f, c);
  }

  Facet& Facet::
  operator= (const Facet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Color_ = x.Color_;
      this->Rotation_ = x.Rotation_;
    }

    return *this;
  }

  Facet::
  ~Facet ()
  {
  }

  // Models
  //

  Models::
  Models ()
  : ::xml_schema::type (),
    Model_ (this)
  {
  }

  Models::
  Models (const Models& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Model_ (x.Model_, f, this)
  {
  }

  Models::
  Models (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Model_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Models::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Model
      //
      if (n.name () == "Model" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Model_type > r (
          Model_traits::create (i, f, this));

        this->Model_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Models* Models::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Models (*this, f, c);
  }

  Models& Models::
  operator= (const Models& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Model_ = x.Model_;
    }

    return *this;
  }

  Models::
  ~Models ()
  {
  }

  // Model
  //

  Model::
  Model (const Name_type& Name)
  : ::xml_schema::type (),
    Name_ (Name, this),
    Length_ (this),
    Width_ (this),
    Height_ (this),
    PrimitiveType_ (this),
    File_ (this)
  {
  }

  Model::
  Model (const Model& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Name_ (x.Name_, f, this),
    Length_ (x.Length_, f, this),
    Width_ (x.Width_, f, this),
    Height_ (x.Height_, f, this),
    PrimitiveType_ (x.PrimitiveType_, f, this),
    File_ (x.File_, f, this)
  {
  }

  Model::
  Model (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Name_ (this),
    Length_ (this),
    Width_ (this),
    Height_ (this),
    PrimitiveType_ (this),
    File_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Model::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Length" && n.namespace_ ().empty ())
      {
        this->Length_.set (Length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Width" && n.namespace_ ().empty ())
      {
        this->Width_.set (Width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Height" && n.namespace_ ().empty ())
      {
        this->Height_.set (Height_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "PrimitiveType" && n.namespace_ ().empty ())
      {
        this->PrimitiveType_.set (PrimitiveType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "File" && n.namespace_ ().empty ())
      {
        this->File_.set (File_traits::create (i, f, this));
        continue;
      }
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Name",
        "");
    }
  }

  Model* Model::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Model (*this, f, c);
  }

  Model& Model::
  operator= (const Model& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Name_ = x.Name_;
      this->Length_ = x.Length_;
      this->Width_ = x.Width_;
      this->Height_ = x.Height_;
      this->PrimitiveType_ = x.PrimitiveType_;
      this->File_ = x.File_;
    }

    return *this;
  }

  Model::
  ~Model ()
  {
  }

  // Geometries
  //

  Geometries::
  Geometries ()
  : ::xml_schema::type (),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this)
  {
  }

  Geometries::
  Geometries (const Geometries& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Geometry_ (x.Geometry_, f, this),
    Axis_ (x.Axis_, f, this),
    FilterBeam_ (x.FilterBeam_, f, this),
    FilterColor_ (x.FilterColor_, f, this),
    FilterGobo_ (x.FilterGobo_, f, this),
    FilterShaper_ (x.FilterShaper_, f, this),
    Beam_ (x.Beam_, f, this),
    GeometryReference_ (x.GeometryReference_, f, this)
  {
  }

  Geometries::
  Geometries (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Geometries::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Geometry
      //
      if (n.name () == "Geometry" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Geometry_type > r (
          Geometry_traits::create (i, f, this));

        this->Geometry_.push_back (::std::move (r));
        continue;
      }

      // Axis
      //
      if (n.name () == "Axis" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Axis_type > r (
          Axis_traits::create (i, f, this));

        this->Axis_.push_back (::std::move (r));
        continue;
      }

      // FilterBeam
      //
      if (n.name () == "FilterBeam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterBeam_type > r (
          FilterBeam_traits::create (i, f, this));

        this->FilterBeam_.push_back (::std::move (r));
        continue;
      }

      // FilterColor
      //
      if (n.name () == "FilterColor" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterColor_type > r (
          FilterColor_traits::create (i, f, this));

        this->FilterColor_.push_back (::std::move (r));
        continue;
      }

      // FilterGobo
      //
      if (n.name () == "FilterGobo" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterGobo_type > r (
          FilterGobo_traits::create (i, f, this));

        this->FilterGobo_.push_back (::std::move (r));
        continue;
      }

      // FilterShaper
      //
      if (n.name () == "FilterShaper" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterShaper_type > r (
          FilterShaper_traits::create (i, f, this));

        this->FilterShaper_.push_back (::std::move (r));
        continue;
      }

      // Beam
      //
      if (n.name () == "Beam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Beam_type > r (
          Beam_traits::create (i, f, this));

        this->Beam_.push_back (::std::move (r));
        continue;
      }

      // GeometryReference
      //
      if (n.name () == "GeometryReference" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< GeometryReference_type > r (
          GeometryReference_traits::create (i, f, this));

        this->GeometryReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Geometries* Geometries::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Geometries (*this, f, c);
  }

  Geometries& Geometries::
  operator= (const Geometries& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Geometry_ = x.Geometry_;
      this->Axis_ = x.Axis_;
      this->FilterBeam_ = x.FilterBeam_;
      this->FilterColor_ = x.FilterColor_;
      this->FilterGobo_ = x.FilterGobo_;
      this->FilterShaper_ = x.FilterShaper_;
      this->Beam_ = x.Beam_;
      this->GeometryReference_ = x.GeometryReference_;
    }

    return *this;
  }

  Geometries::
  ~Geometries ()
  {
  }

  // Geometry
  //

  Geometry::
  Geometry ()
  : ::xml_schema::type (),
    Geometry1_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
  }

  Geometry::
  Geometry (const Geometry& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Geometry1_ (x.Geometry1_, f, this),
    Axis_ (x.Axis_, f, this),
    FilterBeam_ (x.FilterBeam_, f, this),
    FilterColor_ (x.FilterColor_, f, this),
    FilterGobo_ (x.FilterGobo_, f, this),
    FilterShaper_ (x.FilterShaper_, f, this),
    Beam_ (x.Beam_, f, this),
    GeometryReference_ (x.GeometryReference_, f, this),
    Name_ (x.Name_, f, this),
    Model_ (x.Model_, f, this),
    Position_ (x.Position_, f, this)
  {
  }

  Geometry::
  Geometry (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Geometry1_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Geometry::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Geometry
      //
      if (n.name () == "Geometry" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Geometry1_type > r (
          Geometry1_traits::create (i, f, this));

        this->Geometry1_.push_back (::std::move (r));
        continue;
      }

      // Axis
      //
      if (n.name () == "Axis" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Axis_type > r (
          Axis_traits::create (i, f, this));

        this->Axis_.push_back (::std::move (r));
        continue;
      }

      // FilterBeam
      //
      if (n.name () == "FilterBeam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterBeam_type > r (
          FilterBeam_traits::create (i, f, this));

        this->FilterBeam_.push_back (::std::move (r));
        continue;
      }

      // FilterColor
      //
      if (n.name () == "FilterColor" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterColor_type > r (
          FilterColor_traits::create (i, f, this));

        this->FilterColor_.push_back (::std::move (r));
        continue;
      }

      // FilterGobo
      //
      if (n.name () == "FilterGobo" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterGobo_type > r (
          FilterGobo_traits::create (i, f, this));

        this->FilterGobo_.push_back (::std::move (r));
        continue;
      }

      // FilterShaper
      //
      if (n.name () == "FilterShaper" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterShaper_type > r (
          FilterShaper_traits::create (i, f, this));

        this->FilterShaper_.push_back (::std::move (r));
        continue;
      }

      // Beam
      //
      if (n.name () == "Beam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Beam_type > r (
          Beam_traits::create (i, f, this));

        this->Beam_.push_back (::std::move (r));
        continue;
      }

      // GeometryReference
      //
      if (n.name () == "GeometryReference" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< GeometryReference_type > r (
          GeometryReference_traits::create (i, f, this));

        this->GeometryReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Model" && n.namespace_ ().empty ())
      {
        this->Model_.set (Model_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Position" && n.namespace_ ().empty ())
      {
        this->Position_.set (Position_traits::create (i, f, this));
        continue;
      }
    }
  }

  Geometry* Geometry::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Geometry (*this, f, c);
  }

  Geometry& Geometry::
  operator= (const Geometry& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Geometry1_ = x.Geometry1_;
      this->Axis_ = x.Axis_;
      this->FilterBeam_ = x.FilterBeam_;
      this->FilterColor_ = x.FilterColor_;
      this->FilterGobo_ = x.FilterGobo_;
      this->FilterShaper_ = x.FilterShaper_;
      this->Beam_ = x.Beam_;
      this->GeometryReference_ = x.GeometryReference_;
      this->Name_ = x.Name_;
      this->Model_ = x.Model_;
      this->Position_ = x.Position_;
    }

    return *this;
  }

  Geometry::
  ~Geometry ()
  {
  }

  // Axis
  //

  Axis::
  Axis ()
  : ::xml_schema::type (),
    Geometry_ (this),
    Axis1_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
  }

  Axis::
  Axis (const Axis& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Geometry_ (x.Geometry_, f, this),
    Axis1_ (x.Axis1_, f, this),
    FilterBeam_ (x.FilterBeam_, f, this),
    FilterColor_ (x.FilterColor_, f, this),
    FilterGobo_ (x.FilterGobo_, f, this),
    FilterShaper_ (x.FilterShaper_, f, this),
    Beam_ (x.Beam_, f, this),
    GeometryReference_ (x.GeometryReference_, f, this),
    Name_ (x.Name_, f, this),
    Model_ (x.Model_, f, this),
    Position_ (x.Position_, f, this)
  {
  }

  Axis::
  Axis (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Geometry_ (this),
    Axis1_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Axis::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Geometry
      //
      if (n.name () == "Geometry" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Geometry_type > r (
          Geometry_traits::create (i, f, this));

        this->Geometry_.push_back (::std::move (r));
        continue;
      }

      // Axis
      //
      if (n.name () == "Axis" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Axis1_type > r (
          Axis1_traits::create (i, f, this));

        this->Axis1_.push_back (::std::move (r));
        continue;
      }

      // FilterBeam
      //
      if (n.name () == "FilterBeam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterBeam_type > r (
          FilterBeam_traits::create (i, f, this));

        this->FilterBeam_.push_back (::std::move (r));
        continue;
      }

      // FilterColor
      //
      if (n.name () == "FilterColor" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterColor_type > r (
          FilterColor_traits::create (i, f, this));

        this->FilterColor_.push_back (::std::move (r));
        continue;
      }

      // FilterGobo
      //
      if (n.name () == "FilterGobo" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterGobo_type > r (
          FilterGobo_traits::create (i, f, this));

        this->FilterGobo_.push_back (::std::move (r));
        continue;
      }

      // FilterShaper
      //
      if (n.name () == "FilterShaper" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterShaper_type > r (
          FilterShaper_traits::create (i, f, this));

        this->FilterShaper_.push_back (::std::move (r));
        continue;
      }

      // Beam
      //
      if (n.name () == "Beam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Beam_type > r (
          Beam_traits::create (i, f, this));

        this->Beam_.push_back (::std::move (r));
        continue;
      }

      // GeometryReference
      //
      if (n.name () == "GeometryReference" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< GeometryReference_type > r (
          GeometryReference_traits::create (i, f, this));

        this->GeometryReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Model" && n.namespace_ ().empty ())
      {
        this->Model_.set (Model_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Position" && n.namespace_ ().empty ())
      {
        this->Position_.set (Position_traits::create (i, f, this));
        continue;
      }
    }
  }

  Axis* Axis::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Axis (*this, f, c);
  }

  Axis& Axis::
  operator= (const Axis& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Geometry_ = x.Geometry_;
      this->Axis1_ = x.Axis1_;
      this->FilterBeam_ = x.FilterBeam_;
      this->FilterColor_ = x.FilterColor_;
      this->FilterGobo_ = x.FilterGobo_;
      this->FilterShaper_ = x.FilterShaper_;
      this->Beam_ = x.Beam_;
      this->GeometryReference_ = x.GeometryReference_;
      this->Name_ = x.Name_;
      this->Model_ = x.Model_;
      this->Position_ = x.Position_;
    }

    return *this;
  }

  Axis::
  ~Axis ()
  {
  }

  // FilterBeam
  //

  FilterBeam::
  FilterBeam ()
  : ::xml_schema::type (),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam1_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
  }

  FilterBeam::
  FilterBeam (const FilterBeam& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Geometry_ (x.Geometry_, f, this),
    Axis_ (x.Axis_, f, this),
    FilterBeam1_ (x.FilterBeam1_, f, this),
    FilterColor_ (x.FilterColor_, f, this),
    FilterGobo_ (x.FilterGobo_, f, this),
    FilterShaper_ (x.FilterShaper_, f, this),
    Beam_ (x.Beam_, f, this),
    GeometryReference_ (x.GeometryReference_, f, this),
    Name_ (x.Name_, f, this),
    Model_ (x.Model_, f, this),
    Position_ (x.Position_, f, this)
  {
  }

  FilterBeam::
  FilterBeam (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam1_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FilterBeam::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Geometry
      //
      if (n.name () == "Geometry" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Geometry_type > r (
          Geometry_traits::create (i, f, this));

        this->Geometry_.push_back (::std::move (r));
        continue;
      }

      // Axis
      //
      if (n.name () == "Axis" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Axis_type > r (
          Axis_traits::create (i, f, this));

        this->Axis_.push_back (::std::move (r));
        continue;
      }

      // FilterBeam
      //
      if (n.name () == "FilterBeam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterBeam1_type > r (
          FilterBeam1_traits::create (i, f, this));

        this->FilterBeam1_.push_back (::std::move (r));
        continue;
      }

      // FilterColor
      //
      if (n.name () == "FilterColor" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterColor_type > r (
          FilterColor_traits::create (i, f, this));

        this->FilterColor_.push_back (::std::move (r));
        continue;
      }

      // FilterGobo
      //
      if (n.name () == "FilterGobo" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterGobo_type > r (
          FilterGobo_traits::create (i, f, this));

        this->FilterGobo_.push_back (::std::move (r));
        continue;
      }

      // FilterShaper
      //
      if (n.name () == "FilterShaper" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterShaper_type > r (
          FilterShaper_traits::create (i, f, this));

        this->FilterShaper_.push_back (::std::move (r));
        continue;
      }

      // Beam
      //
      if (n.name () == "Beam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Beam_type > r (
          Beam_traits::create (i, f, this));

        this->Beam_.push_back (::std::move (r));
        continue;
      }

      // GeometryReference
      //
      if (n.name () == "GeometryReference" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< GeometryReference_type > r (
          GeometryReference_traits::create (i, f, this));

        this->GeometryReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Model" && n.namespace_ ().empty ())
      {
        this->Model_.set (Model_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Position" && n.namespace_ ().empty ())
      {
        this->Position_.set (Position_traits::create (i, f, this));
        continue;
      }
    }
  }

  FilterBeam* FilterBeam::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FilterBeam (*this, f, c);
  }

  FilterBeam& FilterBeam::
  operator= (const FilterBeam& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Geometry_ = x.Geometry_;
      this->Axis_ = x.Axis_;
      this->FilterBeam1_ = x.FilterBeam1_;
      this->FilterColor_ = x.FilterColor_;
      this->FilterGobo_ = x.FilterGobo_;
      this->FilterShaper_ = x.FilterShaper_;
      this->Beam_ = x.Beam_;
      this->GeometryReference_ = x.GeometryReference_;
      this->Name_ = x.Name_;
      this->Model_ = x.Model_;
      this->Position_ = x.Position_;
    }

    return *this;
  }

  FilterBeam::
  ~FilterBeam ()
  {
  }

  // FilterColor
  //

  FilterColor::
  FilterColor ()
  : ::xml_schema::type (),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor1_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
  }

  FilterColor::
  FilterColor (const FilterColor& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Geometry_ (x.Geometry_, f, this),
    Axis_ (x.Axis_, f, this),
    FilterBeam_ (x.FilterBeam_, f, this),
    FilterColor1_ (x.FilterColor1_, f, this),
    FilterGobo_ (x.FilterGobo_, f, this),
    FilterShaper_ (x.FilterShaper_, f, this),
    Beam_ (x.Beam_, f, this),
    GeometryReference_ (x.GeometryReference_, f, this),
    Name_ (x.Name_, f, this),
    Model_ (x.Model_, f, this),
    Position_ (x.Position_, f, this)
  {
  }

  FilterColor::
  FilterColor (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor1_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FilterColor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Geometry
      //
      if (n.name () == "Geometry" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Geometry_type > r (
          Geometry_traits::create (i, f, this));

        this->Geometry_.push_back (::std::move (r));
        continue;
      }

      // Axis
      //
      if (n.name () == "Axis" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Axis_type > r (
          Axis_traits::create (i, f, this));

        this->Axis_.push_back (::std::move (r));
        continue;
      }

      // FilterBeam
      //
      if (n.name () == "FilterBeam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterBeam_type > r (
          FilterBeam_traits::create (i, f, this));

        this->FilterBeam_.push_back (::std::move (r));
        continue;
      }

      // FilterColor
      //
      if (n.name () == "FilterColor" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterColor1_type > r (
          FilterColor1_traits::create (i, f, this));

        this->FilterColor1_.push_back (::std::move (r));
        continue;
      }

      // FilterGobo
      //
      if (n.name () == "FilterGobo" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterGobo_type > r (
          FilterGobo_traits::create (i, f, this));

        this->FilterGobo_.push_back (::std::move (r));
        continue;
      }

      // FilterShaper
      //
      if (n.name () == "FilterShaper" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterShaper_type > r (
          FilterShaper_traits::create (i, f, this));

        this->FilterShaper_.push_back (::std::move (r));
        continue;
      }

      // Beam
      //
      if (n.name () == "Beam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Beam_type > r (
          Beam_traits::create (i, f, this));

        this->Beam_.push_back (::std::move (r));
        continue;
      }

      // GeometryReference
      //
      if (n.name () == "GeometryReference" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< GeometryReference_type > r (
          GeometryReference_traits::create (i, f, this));

        this->GeometryReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Model" && n.namespace_ ().empty ())
      {
        this->Model_.set (Model_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Position" && n.namespace_ ().empty ())
      {
        this->Position_.set (Position_traits::create (i, f, this));
        continue;
      }
    }
  }

  FilterColor* FilterColor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FilterColor (*this, f, c);
  }

  FilterColor& FilterColor::
  operator= (const FilterColor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Geometry_ = x.Geometry_;
      this->Axis_ = x.Axis_;
      this->FilterBeam_ = x.FilterBeam_;
      this->FilterColor1_ = x.FilterColor1_;
      this->FilterGobo_ = x.FilterGobo_;
      this->FilterShaper_ = x.FilterShaper_;
      this->Beam_ = x.Beam_;
      this->GeometryReference_ = x.GeometryReference_;
      this->Name_ = x.Name_;
      this->Model_ = x.Model_;
      this->Position_ = x.Position_;
    }

    return *this;
  }

  FilterColor::
  ~FilterColor ()
  {
  }

  // FilterGobo
  //

  FilterGobo::
  FilterGobo ()
  : ::xml_schema::type (),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo1_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
  }

  FilterGobo::
  FilterGobo (const FilterGobo& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Geometry_ (x.Geometry_, f, this),
    Axis_ (x.Axis_, f, this),
    FilterBeam_ (x.FilterBeam_, f, this),
    FilterColor_ (x.FilterColor_, f, this),
    FilterGobo1_ (x.FilterGobo1_, f, this),
    FilterShaper_ (x.FilterShaper_, f, this),
    Beam_ (x.Beam_, f, this),
    GeometryReference_ (x.GeometryReference_, f, this),
    Name_ (x.Name_, f, this),
    Model_ (x.Model_, f, this),
    Position_ (x.Position_, f, this)
  {
  }

  FilterGobo::
  FilterGobo (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo1_ (this),
    FilterShaper_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FilterGobo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Geometry
      //
      if (n.name () == "Geometry" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Geometry_type > r (
          Geometry_traits::create (i, f, this));

        this->Geometry_.push_back (::std::move (r));
        continue;
      }

      // Axis
      //
      if (n.name () == "Axis" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Axis_type > r (
          Axis_traits::create (i, f, this));

        this->Axis_.push_back (::std::move (r));
        continue;
      }

      // FilterBeam
      //
      if (n.name () == "FilterBeam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterBeam_type > r (
          FilterBeam_traits::create (i, f, this));

        this->FilterBeam_.push_back (::std::move (r));
        continue;
      }

      // FilterColor
      //
      if (n.name () == "FilterColor" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterColor_type > r (
          FilterColor_traits::create (i, f, this));

        this->FilterColor_.push_back (::std::move (r));
        continue;
      }

      // FilterGobo
      //
      if (n.name () == "FilterGobo" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterGobo1_type > r (
          FilterGobo1_traits::create (i, f, this));

        this->FilterGobo1_.push_back (::std::move (r));
        continue;
      }

      // FilterShaper
      //
      if (n.name () == "FilterShaper" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterShaper_type > r (
          FilterShaper_traits::create (i, f, this));

        this->FilterShaper_.push_back (::std::move (r));
        continue;
      }

      // Beam
      //
      if (n.name () == "Beam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Beam_type > r (
          Beam_traits::create (i, f, this));

        this->Beam_.push_back (::std::move (r));
        continue;
      }

      // GeometryReference
      //
      if (n.name () == "GeometryReference" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< GeometryReference_type > r (
          GeometryReference_traits::create (i, f, this));

        this->GeometryReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Model" && n.namespace_ ().empty ())
      {
        this->Model_.set (Model_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Position" && n.namespace_ ().empty ())
      {
        this->Position_.set (Position_traits::create (i, f, this));
        continue;
      }
    }
  }

  FilterGobo* FilterGobo::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FilterGobo (*this, f, c);
  }

  FilterGobo& FilterGobo::
  operator= (const FilterGobo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Geometry_ = x.Geometry_;
      this->Axis_ = x.Axis_;
      this->FilterBeam_ = x.FilterBeam_;
      this->FilterColor_ = x.FilterColor_;
      this->FilterGobo1_ = x.FilterGobo1_;
      this->FilterShaper_ = x.FilterShaper_;
      this->Beam_ = x.Beam_;
      this->GeometryReference_ = x.GeometryReference_;
      this->Name_ = x.Name_;
      this->Model_ = x.Model_;
      this->Position_ = x.Position_;
    }

    return *this;
  }

  FilterGobo::
  ~FilterGobo ()
  {
  }

  // FilterShaper
  //

  FilterShaper::
  FilterShaper ()
  : ::xml_schema::type (),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper1_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
  }

  FilterShaper::
  FilterShaper (const FilterShaper& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Geometry_ (x.Geometry_, f, this),
    Axis_ (x.Axis_, f, this),
    FilterBeam_ (x.FilterBeam_, f, this),
    FilterColor_ (x.FilterColor_, f, this),
    FilterGobo_ (x.FilterGobo_, f, this),
    FilterShaper1_ (x.FilterShaper1_, f, this),
    Beam_ (x.Beam_, f, this),
    GeometryReference_ (x.GeometryReference_, f, this),
    Name_ (x.Name_, f, this),
    Model_ (x.Model_, f, this),
    Position_ (x.Position_, f, this)
  {
  }

  FilterShaper::
  FilterShaper (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper1_ (this),
    Beam_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FilterShaper::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Geometry
      //
      if (n.name () == "Geometry" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Geometry_type > r (
          Geometry_traits::create (i, f, this));

        this->Geometry_.push_back (::std::move (r));
        continue;
      }

      // Axis
      //
      if (n.name () == "Axis" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Axis_type > r (
          Axis_traits::create (i, f, this));

        this->Axis_.push_back (::std::move (r));
        continue;
      }

      // FilterBeam
      //
      if (n.name () == "FilterBeam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterBeam_type > r (
          FilterBeam_traits::create (i, f, this));

        this->FilterBeam_.push_back (::std::move (r));
        continue;
      }

      // FilterColor
      //
      if (n.name () == "FilterColor" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterColor_type > r (
          FilterColor_traits::create (i, f, this));

        this->FilterColor_.push_back (::std::move (r));
        continue;
      }

      // FilterGobo
      //
      if (n.name () == "FilterGobo" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterGobo_type > r (
          FilterGobo_traits::create (i, f, this));

        this->FilterGobo_.push_back (::std::move (r));
        continue;
      }

      // FilterShaper
      //
      if (n.name () == "FilterShaper" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterShaper1_type > r (
          FilterShaper1_traits::create (i, f, this));

        this->FilterShaper1_.push_back (::std::move (r));
        continue;
      }

      // Beam
      //
      if (n.name () == "Beam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Beam_type > r (
          Beam_traits::create (i, f, this));

        this->Beam_.push_back (::std::move (r));
        continue;
      }

      // GeometryReference
      //
      if (n.name () == "GeometryReference" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< GeometryReference_type > r (
          GeometryReference_traits::create (i, f, this));

        this->GeometryReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Model" && n.namespace_ ().empty ())
      {
        this->Model_.set (Model_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Position" && n.namespace_ ().empty ())
      {
        this->Position_.set (Position_traits::create (i, f, this));
        continue;
      }
    }
  }

  FilterShaper* FilterShaper::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FilterShaper (*this, f, c);
  }

  FilterShaper& FilterShaper::
  operator= (const FilterShaper& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Geometry_ = x.Geometry_;
      this->Axis_ = x.Axis_;
      this->FilterBeam_ = x.FilterBeam_;
      this->FilterColor_ = x.FilterColor_;
      this->FilterGobo_ = x.FilterGobo_;
      this->FilterShaper1_ = x.FilterShaper1_;
      this->Beam_ = x.Beam_;
      this->GeometryReference_ = x.GeometryReference_;
      this->Name_ = x.Name_;
      this->Model_ = x.Model_;
      this->Position_ = x.Position_;
    }

    return *this;
  }

  FilterShaper::
  ~FilterShaper ()
  {
  }

  // Beam
  //

  Beam::
  Beam (const Name_type& Name,
        const Model_type& Model,
        const Position_type& Position)
  : ::xml_schema::type (),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam1_ (this),
    GeometryReference_ (this),
    Name_ (Name, this),
    Model_ (Model, this),
    Position_ (Position, this),
    LampType_ (this),
    PowerConsumption_ (this),
    LuminousFlux_ (this),
    ColorTemperature_ (this),
    BeamAngle_ (this),
    FieldAngle_ (this),
    BeamRadius_ (this),
    BeamType_ (this),
    ColorRenderingIndex_ (this)
  {
  }

  Beam::
  Beam (const Beam& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Geometry_ (x.Geometry_, f, this),
    Axis_ (x.Axis_, f, this),
    FilterBeam_ (x.FilterBeam_, f, this),
    FilterColor_ (x.FilterColor_, f, this),
    FilterGobo_ (x.FilterGobo_, f, this),
    FilterShaper_ (x.FilterShaper_, f, this),
    Beam1_ (x.Beam1_, f, this),
    GeometryReference_ (x.GeometryReference_, f, this),
    Name_ (x.Name_, f, this),
    Model_ (x.Model_, f, this),
    Position_ (x.Position_, f, this),
    LampType_ (x.LampType_, f, this),
    PowerConsumption_ (x.PowerConsumption_, f, this),
    LuminousFlux_ (x.LuminousFlux_, f, this),
    ColorTemperature_ (x.ColorTemperature_, f, this),
    BeamAngle_ (x.BeamAngle_, f, this),
    FieldAngle_ (x.FieldAngle_, f, this),
    BeamRadius_ (x.BeamRadius_, f, this),
    BeamType_ (x.BeamType_, f, this),
    ColorRenderingIndex_ (x.ColorRenderingIndex_, f, this)
  {
  }

  Beam::
  Beam (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Geometry_ (this),
    Axis_ (this),
    FilterBeam_ (this),
    FilterColor_ (this),
    FilterGobo_ (this),
    FilterShaper_ (this),
    Beam1_ (this),
    GeometryReference_ (this),
    Name_ (this),
    Model_ (this),
    Position_ (this),
    LampType_ (this),
    PowerConsumption_ (this),
    LuminousFlux_ (this),
    ColorTemperature_ (this),
    BeamAngle_ (this),
    FieldAngle_ (this),
    BeamRadius_ (this),
    BeamType_ (this),
    ColorRenderingIndex_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Beam::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Geometry
      //
      if (n.name () == "Geometry" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Geometry_type > r (
          Geometry_traits::create (i, f, this));

        this->Geometry_.push_back (::std::move (r));
        continue;
      }

      // Axis
      //
      if (n.name () == "Axis" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Axis_type > r (
          Axis_traits::create (i, f, this));

        this->Axis_.push_back (::std::move (r));
        continue;
      }

      // FilterBeam
      //
      if (n.name () == "FilterBeam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterBeam_type > r (
          FilterBeam_traits::create (i, f, this));

        this->FilterBeam_.push_back (::std::move (r));
        continue;
      }

      // FilterColor
      //
      if (n.name () == "FilterColor" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterColor_type > r (
          FilterColor_traits::create (i, f, this));

        this->FilterColor_.push_back (::std::move (r));
        continue;
      }

      // FilterGobo
      //
      if (n.name () == "FilterGobo" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterGobo_type > r (
          FilterGobo_traits::create (i, f, this));

        this->FilterGobo_.push_back (::std::move (r));
        continue;
      }

      // FilterShaper
      //
      if (n.name () == "FilterShaper" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FilterShaper_type > r (
          FilterShaper_traits::create (i, f, this));

        this->FilterShaper_.push_back (::std::move (r));
        continue;
      }

      // Beam
      //
      if (n.name () == "Beam" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Beam1_type > r (
          Beam1_traits::create (i, f, this));

        this->Beam1_.push_back (::std::move (r));
        continue;
      }

      // GeometryReference
      //
      if (n.name () == "GeometryReference" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< GeometryReference_type > r (
          GeometryReference_traits::create (i, f, this));

        this->GeometryReference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Model" && n.namespace_ ().empty ())
      {
        this->Model_.set (Model_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Position" && n.namespace_ ().empty ())
      {
        this->Position_.set (Position_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "LampType" && n.namespace_ ().empty ())
      {
        this->LampType_.set (LampType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "PowerConsumption" && n.namespace_ ().empty ())
      {
        this->PowerConsumption_.set (PowerConsumption_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "LuminousFlux" && n.namespace_ ().empty ())
      {
        this->LuminousFlux_.set (LuminousFlux_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ColorTemperature" && n.namespace_ ().empty ())
      {
        this->ColorTemperature_.set (ColorTemperature_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "BeamAngle" && n.namespace_ ().empty ())
      {
        this->BeamAngle_.set (BeamAngle_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "FieldAngle" && n.namespace_ ().empty ())
      {
        this->FieldAngle_.set (FieldAngle_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "BeamRadius" && n.namespace_ ().empty ())
      {
        this->BeamRadius_.set (BeamRadius_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "BeamType" && n.namespace_ ().empty ())
      {
        this->BeamType_.set (BeamType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ColorRenderingIndex" && n.namespace_ ().empty ())
      {
        this->ColorRenderingIndex_.set (ColorRenderingIndex_traits::create (i, f, this));
        continue;
      }
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Name",
        "");
    }

    if (!Model_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Model",
        "");
    }

    if (!Position_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Position",
        "");
    }
  }

  Beam* Beam::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Beam (*this, f, c);
  }

  Beam& Beam::
  operator= (const Beam& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Geometry_ = x.Geometry_;
      this->Axis_ = x.Axis_;
      this->FilterBeam_ = x.FilterBeam_;
      this->FilterColor_ = x.FilterColor_;
      this->FilterGobo_ = x.FilterGobo_;
      this->FilterShaper_ = x.FilterShaper_;
      this->Beam1_ = x.Beam1_;
      this->GeometryReference_ = x.GeometryReference_;
      this->Name_ = x.Name_;
      this->Model_ = x.Model_;
      this->Position_ = x.Position_;
      this->LampType_ = x.LampType_;
      this->PowerConsumption_ = x.PowerConsumption_;
      this->LuminousFlux_ = x.LuminousFlux_;
      this->ColorTemperature_ = x.ColorTemperature_;
      this->BeamAngle_ = x.BeamAngle_;
      this->FieldAngle_ = x.FieldAngle_;
      this->BeamRadius_ = x.BeamRadius_;
      this->BeamType_ = x.BeamType_;
      this->ColorRenderingIndex_ = x.ColorRenderingIndex_;
    }

    return *this;
  }

  Beam::
  ~Beam ()
  {
  }

  // GeometryReference
  //

  GeometryReference::
  GeometryReference ()
  : ::xml_schema::type (),
    Break_ (this),
    Name_ (this),
    Position_ (this),
    Geometry_ (this),
    Model_ (this)
  {
  }

  GeometryReference::
  GeometryReference (const GeometryReference& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Break_ (x.Break_, f, this),
    Name_ (x.Name_, f, this),
    Position_ (x.Position_, f, this),
    Geometry_ (x.Geometry_, f, this),
    Model_ (x.Model_, f, this)
  {
  }

  GeometryReference::
  GeometryReference (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Break_ (this),
    Name_ (this),
    Position_ (this),
    Geometry_ (this),
    Model_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GeometryReference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Break
      //
      if (n.name () == "Break" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Break_type > r (
          Break_traits::create (i, f, this));

        this->Break_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Position" && n.namespace_ ().empty ())
      {
        this->Position_.set (Position_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Geometry" && n.namespace_ ().empty ())
      {
        this->Geometry_.set (Geometry_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Model" && n.namespace_ ().empty ())
      {
        this->Model_.set (Model_traits::create (i, f, this));
        continue;
      }
    }
  }

  GeometryReference* GeometryReference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GeometryReference (*this, f, c);
  }

  GeometryReference& GeometryReference::
  operator= (const GeometryReference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Break_ = x.Break_;
      this->Name_ = x.Name_;
      this->Position_ = x.Position_;
      this->Geometry_ = x.Geometry_;
      this->Model_ = x.Model_;
    }

    return *this;
  }

  GeometryReference::
  ~GeometryReference ()
  {
  }

  // Break
  //

  Break::
  Break ()
  : ::xml_schema::type (),
    DMXOffset_ (this),
    DMXBreak_ (this)
  {
  }

  Break::
  Break (const Break& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DMXOffset_ (x.DMXOffset_, f, this),
    DMXBreak_ (x.DMXBreak_, f, this)
  {
  }

  Break::
  Break (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DMXOffset_ (this),
    DMXBreak_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Break::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "DMXOffset" && n.namespace_ ().empty ())
      {
        this->DMXOffset_.set (DMXOffset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DMXBreak" && n.namespace_ ().empty ())
      {
        this->DMXBreak_.set (DMXBreak_traits::create (i, f, this));
        continue;
      }
    }
  }

  Break* Break::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Break (*this, f, c);
  }

  Break& Break::
  operator= (const Break& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DMXOffset_ = x.DMXOffset_;
      this->DMXBreak_ = x.DMXBreak_;
    }

    return *this;
  }

  Break::
  ~Break ()
  {
  }

  // DMXModes
  //

  DMXModes::
  DMXModes ()
  : ::xml_schema::type (),
    DMXMode_ (this)
  {
  }

  DMXModes::
  DMXModes (const DMXModes& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DMXMode_ (x.DMXMode_, f, this)
  {
  }

  DMXModes::
  DMXModes (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DMXMode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DMXModes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DMXMode
      //
      if (n.name () == "DMXMode" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< DMXMode_type > r (
          DMXMode_traits::create (i, f, this));

        this->DMXMode_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DMXModes* DMXModes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DMXModes (*this, f, c);
  }

  DMXModes& DMXModes::
  operator= (const DMXModes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DMXMode_ = x.DMXMode_;
    }

    return *this;
  }

  DMXModes::
  ~DMXModes ()
  {
  }

  // DMXMode
  //

  DMXMode::
  DMXMode (const Name_type& Name)
  : ::xml_schema::type (),
    DMXChannels_ (this),
    Relations_ (this),
    FTMacros_ (this),
    Name_ (Name, this),
    Geometry_ (this)
  {
  }

  DMXMode::
  DMXMode (const DMXMode& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DMXChannels_ (x.DMXChannels_, f, this),
    Relations_ (x.Relations_, f, this),
    FTMacros_ (x.FTMacros_, f, this),
    Name_ (x.Name_, f, this),
    Geometry_ (x.Geometry_, f, this)
  {
  }

  DMXMode::
  DMXMode (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DMXChannels_ (this),
    Relations_ (this),
    FTMacros_ (this),
    Name_ (this),
    Geometry_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DMXMode::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DMXChannels
      //
      if (n.name () == "DMXChannels" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< DMXChannels_type > r (
          DMXChannels_traits::create (i, f, this));

        this->DMXChannels_.push_back (::std::move (r));
        continue;
      }

      // Relations
      //
      if (n.name () == "Relations" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Relations_type > r (
          Relations_traits::create (i, f, this));

        this->Relations_.push_back (::std::move (r));
        continue;
      }

      // FTMacros
      //
      if (n.name () == "FTMacros" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FTMacros_type > r (
          FTMacros_traits::create (i, f, this));

        this->FTMacros_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Geometry" && n.namespace_ ().empty ())
      {
        this->Geometry_.set (Geometry_traits::create (i, f, this));
        continue;
      }
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Name",
        "");
    }
  }

  DMXMode* DMXMode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DMXMode (*this, f, c);
  }

  DMXMode& DMXMode::
  operator= (const DMXMode& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DMXChannels_ = x.DMXChannels_;
      this->Relations_ = x.Relations_;
      this->FTMacros_ = x.FTMacros_;
      this->Name_ = x.Name_;
      this->Geometry_ = x.Geometry_;
    }

    return *this;
  }

  DMXMode::
  ~DMXMode ()
  {
  }

  // DMXChannels
  //

  DMXChannels::
  DMXChannels ()
  : ::xml_schema::type (),
    DMXChannel_ (this)
  {
  }

  DMXChannels::
  DMXChannels (const DMXChannels& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DMXChannel_ (x.DMXChannel_, f, this)
  {
  }

  DMXChannels::
  DMXChannels (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DMXChannel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DMXChannels::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DMXChannel
      //
      if (n.name () == "DMXChannel" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< DMXChannel_type > r (
          DMXChannel_traits::create (i, f, this));

        this->DMXChannel_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DMXChannels* DMXChannels::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DMXChannels (*this, f, c);
  }

  DMXChannels& DMXChannels::
  operator= (const DMXChannels& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DMXChannel_ = x.DMXChannel_;
    }

    return *this;
  }

  DMXChannels::
  ~DMXChannels ()
  {
  }

  // DMXChannel
  //

  DMXChannel::
  DMXChannel (const LogicalChannel_type& LogicalChannel)
  : ::xml_schema::type (),
    LogicalChannel_ (LogicalChannel, this),
    Name_ (this),
    DMXBreak_ (this),
    Offset_ (this),
    Default_ (this),
    Highlight_ (this),
    Geometry_ (this)
  {
  }

  DMXChannel::
  DMXChannel (::std::unique_ptr< LogicalChannel_type > LogicalChannel)
  : ::xml_schema::type (),
    LogicalChannel_ (std::move (LogicalChannel), this),
    Name_ (this),
    DMXBreak_ (this),
    Offset_ (this),
    Default_ (this),
    Highlight_ (this),
    Geometry_ (this)
  {
  }

  DMXChannel::
  DMXChannel (const DMXChannel& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    LogicalChannel_ (x.LogicalChannel_, f, this),
    Name_ (x.Name_, f, this),
    DMXBreak_ (x.DMXBreak_, f, this),
    Offset_ (x.Offset_, f, this),
    Default_ (x.Default_, f, this),
    Highlight_ (x.Highlight_, f, this),
    Geometry_ (x.Geometry_, f, this)
  {
  }

  DMXChannel::
  DMXChannel (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    LogicalChannel_ (this),
    Name_ (this),
    DMXBreak_ (this),
    Offset_ (this),
    Default_ (this),
    Highlight_ (this),
    Geometry_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DMXChannel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LogicalChannel
      //
      if (n.name () == "LogicalChannel" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< LogicalChannel_type > r (
          LogicalChannel_traits::create (i, f, this));

        if (!LogicalChannel_.present ())
        {
          this->LogicalChannel_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!LogicalChannel_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LogicalChannel",
        "http://schemas.gdtf-share.com/device");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DMXBreak" && n.namespace_ ().empty ())
      {
        this->DMXBreak_.set (DMXBreak_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Offset" && n.namespace_ ().empty ())
      {
        this->Offset_.set (Offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Default" && n.namespace_ ().empty ())
      {
        this->Default_.set (Default_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Highlight" && n.namespace_ ().empty ())
      {
        this->Highlight_.set (Highlight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Geometry" && n.namespace_ ().empty ())
      {
        this->Geometry_.set (Geometry_traits::create (i, f, this));
        continue;
      }
    }
  }

  DMXChannel* DMXChannel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DMXChannel (*this, f, c);
  }

  DMXChannel& DMXChannel::
  operator= (const DMXChannel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->LogicalChannel_ = x.LogicalChannel_;
      this->Name_ = x.Name_;
      this->DMXBreak_ = x.DMXBreak_;
      this->Offset_ = x.Offset_;
      this->Default_ = x.Default_;
      this->Highlight_ = x.Highlight_;
      this->Geometry_ = x.Geometry_;
    }

    return *this;
  }

  DMXChannel::
  ~DMXChannel ()
  {
  }

  // LogicalChannel
  //

  LogicalChannel::
  LogicalChannel (const Attribute_type& Attribute)
  : ::xml_schema::type (),
    ChannelFunction_ (this),
    Name_ (this),
    Attribute_ (Attribute, this),
    Snap_ (this),
    Master_ (this),
    MibFade_ (this),
    DMXChangeTimeLimit_ (this)
  {
  }

  LogicalChannel::
  LogicalChannel (const LogicalChannel& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ChannelFunction_ (x.ChannelFunction_, f, this),
    Name_ (x.Name_, f, this),
    Attribute_ (x.Attribute_, f, this),
    Snap_ (x.Snap_, f, this),
    Master_ (x.Master_, f, this),
    MibFade_ (x.MibFade_, f, this),
    DMXChangeTimeLimit_ (x.DMXChangeTimeLimit_, f, this)
  {
  }

  LogicalChannel::
  LogicalChannel (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ChannelFunction_ (this),
    Name_ (this),
    Attribute_ (this),
    Snap_ (this),
    Master_ (this),
    MibFade_ (this),
    DMXChangeTimeLimit_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LogicalChannel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ChannelFunction
      //
      if (n.name () == "ChannelFunction" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< ChannelFunction_type > r (
          ChannelFunction_traits::create (i, f, this));

        this->ChannelFunction_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Attribute" && n.namespace_ ().empty ())
      {
        this->Attribute_.set (Attribute_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Snap" && n.namespace_ ().empty ())
      {
        this->Snap_.set (Snap_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Master" && n.namespace_ ().empty ())
      {
        this->Master_.set (Master_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "MibFade" && n.namespace_ ().empty ())
      {
        this->MibFade_.set (MibFade_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DMXChangeTimeLimit" && n.namespace_ ().empty ())
      {
        this->DMXChangeTimeLimit_.set (DMXChangeTimeLimit_traits::create (i, f, this));
        continue;
      }
    }

    if (!Attribute_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Attribute",
        "");
    }
  }

  LogicalChannel* LogicalChannel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LogicalChannel (*this, f, c);
  }

  LogicalChannel& LogicalChannel::
  operator= (const LogicalChannel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ChannelFunction_ = x.ChannelFunction_;
      this->Name_ = x.Name_;
      this->Attribute_ = x.Attribute_;
      this->Snap_ = x.Snap_;
      this->Master_ = x.Master_;
      this->MibFade_ = x.MibFade_;
      this->DMXChangeTimeLimit_ = x.DMXChangeTimeLimit_;
    }

    return *this;
  }

  LogicalChannel::
  ~LogicalChannel ()
  {
  }

  // ChannelFunction
  //

  const ChannelFunction::ModeFrom_type ChannelFunction::ModeFrom_default_value_ (
    "0/1");

  ChannelFunction::
  ChannelFunction (const Attribute_type& Attribute)
  : ::xml_schema::type (),
    ChannelSet_ (this),
    Name_ (this),
    Attribute_ (Attribute, this),
    OriginalAttribute_ (this),
    DMXFrom_ (this),
    PhysicalFrom_ (this),
    PhysicalTo_ (this),
    RealFade_ (this),
    Wheel_ (this),
    Emitter_ (this),
    Filter_ (this),
    ModeMaster_ (this),
    ModeFrom_ (ModeFrom_default_value (), this),
    ModeTo_ (this)
  {
  }

  ChannelFunction::
  ChannelFunction (const ChannelFunction& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ChannelSet_ (x.ChannelSet_, f, this),
    Name_ (x.Name_, f, this),
    Attribute_ (x.Attribute_, f, this),
    OriginalAttribute_ (x.OriginalAttribute_, f, this),
    DMXFrom_ (x.DMXFrom_, f, this),
    PhysicalFrom_ (x.PhysicalFrom_, f, this),
    PhysicalTo_ (x.PhysicalTo_, f, this),
    RealFade_ (x.RealFade_, f, this),
    Wheel_ (x.Wheel_, f, this),
    Emitter_ (x.Emitter_, f, this),
    Filter_ (x.Filter_, f, this),
    ModeMaster_ (x.ModeMaster_, f, this),
    ModeFrom_ (x.ModeFrom_, f, this),
    ModeTo_ (x.ModeTo_, f, this)
  {
  }

  ChannelFunction::
  ChannelFunction (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ChannelSet_ (this),
    Name_ (this),
    Attribute_ (this),
    OriginalAttribute_ (this),
    DMXFrom_ (this),
    PhysicalFrom_ (this),
    PhysicalTo_ (this),
    RealFade_ (this),
    Wheel_ (this),
    Emitter_ (this),
    Filter_ (this),
    ModeMaster_ (this),
    ModeFrom_ (this),
    ModeTo_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelFunction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ChannelSet
      //
      if (n.name () == "ChannelSet" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< ChannelSet_type > r (
          ChannelSet_traits::create (i, f, this));

        this->ChannelSet_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Attribute" && n.namespace_ ().empty ())
      {
        this->Attribute_.set (Attribute_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OriginalAttribute" && n.namespace_ ().empty ())
      {
        this->OriginalAttribute_.set (OriginalAttribute_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DMXFrom" && n.namespace_ ().empty ())
      {
        this->DMXFrom_.set (DMXFrom_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "PhysicalFrom" && n.namespace_ ().empty ())
      {
        this->PhysicalFrom_.set (PhysicalFrom_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "PhysicalTo" && n.namespace_ ().empty ())
      {
        this->PhysicalTo_.set (PhysicalTo_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "RealFade" && n.namespace_ ().empty ())
      {
        this->RealFade_.set (RealFade_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Wheel" && n.namespace_ ().empty ())
      {
        this->Wheel_.set (Wheel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Emitter" && n.namespace_ ().empty ())
      {
        this->Emitter_.set (Emitter_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Filter" && n.namespace_ ().empty ())
      {
        this->Filter_.set (Filter_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ModeMaster" && n.namespace_ ().empty ())
      {
        this->ModeMaster_.set (ModeMaster_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ModeFrom" && n.namespace_ ().empty ())
      {
        this->ModeFrom_.set (ModeFrom_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ModeTo" && n.namespace_ ().empty ())
      {
        this->ModeTo_.set (ModeTo_traits::create (i, f, this));
        continue;
      }
    }

    if (!Attribute_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Attribute",
        "");
    }

    if (!ModeFrom_.present ())
    {
      this->ModeFrom_.set (ModeFrom_default_value ());
    }
  }

  ChannelFunction* ChannelFunction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelFunction (*this, f, c);
  }

  ChannelFunction& ChannelFunction::
  operator= (const ChannelFunction& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ChannelSet_ = x.ChannelSet_;
      this->Name_ = x.Name_;
      this->Attribute_ = x.Attribute_;
      this->OriginalAttribute_ = x.OriginalAttribute_;
      this->DMXFrom_ = x.DMXFrom_;
      this->PhysicalFrom_ = x.PhysicalFrom_;
      this->PhysicalTo_ = x.PhysicalTo_;
      this->RealFade_ = x.RealFade_;
      this->Wheel_ = x.Wheel_;
      this->Emitter_ = x.Emitter_;
      this->Filter_ = x.Filter_;
      this->ModeMaster_ = x.ModeMaster_;
      this->ModeFrom_ = x.ModeFrom_;
      this->ModeTo_ = x.ModeTo_;
    }

    return *this;
  }

  ChannelFunction::
  ~ChannelFunction ()
  {
  }

  // ChannelSet
  //

  ChannelSet::
  ChannelSet ()
  : ::xml_schema::type (),
    Name_ (this),
    DMXFrom_ (this),
    DMXTo_ (this),
    PhysicalFrom_ (this),
    PhysicalTo_ (this),
    WheelSlotIndex_ (this)
  {
  }

  ChannelSet::
  ChannelSet (const ChannelSet& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Name_ (x.Name_, f, this),
    DMXFrom_ (x.DMXFrom_, f, this),
    DMXTo_ (x.DMXTo_, f, this),
    PhysicalFrom_ (x.PhysicalFrom_, f, this),
    PhysicalTo_ (x.PhysicalTo_, f, this),
    WheelSlotIndex_ (x.WheelSlotIndex_, f, this)
  {
  }

  ChannelSet::
  ChannelSet (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Name_ (this),
    DMXFrom_ (this),
    DMXTo_ (this),
    PhysicalFrom_ (this),
    PhysicalTo_ (this),
    WheelSlotIndex_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ChannelSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DMXFrom" && n.namespace_ ().empty ())
      {
        this->DMXFrom_.set (DMXFrom_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DMXTo" && n.namespace_ ().empty ())
      {
        this->DMXTo_.set (DMXTo_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "PhysicalFrom" && n.namespace_ ().empty ())
      {
        this->PhysicalFrom_.set (PhysicalFrom_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "PhysicalTo" && n.namespace_ ().empty ())
      {
        this->PhysicalTo_.set (PhysicalTo_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "WheelSlotIndex" && n.namespace_ ().empty ())
      {
        this->WheelSlotIndex_.set (WheelSlotIndex_traits::create (i, f, this));
        continue;
      }
    }
  }

  ChannelSet* ChannelSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelSet (*this, f, c);
  }

  ChannelSet& ChannelSet::
  operator= (const ChannelSet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Name_ = x.Name_;
      this->DMXFrom_ = x.DMXFrom_;
      this->DMXTo_ = x.DMXTo_;
      this->PhysicalFrom_ = x.PhysicalFrom_;
      this->PhysicalTo_ = x.PhysicalTo_;
      this->WheelSlotIndex_ = x.WheelSlotIndex_;
    }

    return *this;
  }

  ChannelSet::
  ~ChannelSet ()
  {
  }

  // Relations
  //

  Relations::
  Relations ()
  : ::xml_schema::type (),
    Relation_ (this)
  {
  }

  Relations::
  Relations (const Relations& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Relation_ (x.Relation_, f, this)
  {
  }

  Relations::
  Relations (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Relation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Relations::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Relation
      //
      if (n.name () == "Relation" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Relation_type > r (
          Relation_traits::create (i, f, this));

        this->Relation_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Relations* Relations::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Relations (*this, f, c);
  }

  Relations& Relations::
  operator= (const Relations& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Relation_ = x.Relation_;
    }

    return *this;
  }

  Relations::
  ~Relations ()
  {
  }

  // Relation
  //

  Relation::
  Relation (const Name_type& Name,
            const Master_type& Master,
            const Follower_type& Follower,
            const Type_type& Type)
  : ::xml_schema::type (),
    Name_ (Name, this),
    Master_ (Master, this),
    Follower_ (Follower, this),
    Type_ (Type, this)
  {
  }

  Relation::
  Relation (const Relation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Name_ (x.Name_, f, this),
    Master_ (x.Master_, f, this),
    Follower_ (x.Follower_, f, this),
    Type_ (x.Type_, f, this)
  {
  }

  Relation::
  Relation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Name_ (this),
    Master_ (this),
    Follower_ (this),
    Type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Relation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Master" && n.namespace_ ().empty ())
      {
        this->Master_.set (Master_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Follower" && n.namespace_ ().empty ())
      {
        this->Follower_.set (Follower_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Type" && n.namespace_ ().empty ())
      {
        this->Type_.set (Type_traits::create (i, f, this));
        continue;
      }
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Name",
        "");
    }

    if (!Master_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Master",
        "");
    }

    if (!Follower_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Follower",
        "");
    }

    if (!Type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Type",
        "");
    }
  }

  Relation* Relation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Relation (*this, f, c);
  }

  Relation& Relation::
  operator= (const Relation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Name_ = x.Name_;
      this->Master_ = x.Master_;
      this->Follower_ = x.Follower_;
      this->Type_ = x.Type_;
    }

    return *this;
  }

  Relation::
  ~Relation ()
  {
  }

  // Revisions
  //

  Revisions::
  Revisions ()
  : ::xml_schema::type (),
    Revision_ (this)
  {
  }

  Revisions::
  Revisions (const Revisions& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Revision_ (x.Revision_, f, this)
  {
  }

  Revisions::
  Revisions (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Revision_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Revisions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Revision
      //
      if (n.name () == "Revision" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Revision_type > r (
          Revision_traits::create (i, f, this));

        this->Revision_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Revisions* Revisions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Revisions (*this, f, c);
  }

  Revisions& Revisions::
  operator= (const Revisions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Revision_ = x.Revision_;
    }

    return *this;
  }

  Revisions::
  ~Revisions ()
  {
  }

  // Revision
  //

  Revision::
  Revision ()
  : ::xml_schema::type (),
    Text_ (this),
    Date_ (this),
    UserID_ (this)
  {
  }

  Revision::
  Revision (const Revision& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Text_ (x.Text_, f, this),
    Date_ (x.Date_, f, this),
    UserID_ (x.UserID_, f, this)
  {
  }

  Revision::
  Revision (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Text_ (this),
    Date_ (this),
    UserID_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Revision::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Text" && n.namespace_ ().empty ())
      {
        this->Text_.set (Text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Date" && n.namespace_ ().empty ())
      {
        this->Date_.set (Date_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "UserID" && n.namespace_ ().empty ())
      {
        this->UserID_.set (UserID_traits::create (i, f, this));
        continue;
      }
    }
  }

  Revision* Revision::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Revision (*this, f, c);
  }

  Revision& Revision::
  operator= (const Revision& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Text_ = x.Text_;
      this->Date_ = x.Date_;
      this->UserID_ = x.UserID_;
    }

    return *this;
  }

  Revision::
  ~Revision ()
  {
  }

  // FTPresets
  //

  FTPresets::
  FTPresets ()
  : ::xml_schema::type (),
    FTPreset_ (this)
  {
  }

  FTPresets::
  FTPresets (const FTPresets& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FTPreset_ (x.FTPreset_, f, this)
  {
  }

  FTPresets::
  FTPresets (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FTPreset_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FTPresets::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FTPreset
      //
      if (n.name () == "FTPreset" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FTPreset_type > r (
          FTPreset_traits::create (i, f, this));

        this->FTPreset_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  FTPresets* FTPresets::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FTPresets (*this, f, c);
  }

  FTPresets& FTPresets::
  operator= (const FTPresets& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FTPreset_ = x.FTPreset_;
    }

    return *this;
  }

  FTPresets::
  ~FTPresets ()
  {
  }

  // FTPreset
  //

  FTPreset::
  FTPreset ()
  : ::xml_schema::type ()
  {
  }

  FTPreset::
  FTPreset (const FTPreset& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  FTPreset::
  FTPreset (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  FTPreset::
  FTPreset (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  FTPreset::
  FTPreset (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  FTPreset* FTPreset::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FTPreset (*this, f, c);
  }

  FTPreset::
  ~FTPreset ()
  {
  }

  // FTMacros
  //

  FTMacros::
  FTMacros ()
  : ::xml_schema::type (),
    FTMacro_ (this)
  {
  }

  FTMacros::
  FTMacros (const FTMacros& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FTMacro_ (x.FTMacro_, f, this)
  {
  }

  FTMacros::
  FTMacros (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FTMacro_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FTMacros::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FTMacro
      //
      if (n.name () == "FTMacro" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FTMacro_type > r (
          FTMacro_traits::create (i, f, this));

        this->FTMacro_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  FTMacros* FTMacros::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FTMacros (*this, f, c);
  }

  FTMacros& FTMacros::
  operator= (const FTMacros& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FTMacro_ = x.FTMacro_;
    }

    return *this;
  }

  FTMacros::
  ~FTMacros ()
  {
  }

  // FTMacro
  //

  FTMacro::
  FTMacro ()
  : ::xml_schema::type (),
    MacroDMX_ (this),
    MacroVisual_ (this),
    Name_ (this)
  {
  }

  FTMacro::
  FTMacro (const FTMacro& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    MacroDMX_ (x.MacroDMX_, f, this),
    MacroVisual_ (x.MacroVisual_, f, this),
    Name_ (x.Name_, f, this)
  {
  }

  FTMacro::
  FTMacro (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MacroDMX_ (this),
    MacroVisual_ (this),
    Name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FTMacro::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MacroDMX
      //
      if (n.name () == "MacroDMX" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< MacroDMX_type > r (
          MacroDMX_traits::create (i, f, this));

        this->MacroDMX_.push_back (::std::move (r));
        continue;
      }

      // MacroVisual
      //
      if (n.name () == "MacroVisual" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< MacroVisual_type > r (
          MacroVisual_traits::create (i, f, this));

        this->MacroVisual_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }
    }
  }

  FTMacro* FTMacro::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FTMacro (*this, f, c);
  }

  FTMacro& FTMacro::
  operator= (const FTMacro& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->MacroDMX_ = x.MacroDMX_;
      this->MacroVisual_ = x.MacroVisual_;
      this->Name_ = x.Name_;
    }

    return *this;
  }

  FTMacro::
  ~FTMacro ()
  {
  }

  // MacroDMX
  //

  MacroDMX::
  MacroDMX ()
  : ::xml_schema::type (),
    DMXStep_ (this)
  {
  }

  MacroDMX::
  MacroDMX (const MacroDMX& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DMXStep_ (x.DMXStep_, f, this)
  {
  }

  MacroDMX::
  MacroDMX (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DMXStep_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MacroDMX::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DMXStep
      //
      if (n.name () == "DMXStep" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< DMXStep_type > r (
          DMXStep_traits::create (i, f, this));

        this->DMXStep_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  MacroDMX* MacroDMX::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MacroDMX (*this, f, c);
  }

  MacroDMX& MacroDMX::
  operator= (const MacroDMX& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DMXStep_ = x.DMXStep_;
    }

    return *this;
  }

  MacroDMX::
  ~MacroDMX ()
  {
  }

  // DMXStep
  //

  DMXStep::
  DMXStep ()
  : ::xml_schema::type (),
    DMXValue_ (this),
    Duration_ (this)
  {
  }

  DMXStep::
  DMXStep (const DMXStep& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DMXValue_ (x.DMXValue_, f, this),
    Duration_ (x.Duration_, f, this)
  {
  }

  DMXStep::
  DMXStep (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DMXValue_ (this),
    Duration_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DMXStep::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DMXValue
      //
      if (n.name () == "DMXValue" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< DMXValue_type > r (
          DMXValue_traits::create (i, f, this));

        this->DMXValue_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Duration" && n.namespace_ ().empty ())
      {
        this->Duration_.set (Duration_traits::create (i, f, this));
        continue;
      }
    }
  }

  DMXStep* DMXStep::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DMXStep (*this, f, c);
  }

  DMXStep& DMXStep::
  operator= (const DMXStep& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DMXValue_ = x.DMXValue_;
      this->Duration_ = x.Duration_;
    }

    return *this;
  }

  DMXStep::
  ~DMXStep ()
  {
  }

  // DMXValue
  //

  DMXValue::
  DMXValue ()
  : ::xml_schema::type (),
    Value_ (this),
    DMXChannel_ (this)
  {
  }

  DMXValue::
  DMXValue (const DMXValue& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Value_ (x.Value_, f, this),
    DMXChannel_ (x.DMXChannel_, f, this)
  {
  }

  DMXValue::
  DMXValue (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Value_ (this),
    DMXChannel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DMXValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Value" && n.namespace_ ().empty ())
      {
        this->Value_.set (Value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DMXChannel" && n.namespace_ ().empty ())
      {
        this->DMXChannel_.set (DMXChannel_traits::create (i, f, this));
        continue;
      }
    }
  }

  DMXValue* DMXValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DMXValue (*this, f, c);
  }

  DMXValue& DMXValue::
  operator= (const DMXValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Value_ = x.Value_;
      this->DMXChannel_ = x.DMXChannel_;
    }

    return *this;
  }

  DMXValue::
  ~DMXValue ()
  {
  }

  // MacroVisual
  //

  MacroVisual::
  MacroVisual ()
  : ::xml_schema::type (),
    VisualStep_ (this)
  {
  }

  MacroVisual::
  MacroVisual (const MacroVisual& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    VisualStep_ (x.VisualStep_, f, this)
  {
  }

  MacroVisual::
  MacroVisual (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    VisualStep_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MacroVisual::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // VisualStep
      //
      if (n.name () == "VisualStep" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< VisualStep_type > r (
          VisualStep_traits::create (i, f, this));

        this->VisualStep_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  MacroVisual* MacroVisual::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MacroVisual (*this, f, c);
  }

  MacroVisual& MacroVisual::
  operator= (const MacroVisual& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->VisualStep_ = x.VisualStep_;
    }

    return *this;
  }

  MacroVisual::
  ~MacroVisual ()
  {
  }

  // VisualStep
  //

  VisualStep::
  VisualStep ()
  : ::xml_schema::type (),
    VisualValue_ (this),
    Duration_ (this),
    Fade_ (this),
    Delay_ (this)
  {
  }

  VisualStep::
  VisualStep (const VisualStep& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    VisualValue_ (x.VisualValue_, f, this),
    Duration_ (x.Duration_, f, this),
    Fade_ (x.Fade_, f, this),
    Delay_ (x.Delay_, f, this)
  {
  }

  VisualStep::
  VisualStep (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    VisualValue_ (this),
    Duration_ (this),
    Fade_ (this),
    Delay_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VisualStep::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // VisualValue
      //
      if (n.name () == "VisualValue" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< VisualValue_type > r (
          VisualValue_traits::create (i, f, this));

        this->VisualValue_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Duration" && n.namespace_ ().empty ())
      {
        this->Duration_.set (Duration_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Fade" && n.namespace_ ().empty ())
      {
        this->Fade_.set (Fade_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Delay" && n.namespace_ ().empty ())
      {
        this->Delay_.set (Delay_traits::create (i, f, this));
        continue;
      }
    }
  }

  VisualStep* VisualStep::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VisualStep (*this, f, c);
  }

  VisualStep& VisualStep::
  operator= (const VisualStep& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->VisualValue_ = x.VisualValue_;
      this->Duration_ = x.Duration_;
      this->Fade_ = x.Fade_;
      this->Delay_ = x.Delay_;
    }

    return *this;
  }

  VisualStep::
  ~VisualStep ()
  {
  }

  // VisualValue
  //

  VisualValue::
  VisualValue ()
  : ::xml_schema::type (),
    Value_ (this),
    ChannelFunction_ (this)
  {
  }

  VisualValue::
  VisualValue (const VisualValue& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Value_ (x.Value_, f, this),
    ChannelFunction_ (x.ChannelFunction_, f, this)
  {
  }

  VisualValue::
  VisualValue (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Value_ (this),
    ChannelFunction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void VisualValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Value" && n.namespace_ ().empty ())
      {
        this->Value_.set (Value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ChannelFunction" && n.namespace_ ().empty ())
      {
        this->ChannelFunction_.set (ChannelFunction_traits::create (i, f, this));
        continue;
      }
    }
  }

  VisualValue* VisualValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class VisualValue (*this, f, c);
  }

  VisualValue& VisualValue::
  operator= (const VisualValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Value_ = x.Value_;
      this->ChannelFunction_ = x.ChannelFunction_;
    }

    return *this;
  }

  VisualValue::
  ~VisualValue ()
  {
  }

  // PhysicalDescriptions
  //

  PhysicalDescriptions::
  PhysicalDescriptions ()
  : ::xml_schema::type (),
    Emitters_ (this),
    Filters_ (this),
    ColorSpace_ (this),
    DMXProfiles_ (this),
    CRIs_ (this)
  {
  }

  PhysicalDescriptions::
  PhysicalDescriptions (const PhysicalDescriptions& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Emitters_ (x.Emitters_, f, this),
    Filters_ (x.Filters_, f, this),
    ColorSpace_ (x.ColorSpace_, f, this),
    DMXProfiles_ (x.DMXProfiles_, f, this),
    CRIs_ (x.CRIs_, f, this)
  {
  }

  PhysicalDescriptions::
  PhysicalDescriptions (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Emitters_ (this),
    Filters_ (this),
    ColorSpace_ (this),
    DMXProfiles_ (this),
    CRIs_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PhysicalDescriptions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Emitters
      //
      if (n.name () == "Emitters" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Emitters_type > r (
          Emitters_traits::create (i, f, this));

        this->Emitters_.push_back (::std::move (r));
        continue;
      }

      // Filters
      //
      if (n.name () == "Filters" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Filters_type > r (
          Filters_traits::create (i, f, this));

        this->Filters_.push_back (::std::move (r));
        continue;
      }

      // ColorSpace
      //
      if (n.name () == "ColorSpace" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< ColorSpace_type > r (
          ColorSpace_traits::create (i, f, this));

        this->ColorSpace_.push_back (::std::move (r));
        continue;
      }

      // DMXProfiles
      //
      if (n.name () == "DMXProfiles" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< DMXProfiles_type > r (
          DMXProfiles_traits::create (i, f, this));

        this->DMXProfiles_.push_back (::std::move (r));
        continue;
      }

      // CRIs
      //
      if (n.name () == "CRIs" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< CRIs_type > r (
          CRIs_traits::create (i, f, this));

        this->CRIs_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  PhysicalDescriptions* PhysicalDescriptions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PhysicalDescriptions (*this, f, c);
  }

  PhysicalDescriptions& PhysicalDescriptions::
  operator= (const PhysicalDescriptions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Emitters_ = x.Emitters_;
      this->Filters_ = x.Filters_;
      this->ColorSpace_ = x.ColorSpace_;
      this->DMXProfiles_ = x.DMXProfiles_;
      this->CRIs_ = x.CRIs_;
    }

    return *this;
  }

  PhysicalDescriptions::
  ~PhysicalDescriptions ()
  {
  }

  // Emitters
  //

  Emitters::
  Emitters ()
  : ::xml_schema::type (),
    Emitter_ (this)
  {
  }

  Emitters::
  Emitters (const Emitters& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Emitter_ (x.Emitter_, f, this)
  {
  }

  Emitters::
  Emitters (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Emitter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Emitters::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Emitter
      //
      if (n.name () == "Emitter" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Emitter_type > r (
          Emitter_traits::create (i, f, this));

        this->Emitter_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Emitters* Emitters::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Emitters (*this, f, c);
  }

  Emitters& Emitters::
  operator= (const Emitters& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Emitter_ = x.Emitter_;
    }

    return *this;
  }

  Emitters::
  ~Emitters ()
  {
  }

  // Emitter
  //

  Emitter::
  Emitter ()
  : ::xml_schema::type (),
    Measurement_ (this),
    Name_ (this),
    Color_ (this),
    DominantWaveLength_ (this),
    DiodePart_ (this)
  {
  }

  Emitter::
  Emitter (const Emitter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Measurement_ (x.Measurement_, f, this),
    Name_ (x.Name_, f, this),
    Color_ (x.Color_, f, this),
    DominantWaveLength_ (x.DominantWaveLength_, f, this),
    DiodePart_ (x.DiodePart_, f, this)
  {
  }

  Emitter::
  Emitter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Measurement_ (this),
    Name_ (this),
    Color_ (this),
    DominantWaveLength_ (this),
    DiodePart_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Emitter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Measurement
      //
      if (n.name () == "Measurement" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Measurement_type > r (
          Measurement_traits::create (i, f, this));

        this->Measurement_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Color" && n.namespace_ ().empty ())
      {
        this->Color_.set (Color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DominantWaveLength" && n.namespace_ ().empty ())
      {
        this->DominantWaveLength_.set (DominantWaveLength_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DiodePart" && n.namespace_ ().empty ())
      {
        this->DiodePart_.set (DiodePart_traits::create (i, f, this));
        continue;
      }
    }
  }

  Emitter* Emitter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Emitter (*this, f, c);
  }

  Emitter& Emitter::
  operator= (const Emitter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Measurement_ = x.Measurement_;
      this->Name_ = x.Name_;
      this->Color_ = x.Color_;
      this->DominantWaveLength_ = x.DominantWaveLength_;
      this->DiodePart_ = x.DiodePart_;
    }

    return *this;
  }

  Emitter::
  ~Emitter ()
  {
  }

  // Filters
  //

  Filters::
  Filters ()
  : ::xml_schema::type (),
    Filter_ (this)
  {
  }

  Filters::
  Filters (const Filters& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Filter_ (x.Filter_, f, this)
  {
  }

  Filters::
  Filters (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Filter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Filters::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Filter
      //
      if (n.name () == "Filter" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Filter_type > r (
          Filter_traits::create (i, f, this));

        this->Filter_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Filters* Filters::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Filters (*this, f, c);
  }

  Filters& Filters::
  operator= (const Filters& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Filter_ = x.Filter_;
    }

    return *this;
  }

  Filters::
  ~Filters ()
  {
  }

  // Filter
  //

  Filter::
  Filter ()
  : ::xml_schema::type (),
    Measurement_ (this),
    Name_ (this),
    Color_ (this)
  {
  }

  Filter::
  Filter (const Filter& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Measurement_ (x.Measurement_, f, this),
    Name_ (x.Name_, f, this),
    Color_ (x.Color_, f, this)
  {
  }

  Filter::
  Filter (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Measurement_ (this),
    Name_ (this),
    Color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Filter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Measurement
      //
      if (n.name () == "Measurement" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Measurement_type > r (
          Measurement_traits::create (i, f, this));

        this->Measurement_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Color" && n.namespace_ ().empty ())
      {
        this->Color_.set (Color_traits::create (i, f, this));
        continue;
      }
    }
  }

  Filter* Filter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Filter (*this, f, c);
  }

  Filter& Filter::
  operator= (const Filter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Measurement_ = x.Measurement_;
      this->Name_ = x.Name_;
      this->Color_ = x.Color_;
    }

    return *this;
  }

  Filter::
  ~Filter ()
  {
  }

  // Measurement
  //

  Measurement::
  Measurement ()
  : ::xml_schema::type (),
    MeasurementPoint_ (this),
    Physical_ (this),
    LuminousIntensity_ (this),
    Transmission_ (this),
    InterpolationTo_ (this)
  {
  }

  Measurement::
  Measurement (const Measurement& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    MeasurementPoint_ (x.MeasurementPoint_, f, this),
    Physical_ (x.Physical_, f, this),
    LuminousIntensity_ (x.LuminousIntensity_, f, this),
    Transmission_ (x.Transmission_, f, this),
    InterpolationTo_ (x.InterpolationTo_, f, this)
  {
  }

  Measurement::
  Measurement (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    MeasurementPoint_ (this),
    Physical_ (this),
    LuminousIntensity_ (this),
    Transmission_ (this),
    InterpolationTo_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Measurement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MeasurementPoint
      //
      if (n.name () == "MeasurementPoint" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< MeasurementPoint_type > r (
          MeasurementPoint_traits::create (i, f, this));

        this->MeasurementPoint_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Physical" && n.namespace_ ().empty ())
      {
        this->Physical_.set (Physical_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "LuminousIntensity" && n.namespace_ ().empty ())
      {
        this->LuminousIntensity_.set (LuminousIntensity_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Transmission" && n.namespace_ ().empty ())
      {
        this->Transmission_.set (Transmission_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "InterpolationTo" && n.namespace_ ().empty ())
      {
        this->InterpolationTo_.set (InterpolationTo_traits::create (i, f, this));
        continue;
      }
    }
  }

  Measurement* Measurement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Measurement (*this, f, c);
  }

  Measurement& Measurement::
  operator= (const Measurement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->MeasurementPoint_ = x.MeasurementPoint_;
      this->Physical_ = x.Physical_;
      this->LuminousIntensity_ = x.LuminousIntensity_;
      this->Transmission_ = x.Transmission_;
      this->InterpolationTo_ = x.InterpolationTo_;
    }

    return *this;
  }

  Measurement::
  ~Measurement ()
  {
  }

  // MeasurementPoint
  //

  MeasurementPoint::
  MeasurementPoint ()
  : ::xml_schema::type (),
    WaveLength_ (this),
    Energy_ (this)
  {
  }

  MeasurementPoint::
  MeasurementPoint (const MeasurementPoint& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    WaveLength_ (x.WaveLength_, f, this),
    Energy_ (x.Energy_, f, this)
  {
  }

  MeasurementPoint::
  MeasurementPoint (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    WaveLength_ (this),
    Energy_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void MeasurementPoint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "WaveLength" && n.namespace_ ().empty ())
      {
        this->WaveLength_.set (WaveLength_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Energy" && n.namespace_ ().empty ())
      {
        this->Energy_.set (Energy_traits::create (i, f, this));
        continue;
      }
    }
  }

  MeasurementPoint* MeasurementPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MeasurementPoint (*this, f, c);
  }

  MeasurementPoint& MeasurementPoint::
  operator= (const MeasurementPoint& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->WaveLength_ = x.WaveLength_;
      this->Energy_ = x.Energy_;
    }

    return *this;
  }

  MeasurementPoint::
  ~MeasurementPoint ()
  {
  }

  // ColorSpace
  //

  ColorSpace::
  ColorSpace ()
  : ::xml_schema::type (),
    ColorSpace1_ (this),
    Red_ (this),
    Green_ (this),
    Blue_ (this),
    WhitePoint_ (this)
  {
  }

  ColorSpace::
  ColorSpace (const ColorSpace& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ColorSpace1_ (x.ColorSpace1_, f, this),
    Red_ (x.Red_, f, this),
    Green_ (x.Green_, f, this),
    Blue_ (x.Blue_, f, this),
    WhitePoint_ (x.WhitePoint_, f, this)
  {
  }

  ColorSpace::
  ColorSpace (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ColorSpace1_ (this),
    Red_ (this),
    Green_ (this),
    Blue_ (this),
    WhitePoint_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ColorSpace::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ColorSpace" && n.namespace_ ().empty ())
      {
        this->ColorSpace1_.set (ColorSpace1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Red" && n.namespace_ ().empty ())
      {
        this->Red_.set (Red_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Green" && n.namespace_ ().empty ())
      {
        this->Green_.set (Green_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Blue" && n.namespace_ ().empty ())
      {
        this->Blue_.set (Blue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "WhitePoint" && n.namespace_ ().empty ())
      {
        this->WhitePoint_.set (WhitePoint_traits::create (i, f, this));
        continue;
      }
    }
  }

  ColorSpace* ColorSpace::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ColorSpace (*this, f, c);
  }

  ColorSpace& ColorSpace::
  operator= (const ColorSpace& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ColorSpace1_ = x.ColorSpace1_;
      this->Red_ = x.Red_;
      this->Green_ = x.Green_;
      this->Blue_ = x.Blue_;
      this->WhitePoint_ = x.WhitePoint_;
    }

    return *this;
  }

  ColorSpace::
  ~ColorSpace ()
  {
  }

  // DMXProfiles
  //

  DMXProfiles::
  DMXProfiles ()
  : ::xml_schema::type (),
    DMXProfile_ (this)
  {
  }

  DMXProfiles::
  DMXProfiles (const DMXProfiles& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DMXProfile_ (x.DMXProfile_, f, this)
  {
  }

  DMXProfiles::
  DMXProfiles (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DMXProfile_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DMXProfiles::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DMXProfile
      //
      if (n.name () == "DMXProfile" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< DMXProfile_type > r (
          DMXProfile_traits::create (i, f, this));

        this->DMXProfile_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DMXProfiles* DMXProfiles::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DMXProfiles (*this, f, c);
  }

  DMXProfiles& DMXProfiles::
  operator= (const DMXProfiles& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DMXProfile_ = x.DMXProfile_;
    }

    return *this;
  }

  DMXProfiles::
  ~DMXProfiles ()
  {
  }

  // DMXProfile
  //

  DMXProfile::
  DMXProfile ()
  : ::xml_schema::type ()
  {
  }

  DMXProfile::
  DMXProfile (const DMXProfile& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  DMXProfile::
  DMXProfile (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  DMXProfile::
  DMXProfile (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  DMXProfile::
  DMXProfile (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  DMXProfile* DMXProfile::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DMXProfile (*this, f, c);
  }

  DMXProfile::
  ~DMXProfile ()
  {
  }

  // CRIs
  //

  CRIs::
  CRIs ()
  : ::xml_schema::type (),
    CRI_ (this)
  {
  }

  CRIs::
  CRIs (const CRIs& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CRI_ (x.CRI_, f, this)
  {
  }

  CRIs::
  CRIs (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CRI_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CRIs::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CRI
      //
      if (n.name () == "CRI" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< CRI_type > r (
          CRI_traits::create (i, f, this));

        this->CRI_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CRIs* CRIs::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CRIs (*this, f, c);
  }

  CRIs& CRIs::
  operator= (const CRIs& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CRI_ = x.CRI_;
    }

    return *this;
  }

  CRIs::
  ~CRIs ()
  {
  }

  // CRI
  //

  CRI::
  CRI ()
  : ::xml_schema::type (),
    CES_ (this),
    ColorRenderingIndex_ (this)
  {
  }

  CRI::
  CRI (const CRI& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CES_ (x.CES_, f, this),
    ColorRenderingIndex_ (x.ColorRenderingIndex_, f, this)
  {
  }

  CRI::
  CRI (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CES_ (this),
    ColorRenderingIndex_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CRI::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "CES" && n.namespace_ ().empty ())
      {
        this->CES_.set (CES_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ColorRenderingIndex" && n.namespace_ ().empty ())
      {
        this->ColorRenderingIndex_.set (ColorRenderingIndex_traits::create (i, f, this));
        continue;
      }
    }
  }

  CRI* CRI::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CRI (*this, f, c);
  }

  CRI& CRI::
  operator= (const CRI& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->CES_ = x.CES_;
      this->ColorRenderingIndex_ = x.ColorRenderingIndex_;
    }

    return *this;
  }

  CRI::
  ~CRI ()
  {
  }

  // Protocols
  //

  Protocols::
  Protocols ()
  : ::xml_schema::type (),
    RDM_ (this),
    Art_Net_ (this),
    sACN_ (this),
    KiNET_ (this),
    PosiStageNet_ (this),
    OpenSoundControl_ (this),
    CITP_ (this)
  {
  }

  Protocols::
  Protocols (const Protocols& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    RDM_ (x.RDM_, f, this),
    Art_Net_ (x.Art_Net_, f, this),
    sACN_ (x.sACN_, f, this),
    KiNET_ (x.KiNET_, f, this),
    PosiStageNet_ (x.PosiStageNet_, f, this),
    OpenSoundControl_ (x.OpenSoundControl_, f, this),
    CITP_ (x.CITP_, f, this)
  {
  }

  Protocols::
  Protocols (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    RDM_ (this),
    Art_Net_ (this),
    sACN_ (this),
    KiNET_ (this),
    PosiStageNet_ (this),
    OpenSoundControl_ (this),
    CITP_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Protocols::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RDM
      //
      if (n.name () == "RDM" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< RDM_type > r (
          RDM_traits::create (i, f, this));

        this->RDM_.push_back (::std::move (r));
        continue;
      }

      // Art-Net
      //
      if (n.name () == "Art-Net" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Art_Net_type > r (
          Art_Net_traits::create (i, f, this));

        this->Art_Net_.push_back (::std::move (r));
        continue;
      }

      // sACN
      //
      if (n.name () == "sACN" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< sACN_type > r (
          sACN_traits::create (i, f, this));

        this->sACN_.push_back (::std::move (r));
        continue;
      }

      // KiNET
      //
      if (n.name () == "KiNET" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< KiNET_type > r (
          KiNET_traits::create (i, f, this));

        this->KiNET_.push_back (::std::move (r));
        continue;
      }

      // PosiStageNet
      //
      if (n.name () == "PosiStageNet" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< PosiStageNet_type > r (
          PosiStageNet_traits::create (i, f, this));

        this->PosiStageNet_.push_back (::std::move (r));
        continue;
      }

      // OpenSoundControl
      //
      if (n.name () == "OpenSoundControl" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< OpenSoundControl_type > r (
          OpenSoundControl_traits::create (i, f, this));

        this->OpenSoundControl_.push_back (::std::move (r));
        continue;
      }

      // CITP
      //
      if (n.name () == "CITP" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< CITP_type > r (
          CITP_traits::create (i, f, this));

        this->CITP_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Protocols* Protocols::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Protocols (*this, f, c);
  }

  Protocols& Protocols::
  operator= (const Protocols& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->RDM_ = x.RDM_;
      this->Art_Net_ = x.Art_Net_;
      this->sACN_ = x.sACN_;
      this->KiNET_ = x.KiNET_;
      this->PosiStageNet_ = x.PosiStageNet_;
      this->OpenSoundControl_ = x.OpenSoundControl_;
      this->CITP_ = x.CITP_;
    }

    return *this;
  }

  Protocols::
  ~Protocols ()
  {
  }

  // Art_Net
  //

  Art_Net::
  Art_Net ()
  : ::xml_schema::type ()
  {
  }

  Art_Net::
  Art_Net (const Art_Net& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  Art_Net::
  Art_Net (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Art_Net::
  Art_Net (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Art_Net::
  Art_Net (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Art_Net* Art_Net::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Art_Net (*this, f, c);
  }

  Art_Net::
  ~Art_Net ()
  {
  }

  // sACN
  //

  sACN::
  sACN ()
  : ::xml_schema::type ()
  {
  }

  sACN::
  sACN (const sACN& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  sACN::
  sACN (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  sACN::
  sACN (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  sACN::
  sACN (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  sACN* sACN::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sACN (*this, f, c);
  }

  sACN::
  ~sACN ()
  {
  }

  // KiNET
  //

  KiNET::
  KiNET ()
  : ::xml_schema::type ()
  {
  }

  KiNET::
  KiNET (const KiNET& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  KiNET::
  KiNET (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  KiNET::
  KiNET (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  KiNET::
  KiNET (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  KiNET* KiNET::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KiNET (*this, f, c);
  }

  KiNET::
  ~KiNET ()
  {
  }

  // PosiStageNet
  //

  PosiStageNet::
  PosiStageNet ()
  : ::xml_schema::type ()
  {
  }

  PosiStageNet::
  PosiStageNet (const PosiStageNet& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  PosiStageNet::
  PosiStageNet (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  PosiStageNet::
  PosiStageNet (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  PosiStageNet::
  PosiStageNet (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  PosiStageNet* PosiStageNet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PosiStageNet (*this, f, c);
  }

  PosiStageNet::
  ~PosiStageNet ()
  {
  }

  // OpenSoundControl
  //

  OpenSoundControl::
  OpenSoundControl ()
  : ::xml_schema::type ()
  {
  }

  OpenSoundControl::
  OpenSoundControl (const OpenSoundControl& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  OpenSoundControl::
  OpenSoundControl (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  OpenSoundControl::
  OpenSoundControl (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  OpenSoundControl::
  OpenSoundControl (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  OpenSoundControl* OpenSoundControl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OpenSoundControl (*this, f, c);
  }

  OpenSoundControl::
  ~OpenSoundControl ()
  {
  }

  // CITP
  //

  CITP::
  CITP ()
  : ::xml_schema::type ()
  {
  }

  CITP::
  CITP (const CITP& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  CITP::
  CITP (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  CITP::
  CITP (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  CITP::
  CITP (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  CITP* CITP::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CITP (*this, f, c);
  }

  CITP::
  ~CITP ()
  {
  }

  // RDM
  //

  RDM::
  RDM ()
  : ::xml_schema::type (),
    SoftwareVersionID_ (this),
    ManufacturerID_ (this),
    DeviceModelID_ (this)
  {
  }

  RDM::
  RDM (const RDM& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SoftwareVersionID_ (x.SoftwareVersionID_, f, this),
    ManufacturerID_ (x.ManufacturerID_, f, this),
    DeviceModelID_ (x.DeviceModelID_, f, this)
  {
  }

  RDM::
  RDM (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SoftwareVersionID_ (this),
    ManufacturerID_ (this),
    DeviceModelID_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RDM::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SoftwareVersionID
      //
      if (n.name () == "SoftwareVersionID" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< SoftwareVersionID_type > r (
          SoftwareVersionID_traits::create (i, f, this));

        this->SoftwareVersionID_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ManufacturerID" && n.namespace_ ().empty ())
      {
        this->ManufacturerID_.set (ManufacturerID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DeviceModelID" && n.namespace_ ().empty ())
      {
        this->DeviceModelID_.set (DeviceModelID_traits::create (i, f, this));
        continue;
      }
    }
  }

  RDM* RDM::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RDM (*this, f, c);
  }

  RDM& RDM::
  operator= (const RDM& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SoftwareVersionID_ = x.SoftwareVersionID_;
      this->ManufacturerID_ = x.ManufacturerID_;
      this->DeviceModelID_ = x.DeviceModelID_;
    }

    return *this;
  }

  RDM::
  ~RDM ()
  {
  }

  // SoftwareVersionID
  //

  SoftwareVersionID::
  SoftwareVersionID ()
  : ::xml_schema::type (),
    DMXPersonality_ (this),
    Value_ (this)
  {
  }

  SoftwareVersionID::
  SoftwareVersionID (const SoftwareVersionID& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DMXPersonality_ (x.DMXPersonality_, f, this),
    Value_ (x.Value_, f, this)
  {
  }

  SoftwareVersionID::
  SoftwareVersionID (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DMXPersonality_ (this),
    Value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SoftwareVersionID::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DMXPersonality
      //
      if (n.name () == "DMXPersonality" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< DMXPersonality_type > r (
          DMXPersonality_traits::create (i, f, this));

        this->DMXPersonality_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Value" && n.namespace_ ().empty ())
      {
        this->Value_.set (Value_traits::create (i, f, this));
        continue;
      }
    }
  }

  SoftwareVersionID* SoftwareVersionID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SoftwareVersionID (*this, f, c);
  }

  SoftwareVersionID& SoftwareVersionID::
  operator= (const SoftwareVersionID& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DMXPersonality_ = x.DMXPersonality_;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  SoftwareVersionID::
  ~SoftwareVersionID ()
  {
  }

  // DMXPersonality
  //

  DMXPersonality::
  DMXPersonality ()
  : ::xml_schema::type (),
    Value_ (this),
    DMXMode_ (this)
  {
  }

  DMXPersonality::
  DMXPersonality (const DMXPersonality& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Value_ (x.Value_, f, this),
    DMXMode_ (x.DMXMode_, f, this)
  {
  }

  DMXPersonality::
  DMXPersonality (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Value_ (this),
    DMXMode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DMXPersonality::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Value" && n.namespace_ ().empty ())
      {
        this->Value_.set (Value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "DMXMode" && n.namespace_ ().empty ())
      {
        this->DMXMode_.set (DMXMode_traits::create (i, f, this));
        continue;
      }
    }
  }

  DMXPersonality* DMXPersonality::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DMXPersonality (*this, f, c);
  }

  DMXPersonality& DMXPersonality::
  operator= (const DMXPersonality& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Value_ = x.Value_;
      this->DMXMode_ = x.DMXMode_;
    }

    return *this;
  }

  DMXPersonality::
  ~DMXPersonality ()
  {
  }

  // AttributeDefinitions
  //

  AttributeDefinitions::
  AttributeDefinitions (const FeatureGroups_type& FeatureGroups,
                        const Attributes_type& Attributes)
  : ::xml_schema::type (),
    ActivationGroups_ (this),
    FeatureGroups_ (FeatureGroups, this),
    Attributes_ (Attributes, this)
  {
  }

  AttributeDefinitions::
  AttributeDefinitions (::std::unique_ptr< FeatureGroups_type > FeatureGroups,
                        ::std::unique_ptr< Attributes_type > Attributes)
  : ::xml_schema::type (),
    ActivationGroups_ (this),
    FeatureGroups_ (std::move (FeatureGroups), this),
    Attributes_ (std::move (Attributes), this)
  {
  }

  AttributeDefinitions::
  AttributeDefinitions (const AttributeDefinitions& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ActivationGroups_ (x.ActivationGroups_, f, this),
    FeatureGroups_ (x.FeatureGroups_, f, this),
    Attributes_ (x.Attributes_, f, this)
  {
  }

  AttributeDefinitions::
  AttributeDefinitions (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ActivationGroups_ (this),
    FeatureGroups_ (this),
    Attributes_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AttributeDefinitions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ActivationGroups
      //
      if (n.name () == "ActivationGroups" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< ActivationGroups_type > r (
          ActivationGroups_traits::create (i, f, this));

        if (!this->ActivationGroups_)
        {
          this->ActivationGroups_.set (::std::move (r));
          continue;
        }
      }

      // FeatureGroups
      //
      if (n.name () == "FeatureGroups" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FeatureGroups_type > r (
          FeatureGroups_traits::create (i, f, this));

        if (!FeatureGroups_.present ())
        {
          this->FeatureGroups_.set (::std::move (r));
          continue;
        }
      }

      // Attributes
      //
      if (n.name () == "Attributes" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Attributes_type > r (
          Attributes_traits::create (i, f, this));

        if (!Attributes_.present ())
        {
          this->Attributes_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!FeatureGroups_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FeatureGroups",
        "http://schemas.gdtf-share.com/device");
    }

    if (!Attributes_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Attributes",
        "http://schemas.gdtf-share.com/device");
    }
  }

  AttributeDefinitions* AttributeDefinitions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AttributeDefinitions (*this, f, c);
  }

  AttributeDefinitions& AttributeDefinitions::
  operator= (const AttributeDefinitions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ActivationGroups_ = x.ActivationGroups_;
      this->FeatureGroups_ = x.FeatureGroups_;
      this->Attributes_ = x.Attributes_;
    }

    return *this;
  }

  AttributeDefinitions::
  ~AttributeDefinitions ()
  {
  }

  // ActivationGroups
  //

  ActivationGroups::
  ActivationGroups ()
  : ::xml_schema::type (),
    ActivationGroup_ (this)
  {
  }

  ActivationGroups::
  ActivationGroups (const ActivationGroups& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ActivationGroup_ (x.ActivationGroup_, f, this)
  {
  }

  ActivationGroups::
  ActivationGroups (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ActivationGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ActivationGroups::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ActivationGroup
      //
      if (n.name () == "ActivationGroup" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< ActivationGroup_type > r (
          ActivationGroup_traits::create (i, f, this));

        this->ActivationGroup_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ActivationGroups* ActivationGroups::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ActivationGroups (*this, f, c);
  }

  ActivationGroups& ActivationGroups::
  operator= (const ActivationGroups& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ActivationGroup_ = x.ActivationGroup_;
    }

    return *this;
  }

  ActivationGroups::
  ~ActivationGroups ()
  {
  }

  // FeatureGroups
  //

  FeatureGroups::
  FeatureGroups ()
  : ::xml_schema::type (),
    FeatureGroup_ (this)
  {
  }

  FeatureGroups::
  FeatureGroups (const FeatureGroups& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FeatureGroup_ (x.FeatureGroup_, f, this)
  {
  }

  FeatureGroups::
  FeatureGroups (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FeatureGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FeatureGroups::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FeatureGroup
      //
      if (n.name () == "FeatureGroup" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< FeatureGroup_type > r (
          FeatureGroup_traits::create (i, f, this));

        this->FeatureGroup_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  FeatureGroups* FeatureGroups::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FeatureGroups (*this, f, c);
  }

  FeatureGroups& FeatureGroups::
  operator= (const FeatureGroups& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FeatureGroup_ = x.FeatureGroup_;
    }

    return *this;
  }

  FeatureGroups::
  ~FeatureGroups ()
  {
  }

  // ActivationGroup
  //

  ActivationGroup::
  ActivationGroup ()
  : ::xml_schema::type (),
    Name_ (this)
  {
  }

  ActivationGroup::
  ActivationGroup (const ActivationGroup& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Name_ (x.Name_, f, this)
  {
  }

  ActivationGroup::
  ActivationGroup (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ActivationGroup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }
    }
  }

  ActivationGroup* ActivationGroup::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ActivationGroup (*this, f, c);
  }

  ActivationGroup& ActivationGroup::
  operator= (const ActivationGroup& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Name_ = x.Name_;
    }

    return *this;
  }

  ActivationGroup::
  ~ActivationGroup ()
  {
  }

  // FeatureGroup
  //

  FeatureGroup::
  FeatureGroup (const Name_type& Name,
                const Pretty_type& Pretty)
  : ::xml_schema::type (),
    Feature_ (this),
    Name_ (Name, this),
    Pretty_ (Pretty, this)
  {
  }

  FeatureGroup::
  FeatureGroup (const FeatureGroup& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Feature_ (x.Feature_, f, this),
    Name_ (x.Name_, f, this),
    Pretty_ (x.Pretty_, f, this)
  {
  }

  FeatureGroup::
  FeatureGroup (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Feature_ (this),
    Name_ (this),
    Pretty_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FeatureGroup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Feature
      //
      if (n.name () == "Feature" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Feature_type > r (
          Feature_traits::create (i, f, this));

        this->Feature_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Pretty" && n.namespace_ ().empty ())
      {
        this->Pretty_.set (Pretty_traits::create (i, f, this));
        continue;
      }
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Name",
        "");
    }

    if (!Pretty_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Pretty",
        "");
    }
  }

  FeatureGroup* FeatureGroup::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FeatureGroup (*this, f, c);
  }

  FeatureGroup& FeatureGroup::
  operator= (const FeatureGroup& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Feature_ = x.Feature_;
      this->Name_ = x.Name_;
      this->Pretty_ = x.Pretty_;
    }

    return *this;
  }

  FeatureGroup::
  ~FeatureGroup ()
  {
  }

  // Feature
  //

  Feature::
  Feature ()
  : ::xml_schema::type (),
    Name_ (this)
  {
  }

  Feature::
  Feature (const Feature& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Name_ (x.Name_, f, this)
  {
  }

  Feature::
  Feature (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Feature::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }
    }
  }

  Feature* Feature::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Feature (*this, f, c);
  }

  Feature& Feature::
  operator= (const Feature& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Name_ = x.Name_;
    }

    return *this;
  }

  Feature::
  ~Feature ()
  {
  }

  // Attributes
  //

  Attributes::
  Attributes ()
  : ::xml_schema::type (),
    Attribute_ (this)
  {
  }

  Attributes::
  Attributes (const Attributes& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Attribute_ (x.Attribute_, f, this)
  {
  }

  Attributes::
  Attributes (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Attribute_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Attributes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Attribute
      //
      if (n.name () == "Attribute" && n.namespace_ () == "http://schemas.gdtf-share.com/device")
      {
        ::std::unique_ptr< Attribute_type > r (
          Attribute_traits::create (i, f, this));

        this->Attribute_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Attributes* Attributes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Attributes (*this, f, c);
  }

  Attributes& Attributes::
  operator= (const Attributes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Attribute_ = x.Attribute_;
    }

    return *this;
  }

  Attributes::
  ~Attributes ()
  {
  }

  // Attribute
  //

  Attribute::
  Attribute (const Name_type& Name,
             const Pretty_type& Pretty)
  : ::xml_schema::type (),
    Name_ (Name, this),
    Pretty_ (Pretty, this),
    ActivationGroup_ (this),
    PhysicalUnit_ (this),
    Color_ (this),
    Feature_ (this),
    MainAttribute_ (this)
  {
  }

  Attribute::
  Attribute (const Attribute& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Name_ (x.Name_, f, this),
    Pretty_ (x.Pretty_, f, this),
    ActivationGroup_ (x.ActivationGroup_, f, this),
    PhysicalUnit_ (x.PhysicalUnit_, f, this),
    Color_ (x.Color_, f, this),
    Feature_ (x.Feature_, f, this),
    MainAttribute_ (x.MainAttribute_, f, this)
  {
  }

  Attribute::
  Attribute (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Name_ (this),
    Pretty_ (this),
    ActivationGroup_ (this),
    PhysicalUnit_ (this),
    Color_ (this),
    Feature_ (this),
    MainAttribute_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Attribute::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Name" && n.namespace_ ().empty ())
      {
        this->Name_.set (Name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Pretty" && n.namespace_ ().empty ())
      {
        this->Pretty_.set (Pretty_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ActivationGroup" && n.namespace_ ().empty ())
      {
        this->ActivationGroup_.set (ActivationGroup_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "PhysicalUnit" && n.namespace_ ().empty ())
      {
        this->PhysicalUnit_.set (PhysicalUnit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Color" && n.namespace_ ().empty ())
      {
        this->Color_.set (Color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "Feature" && n.namespace_ ().empty ())
      {
        this->Feature_.set (Feature_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "MainAttribute" && n.namespace_ ().empty ())
      {
        this->MainAttribute_.set (MainAttribute_traits::create (i, f, this));
        continue;
      }
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Name",
        "");
    }

    if (!Pretty_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Pretty",
        "");
    }
  }

  Attribute* Attribute::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Attribute (*this, f, c);
  }

  Attribute& Attribute::
  operator= (const Attribute& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Name_ = x.Name_;
      this->Pretty_ = x.Pretty_;
      this->ActivationGroup_ = x.ActivationGroup_;
      this->PhysicalUnit_ = x.PhysicalUnit_;
      this->Color_ = x.Color_;
      this->Feature_ = x.Feature_;
      this->MainAttribute_ = x.MainAttribute_;
    }

    return *this;
  }

  Attribute::
  ~Attribute ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace device
{
  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::GDTF > (
      ::device::GDTF_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::GDTF > (
      ::device::GDTF_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::GDTF > (
      ::device::GDTF_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::GDTF_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::GDTF_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::GDTF_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::GDTF_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::GDTF_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::GDTF_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::GDTF > (
      ::device::GDTF_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::GDTF > (
      ::device::GDTF_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::GDTF > (
      ::device::GDTF_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::GDTF > (
        ::device::GDTF_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GDTF" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::GDTF > r (
        ::xsd::cxx::tree::traits< ::device::GDTF, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GDTF",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::GDTF >
  GDTF_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GDTF" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::GDTF > r (
        ::xsd::cxx::tree::traits< ::device::GDTF, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GDTF",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FixtureType > (
      ::device::FixtureType_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FixtureType > (
      ::device::FixtureType_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FixtureType > (
      ::device::FixtureType_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FixtureType_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FixtureType_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FixtureType_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FixtureType_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FixtureType_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FixtureType_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FixtureType > (
      ::device::FixtureType_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FixtureType > (
      ::device::FixtureType_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FixtureType > (
      ::device::FixtureType_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FixtureType > (
        ::device::FixtureType_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FixtureType" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FixtureType > r (
        ::xsd::cxx::tree::traits< ::device::FixtureType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FixtureType",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FixtureType >
  FixtureType_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FixtureType" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FixtureType > r (
        ::xsd::cxx::tree::traits< ::device::FixtureType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FixtureType",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Wheels > (
      ::device::Wheels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Wheels > (
      ::device::Wheels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Wheels > (
      ::device::Wheels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Wheels_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Wheels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Wheels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Wheels_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Wheels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Wheels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Wheels > (
      ::device::Wheels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Wheels > (
      ::device::Wheels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Wheels > (
      ::device::Wheels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Wheels > (
        ::device::Wheels_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Wheels" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Wheels > r (
        ::xsd::cxx::tree::traits< ::device::Wheels, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Wheels",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Wheels >
  Wheels_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Wheels" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Wheels > r (
        ::xsd::cxx::tree::traits< ::device::Wheels, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Wheels",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Wheel > (
      ::device::Wheel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Wheel > (
      ::device::Wheel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Wheel > (
      ::device::Wheel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Wheel_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Wheel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Wheel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Wheel_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Wheel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Wheel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Wheel > (
      ::device::Wheel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Wheel > (
      ::device::Wheel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Wheel > (
      ::device::Wheel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Wheel > (
        ::device::Wheel_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Wheel" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Wheel > r (
        ::xsd::cxx::tree::traits< ::device::Wheel, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Wheel",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Wheel >
  Wheel_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Wheel" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Wheel > r (
        ::xsd::cxx::tree::traits< ::device::Wheel, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Wheel",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Slot > (
      ::device::Slot_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Slot > (
      ::device::Slot_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Slot > (
      ::device::Slot_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Slot_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Slot_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Slot_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Slot_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Slot_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Slot_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Slot > (
      ::device::Slot_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Slot > (
      ::device::Slot_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Slot > (
      ::device::Slot_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Slot > (
        ::device::Slot_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Slot" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Slot > r (
        ::xsd::cxx::tree::traits< ::device::Slot, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Slot",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Slot >
  Slot_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Slot" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Slot > r (
        ::xsd::cxx::tree::traits< ::device::Slot, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Slot",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Facet > (
      ::device::Facet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Facet > (
      ::device::Facet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Facet > (
      ::device::Facet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Facet_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Facet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Facet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Facet_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Facet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Facet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Facet > (
      ::device::Facet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Facet > (
      ::device::Facet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Facet > (
      ::device::Facet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Facet > (
        ::device::Facet_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Facet" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Facet > r (
        ::xsd::cxx::tree::traits< ::device::Facet, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Facet",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Facet >
  Facet_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Facet" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Facet > r (
        ::xsd::cxx::tree::traits< ::device::Facet, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Facet",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Models > (
      ::device::Models_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Models > (
      ::device::Models_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Models > (
      ::device::Models_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Models_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Models_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Models_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Models_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Models_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Models_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Models > (
      ::device::Models_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Models > (
      ::device::Models_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Models > (
      ::device::Models_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Models > (
        ::device::Models_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Models" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Models > r (
        ::xsd::cxx::tree::traits< ::device::Models, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Models",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Models >
  Models_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Models" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Models > r (
        ::xsd::cxx::tree::traits< ::device::Models, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Models",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Model > (
      ::device::Model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Model > (
      ::device::Model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Model > (
      ::device::Model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Model_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Model_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Model_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Model_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Model_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Model_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Model > (
      ::device::Model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Model > (
      ::device::Model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Model > (
      ::device::Model_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Model > (
        ::device::Model_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Model" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Model > r (
        ::xsd::cxx::tree::traits< ::device::Model, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Model",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Model >
  Model_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Model" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Model > r (
        ::xsd::cxx::tree::traits< ::device::Model, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Model",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Geometries > (
      ::device::Geometries_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Geometries > (
      ::device::Geometries_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Geometries > (
      ::device::Geometries_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Geometries_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Geometries_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Geometries_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Geometries_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Geometries_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Geometries_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Geometries > (
      ::device::Geometries_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Geometries > (
      ::device::Geometries_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Geometries > (
      ::device::Geometries_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Geometries > (
        ::device::Geometries_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Geometries" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Geometries > r (
        ::xsd::cxx::tree::traits< ::device::Geometries, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Geometries",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Geometries >
  Geometries_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Geometries" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Geometries > r (
        ::xsd::cxx::tree::traits< ::device::Geometries, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Geometries",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Geometry > (
      ::device::Geometry_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Geometry > (
      ::device::Geometry_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Geometry > (
      ::device::Geometry_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Geometry_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Geometry_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Geometry_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Geometry_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Geometry_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Geometry_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Geometry > (
      ::device::Geometry_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Geometry > (
      ::device::Geometry_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Geometry > (
      ::device::Geometry_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Geometry > (
        ::device::Geometry_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Geometry" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Geometry > r (
        ::xsd::cxx::tree::traits< ::device::Geometry, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Geometry",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Geometry >
  Geometry_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Geometry" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Geometry > r (
        ::xsd::cxx::tree::traits< ::device::Geometry, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Geometry",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Axis > (
      ::device::Axis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Axis > (
      ::device::Axis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Axis > (
      ::device::Axis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Axis_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Axis_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Axis_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Axis_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Axis_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Axis_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Axis > (
      ::device::Axis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Axis > (
      ::device::Axis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Axis > (
      ::device::Axis_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Axis > (
        ::device::Axis_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Axis" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Axis > r (
        ::xsd::cxx::tree::traits< ::device::Axis, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Axis",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Axis >
  Axis_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Axis" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Axis > r (
        ::xsd::cxx::tree::traits< ::device::Axis, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Axis",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FilterBeam > (
      ::device::FilterBeam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterBeam > (
      ::device::FilterBeam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterBeam > (
      ::device::FilterBeam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterBeam_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterBeam_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterBeam_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterBeam_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterBeam_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterBeam_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FilterBeam > (
      ::device::FilterBeam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterBeam > (
      ::device::FilterBeam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterBeam > (
      ::device::FilterBeam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FilterBeam > (
        ::device::FilterBeam_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FilterBeam" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FilterBeam > r (
        ::xsd::cxx::tree::traits< ::device::FilterBeam, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FilterBeam",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FilterBeam >
  FilterBeam_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FilterBeam" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FilterBeam > r (
        ::xsd::cxx::tree::traits< ::device::FilterBeam, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FilterBeam",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FilterColor > (
      ::device::FilterColor_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterColor > (
      ::device::FilterColor_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterColor > (
      ::device::FilterColor_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterColor_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterColor_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterColor_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterColor_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterColor_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterColor_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FilterColor > (
      ::device::FilterColor_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterColor > (
      ::device::FilterColor_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterColor > (
      ::device::FilterColor_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FilterColor > (
        ::device::FilterColor_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FilterColor" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FilterColor > r (
        ::xsd::cxx::tree::traits< ::device::FilterColor, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FilterColor",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FilterColor >
  FilterColor_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FilterColor" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FilterColor > r (
        ::xsd::cxx::tree::traits< ::device::FilterColor, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FilterColor",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FilterGobo > (
      ::device::FilterGobo_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterGobo > (
      ::device::FilterGobo_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterGobo > (
      ::device::FilterGobo_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterGobo_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterGobo_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterGobo_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterGobo_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterGobo_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterGobo_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FilterGobo > (
      ::device::FilterGobo_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterGobo > (
      ::device::FilterGobo_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterGobo > (
      ::device::FilterGobo_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FilterGobo > (
        ::device::FilterGobo_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FilterGobo" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FilterGobo > r (
        ::xsd::cxx::tree::traits< ::device::FilterGobo, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FilterGobo",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FilterGobo >
  FilterGobo_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FilterGobo" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FilterGobo > r (
        ::xsd::cxx::tree::traits< ::device::FilterGobo, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FilterGobo",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FilterShaper > (
      ::device::FilterShaper_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterShaper > (
      ::device::FilterShaper_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterShaper > (
      ::device::FilterShaper_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterShaper_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterShaper_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FilterShaper_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterShaper_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterShaper_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FilterShaper_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FilterShaper > (
      ::device::FilterShaper_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterShaper > (
      ::device::FilterShaper_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FilterShaper > (
      ::device::FilterShaper_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FilterShaper > (
        ::device::FilterShaper_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FilterShaper" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FilterShaper > r (
        ::xsd::cxx::tree::traits< ::device::FilterShaper, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FilterShaper",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FilterShaper >
  FilterShaper_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FilterShaper" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FilterShaper > r (
        ::xsd::cxx::tree::traits< ::device::FilterShaper, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FilterShaper",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Beam > (
      ::device::Beam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Beam > (
      ::device::Beam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Beam > (
      ::device::Beam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Beam_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Beam_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Beam_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Beam_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Beam_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Beam_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Beam > (
      ::device::Beam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Beam > (
      ::device::Beam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Beam > (
      ::device::Beam_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Beam > (
        ::device::Beam_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Beam" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Beam > r (
        ::xsd::cxx::tree::traits< ::device::Beam, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Beam",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Beam >
  Beam_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Beam" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Beam > r (
        ::xsd::cxx::tree::traits< ::device::Beam, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Beam",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::GeometryReference > (
      ::device::GeometryReference_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::GeometryReference > (
      ::device::GeometryReference_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::GeometryReference > (
      ::device::GeometryReference_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::GeometryReference_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::GeometryReference_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::GeometryReference_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::GeometryReference_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::GeometryReference_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::GeometryReference_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::GeometryReference > (
      ::device::GeometryReference_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::GeometryReference > (
      ::device::GeometryReference_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::GeometryReference > (
      ::device::GeometryReference_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::GeometryReference > (
        ::device::GeometryReference_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GeometryReference" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::GeometryReference > r (
        ::xsd::cxx::tree::traits< ::device::GeometryReference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GeometryReference",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::GeometryReference >
  GeometryReference_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GeometryReference" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::GeometryReference > r (
        ::xsd::cxx::tree::traits< ::device::GeometryReference, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GeometryReference",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Break > (
      ::device::Break_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Break > (
      ::device::Break_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Break > (
      ::device::Break_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Break_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Break_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Break_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Break_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Break_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Break_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Break > (
      ::device::Break_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Break > (
      ::device::Break_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Break > (
      ::device::Break_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Break > (
        ::device::Break_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Break" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Break > r (
        ::xsd::cxx::tree::traits< ::device::Break, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Break",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Break >
  Break_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Break" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Break > r (
        ::xsd::cxx::tree::traits< ::device::Break, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Break",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXModes > (
      ::device::DMXModes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXModes > (
      ::device::DMXModes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXModes > (
      ::device::DMXModes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXModes_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXModes_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXModes_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXModes_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXModes_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXModes_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXModes > (
      ::device::DMXModes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXModes > (
      ::device::DMXModes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXModes > (
      ::device::DMXModes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::DMXModes > (
        ::device::DMXModes_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DMXModes" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXModes > r (
        ::xsd::cxx::tree::traits< ::device::DMXModes, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXModes",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXModes >
  DMXModes_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DMXModes" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXModes > r (
        ::xsd::cxx::tree::traits< ::device::DMXModes, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXModes",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXMode > (
      ::device::DMXMode_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXMode > (
      ::device::DMXMode_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXMode > (
      ::device::DMXMode_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXMode_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXMode_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXMode_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXMode_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXMode_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXMode_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXMode > (
      ::device::DMXMode_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXMode > (
      ::device::DMXMode_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXMode > (
      ::device::DMXMode_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::DMXMode > (
        ::device::DMXMode_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DMXMode" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXMode > r (
        ::xsd::cxx::tree::traits< ::device::DMXMode, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXMode",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXMode >
  DMXMode_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DMXMode" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXMode > r (
        ::xsd::cxx::tree::traits< ::device::DMXMode, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXMode",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXChannels > (
      ::device::DMXChannels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXChannels > (
      ::device::DMXChannels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXChannels > (
      ::device::DMXChannels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXChannels_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXChannels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXChannels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXChannels_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXChannels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXChannels_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXChannels > (
      ::device::DMXChannels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXChannels > (
      ::device::DMXChannels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXChannels > (
      ::device::DMXChannels_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::DMXChannels > (
        ::device::DMXChannels_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DMXChannels" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXChannels > r (
        ::xsd::cxx::tree::traits< ::device::DMXChannels, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXChannels",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXChannels >
  DMXChannels_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DMXChannels" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXChannels > r (
        ::xsd::cxx::tree::traits< ::device::DMXChannels, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXChannels",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXChannel > (
      ::device::DMXChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXChannel > (
      ::device::DMXChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXChannel > (
      ::device::DMXChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXChannel_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXChannel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXChannel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXChannel_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXChannel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXChannel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXChannel > (
      ::device::DMXChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXChannel > (
      ::device::DMXChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXChannel > (
      ::device::DMXChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::DMXChannel > (
        ::device::DMXChannel_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DMXChannel" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXChannel > r (
        ::xsd::cxx::tree::traits< ::device::DMXChannel, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXChannel",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXChannel >
  DMXChannel_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DMXChannel" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXChannel > r (
        ::xsd::cxx::tree::traits< ::device::DMXChannel, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXChannel",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::LogicalChannel > (
      ::device::LogicalChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::LogicalChannel > (
      ::device::LogicalChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::LogicalChannel > (
      ::device::LogicalChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::LogicalChannel_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::LogicalChannel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::LogicalChannel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::LogicalChannel_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::LogicalChannel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::LogicalChannel_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::LogicalChannel > (
      ::device::LogicalChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::LogicalChannel > (
      ::device::LogicalChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::LogicalChannel > (
      ::device::LogicalChannel_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::LogicalChannel > (
        ::device::LogicalChannel_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "LogicalChannel" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::LogicalChannel > r (
        ::xsd::cxx::tree::traits< ::device::LogicalChannel, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "LogicalChannel",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::LogicalChannel >
  LogicalChannel_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "LogicalChannel" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::LogicalChannel > r (
        ::xsd::cxx::tree::traits< ::device::LogicalChannel, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "LogicalChannel",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ChannelFunction > (
      ::device::ChannelFunction_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ChannelFunction > (
      ::device::ChannelFunction_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ChannelFunction > (
      ::device::ChannelFunction_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ChannelFunction_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ChannelFunction_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ChannelFunction_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ChannelFunction_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ChannelFunction_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ChannelFunction_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ChannelFunction > (
      ::device::ChannelFunction_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ChannelFunction > (
      ::device::ChannelFunction_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ChannelFunction > (
      ::device::ChannelFunction_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::ChannelFunction > (
        ::device::ChannelFunction_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ChannelFunction" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ChannelFunction > r (
        ::xsd::cxx::tree::traits< ::device::ChannelFunction, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ChannelFunction",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ChannelFunction >
  ChannelFunction_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ChannelFunction" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ChannelFunction > r (
        ::xsd::cxx::tree::traits< ::device::ChannelFunction, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ChannelFunction",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ChannelSet > (
      ::device::ChannelSet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ChannelSet > (
      ::device::ChannelSet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ChannelSet > (
      ::device::ChannelSet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ChannelSet_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ChannelSet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ChannelSet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ChannelSet_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ChannelSet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ChannelSet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ChannelSet > (
      ::device::ChannelSet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ChannelSet > (
      ::device::ChannelSet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ChannelSet > (
      ::device::ChannelSet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::ChannelSet > (
        ::device::ChannelSet_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ChannelSet" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ChannelSet > r (
        ::xsd::cxx::tree::traits< ::device::ChannelSet, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ChannelSet",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ChannelSet >
  ChannelSet_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ChannelSet" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ChannelSet > r (
        ::xsd::cxx::tree::traits< ::device::ChannelSet, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ChannelSet",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Relations > (
      ::device::Relations_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Relations > (
      ::device::Relations_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Relations > (
      ::device::Relations_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Relations_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Relations_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Relations_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Relations_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Relations_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Relations_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Relations > (
      ::device::Relations_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Relations > (
      ::device::Relations_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Relations > (
      ::device::Relations_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Relations > (
        ::device::Relations_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Relations" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Relations > r (
        ::xsd::cxx::tree::traits< ::device::Relations, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Relations",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Relations >
  Relations_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Relations" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Relations > r (
        ::xsd::cxx::tree::traits< ::device::Relations, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Relations",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Relation > (
      ::device::Relation_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Relation > (
      ::device::Relation_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Relation > (
      ::device::Relation_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Relation_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Relation_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Relation_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Relation_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Relation_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Relation_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Relation > (
      ::device::Relation_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Relation > (
      ::device::Relation_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Relation > (
      ::device::Relation_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Relation > (
        ::device::Relation_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Relation" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Relation > r (
        ::xsd::cxx::tree::traits< ::device::Relation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Relation",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Relation >
  Relation_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Relation" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Relation > r (
        ::xsd::cxx::tree::traits< ::device::Relation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Relation",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Revisions > (
      ::device::Revisions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Revisions > (
      ::device::Revisions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Revisions > (
      ::device::Revisions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Revisions_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Revisions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Revisions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Revisions_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Revisions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Revisions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Revisions > (
      ::device::Revisions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Revisions > (
      ::device::Revisions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Revisions > (
      ::device::Revisions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Revisions > (
        ::device::Revisions_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Revisions" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Revisions > r (
        ::xsd::cxx::tree::traits< ::device::Revisions, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Revisions",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Revisions >
  Revisions_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Revisions" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Revisions > r (
        ::xsd::cxx::tree::traits< ::device::Revisions, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Revisions",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Revision > (
      ::device::Revision_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Revision > (
      ::device::Revision_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Revision > (
      ::device::Revision_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Revision_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Revision_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Revision_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Revision_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Revision_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Revision_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Revision > (
      ::device::Revision_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Revision > (
      ::device::Revision_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Revision > (
      ::device::Revision_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Revision > (
        ::device::Revision_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Revision" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Revision > r (
        ::xsd::cxx::tree::traits< ::device::Revision, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Revision",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Revision >
  Revision_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Revision" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Revision > r (
        ::xsd::cxx::tree::traits< ::device::Revision, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Revision",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FTPresets > (
      ::device::FTPresets_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTPresets > (
      ::device::FTPresets_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTPresets > (
      ::device::FTPresets_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTPresets_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTPresets_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTPresets_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTPresets_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTPresets_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTPresets_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FTPresets > (
      ::device::FTPresets_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTPresets > (
      ::device::FTPresets_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTPresets > (
      ::device::FTPresets_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FTPresets > (
        ::device::FTPresets_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FTPresets" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FTPresets > r (
        ::xsd::cxx::tree::traits< ::device::FTPresets, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FTPresets",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FTPresets >
  FTPresets_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FTPresets" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FTPresets > r (
        ::xsd::cxx::tree::traits< ::device::FTPresets, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FTPresets",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FTPreset > (
      ::device::FTPreset_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTPreset > (
      ::device::FTPreset_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTPreset > (
      ::device::FTPreset_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTPreset_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTPreset_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTPreset_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTPreset_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTPreset_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTPreset_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FTPreset > (
      ::device::FTPreset_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTPreset > (
      ::device::FTPreset_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTPreset > (
      ::device::FTPreset_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FTPreset > (
        ::device::FTPreset_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FTPreset" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FTPreset > r (
        ::xsd::cxx::tree::traits< ::device::FTPreset, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FTPreset",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FTPreset >
  FTPreset_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FTPreset" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FTPreset > r (
        ::xsd::cxx::tree::traits< ::device::FTPreset, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FTPreset",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FTMacros > (
      ::device::FTMacros_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTMacros > (
      ::device::FTMacros_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTMacros > (
      ::device::FTMacros_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTMacros_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTMacros_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTMacros_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTMacros_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTMacros_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTMacros_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FTMacros > (
      ::device::FTMacros_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTMacros > (
      ::device::FTMacros_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTMacros > (
      ::device::FTMacros_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FTMacros > (
        ::device::FTMacros_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FTMacros" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FTMacros > r (
        ::xsd::cxx::tree::traits< ::device::FTMacros, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FTMacros",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FTMacros >
  FTMacros_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FTMacros" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FTMacros > r (
        ::xsd::cxx::tree::traits< ::device::FTMacros, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FTMacros",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FTMacro > (
      ::device::FTMacro_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTMacro > (
      ::device::FTMacro_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTMacro > (
      ::device::FTMacro_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTMacro_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTMacro_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FTMacro_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTMacro_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTMacro_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FTMacro_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FTMacro > (
      ::device::FTMacro_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTMacro > (
      ::device::FTMacro_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FTMacro > (
      ::device::FTMacro_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FTMacro > (
        ::device::FTMacro_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FTMacro" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FTMacro > r (
        ::xsd::cxx::tree::traits< ::device::FTMacro, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FTMacro",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FTMacro >
  FTMacro_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FTMacro" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FTMacro > r (
        ::xsd::cxx::tree::traits< ::device::FTMacro, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FTMacro",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::MacroDMX > (
      ::device::MacroDMX_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MacroDMX > (
      ::device::MacroDMX_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MacroDMX > (
      ::device::MacroDMX_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::MacroDMX_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::MacroDMX_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::MacroDMX_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::MacroDMX_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::MacroDMX_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::MacroDMX_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::MacroDMX > (
      ::device::MacroDMX_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MacroDMX > (
      ::device::MacroDMX_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MacroDMX > (
      ::device::MacroDMX_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::MacroDMX > (
        ::device::MacroDMX_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MacroDMX" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::MacroDMX > r (
        ::xsd::cxx::tree::traits< ::device::MacroDMX, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MacroDMX",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::MacroDMX >
  MacroDMX_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "MacroDMX" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::MacroDMX > r (
        ::xsd::cxx::tree::traits< ::device::MacroDMX, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MacroDMX",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXStep > (
      ::device::DMXStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXStep > (
      ::device::DMXStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXStep > (
      ::device::DMXStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXStep_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXStep_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXStep_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXStep_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXStep_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXStep_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXStep > (
      ::device::DMXStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXStep > (
      ::device::DMXStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXStep > (
      ::device::DMXStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::DMXStep > (
        ::device::DMXStep_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DMXStep" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXStep > r (
        ::xsd::cxx::tree::traits< ::device::DMXStep, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXStep",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXStep >
  DMXStep_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DMXStep" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXStep > r (
        ::xsd::cxx::tree::traits< ::device::DMXStep, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXStep",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXValue > (
      ::device::DMXValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXValue > (
      ::device::DMXValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXValue > (
      ::device::DMXValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXValue_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXValue_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXValue > (
      ::device::DMXValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXValue > (
      ::device::DMXValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXValue > (
      ::device::DMXValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::DMXValue > (
        ::device::DMXValue_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DMXValue" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXValue > r (
        ::xsd::cxx::tree::traits< ::device::DMXValue, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXValue",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXValue >
  DMXValue_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DMXValue" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXValue > r (
        ::xsd::cxx::tree::traits< ::device::DMXValue, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXValue",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::MacroVisual > (
      ::device::MacroVisual_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MacroVisual > (
      ::device::MacroVisual_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MacroVisual > (
      ::device::MacroVisual_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::MacroVisual_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::MacroVisual_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::MacroVisual_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::MacroVisual_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::MacroVisual_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::MacroVisual_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::MacroVisual > (
      ::device::MacroVisual_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MacroVisual > (
      ::device::MacroVisual_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MacroVisual > (
      ::device::MacroVisual_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::MacroVisual > (
        ::device::MacroVisual_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MacroVisual" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::MacroVisual > r (
        ::xsd::cxx::tree::traits< ::device::MacroVisual, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MacroVisual",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::MacroVisual >
  MacroVisual_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "MacroVisual" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::MacroVisual > r (
        ::xsd::cxx::tree::traits< ::device::MacroVisual, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MacroVisual",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::VisualStep > (
      ::device::VisualStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::VisualStep > (
      ::device::VisualStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::VisualStep > (
      ::device::VisualStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::VisualStep_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::VisualStep_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::VisualStep_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::VisualStep_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::VisualStep_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::VisualStep_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::VisualStep > (
      ::device::VisualStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::VisualStep > (
      ::device::VisualStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::VisualStep > (
      ::device::VisualStep_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::VisualStep > (
        ::device::VisualStep_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "VisualStep" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::VisualStep > r (
        ::xsd::cxx::tree::traits< ::device::VisualStep, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VisualStep",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::VisualStep >
  VisualStep_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "VisualStep" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::VisualStep > r (
        ::xsd::cxx::tree::traits< ::device::VisualStep, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VisualStep",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::VisualValue > (
      ::device::VisualValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::VisualValue > (
      ::device::VisualValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::VisualValue > (
      ::device::VisualValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::VisualValue_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::VisualValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::VisualValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::VisualValue_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::VisualValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::VisualValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::VisualValue > (
      ::device::VisualValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::VisualValue > (
      ::device::VisualValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::VisualValue > (
      ::device::VisualValue_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::VisualValue > (
        ::device::VisualValue_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "VisualValue" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::VisualValue > r (
        ::xsd::cxx::tree::traits< ::device::VisualValue, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VisualValue",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::VisualValue >
  VisualValue_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "VisualValue" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::VisualValue > r (
        ::xsd::cxx::tree::traits< ::device::VisualValue, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VisualValue",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::PhysicalDescriptions > (
      ::device::PhysicalDescriptions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::PhysicalDescriptions > (
      ::device::PhysicalDescriptions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::PhysicalDescriptions > (
      ::device::PhysicalDescriptions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::PhysicalDescriptions_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::PhysicalDescriptions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::PhysicalDescriptions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::PhysicalDescriptions_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::PhysicalDescriptions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::PhysicalDescriptions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::PhysicalDescriptions > (
      ::device::PhysicalDescriptions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::PhysicalDescriptions > (
      ::device::PhysicalDescriptions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::PhysicalDescriptions > (
      ::device::PhysicalDescriptions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::PhysicalDescriptions > (
        ::device::PhysicalDescriptions_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PhysicalDescriptions" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::PhysicalDescriptions > r (
        ::xsd::cxx::tree::traits< ::device::PhysicalDescriptions, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PhysicalDescriptions",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::PhysicalDescriptions >
  PhysicalDescriptions_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "PhysicalDescriptions" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::PhysicalDescriptions > r (
        ::xsd::cxx::tree::traits< ::device::PhysicalDescriptions, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PhysicalDescriptions",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Emitters > (
      ::device::Emitters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Emitters > (
      ::device::Emitters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Emitters > (
      ::device::Emitters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Emitters_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Emitters_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Emitters_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Emitters_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Emitters_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Emitters_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Emitters > (
      ::device::Emitters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Emitters > (
      ::device::Emitters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Emitters > (
      ::device::Emitters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Emitters > (
        ::device::Emitters_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Emitters" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Emitters > r (
        ::xsd::cxx::tree::traits< ::device::Emitters, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Emitters",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Emitters >
  Emitters_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Emitters" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Emitters > r (
        ::xsd::cxx::tree::traits< ::device::Emitters, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Emitters",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Emitter > (
      ::device::Emitter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Emitter > (
      ::device::Emitter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Emitter > (
      ::device::Emitter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Emitter_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Emitter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Emitter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Emitter_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Emitter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Emitter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Emitter > (
      ::device::Emitter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Emitter > (
      ::device::Emitter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Emitter > (
      ::device::Emitter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Emitter > (
        ::device::Emitter_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Emitter" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Emitter > r (
        ::xsd::cxx::tree::traits< ::device::Emitter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Emitter",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Emitter >
  Emitter_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Emitter" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Emitter > r (
        ::xsd::cxx::tree::traits< ::device::Emitter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Emitter",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Filters > (
      ::device::Filters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Filters > (
      ::device::Filters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Filters > (
      ::device::Filters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Filters_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Filters_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Filters_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Filters_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Filters_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Filters_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Filters > (
      ::device::Filters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Filters > (
      ::device::Filters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Filters > (
      ::device::Filters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Filters > (
        ::device::Filters_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Filters" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Filters > r (
        ::xsd::cxx::tree::traits< ::device::Filters, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Filters",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Filters >
  Filters_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Filters" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Filters > r (
        ::xsd::cxx::tree::traits< ::device::Filters, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Filters",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Filter > (
      ::device::Filter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Filter > (
      ::device::Filter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Filter > (
      ::device::Filter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Filter_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Filter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Filter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Filter_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Filter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Filter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Filter > (
      ::device::Filter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Filter > (
      ::device::Filter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Filter > (
      ::device::Filter_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Filter > (
        ::device::Filter_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Filter" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Filter > r (
        ::xsd::cxx::tree::traits< ::device::Filter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Filter",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Filter >
  Filter_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Filter" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Filter > r (
        ::xsd::cxx::tree::traits< ::device::Filter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Filter",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Measurement > (
      ::device::Measurement_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Measurement > (
      ::device::Measurement_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Measurement > (
      ::device::Measurement_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Measurement_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Measurement_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Measurement_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Measurement_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Measurement_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Measurement_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Measurement > (
      ::device::Measurement_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Measurement > (
      ::device::Measurement_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Measurement > (
      ::device::Measurement_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Measurement > (
        ::device::Measurement_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Measurement" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Measurement > r (
        ::xsd::cxx::tree::traits< ::device::Measurement, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Measurement",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Measurement >
  Measurement_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Measurement" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Measurement > r (
        ::xsd::cxx::tree::traits< ::device::Measurement, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Measurement",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::MeasurementPoint > (
      ::device::MeasurementPoint_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MeasurementPoint > (
      ::device::MeasurementPoint_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MeasurementPoint > (
      ::device::MeasurementPoint_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::MeasurementPoint_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::MeasurementPoint_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::MeasurementPoint_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::MeasurementPoint_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::MeasurementPoint_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::MeasurementPoint_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::MeasurementPoint > (
      ::device::MeasurementPoint_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MeasurementPoint > (
      ::device::MeasurementPoint_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::MeasurementPoint > (
      ::device::MeasurementPoint_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::MeasurementPoint > (
        ::device::MeasurementPoint_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MeasurementPoint" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::MeasurementPoint > r (
        ::xsd::cxx::tree::traits< ::device::MeasurementPoint, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MeasurementPoint",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::MeasurementPoint >
  MeasurementPoint_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "MeasurementPoint" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::MeasurementPoint > r (
        ::xsd::cxx::tree::traits< ::device::MeasurementPoint, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MeasurementPoint",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ColorSpace > (
      ::device::ColorSpace_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ColorSpace > (
      ::device::ColorSpace_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ColorSpace > (
      ::device::ColorSpace_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ColorSpace_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ColorSpace_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ColorSpace_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ColorSpace_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ColorSpace_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ColorSpace_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ColorSpace > (
      ::device::ColorSpace_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ColorSpace > (
      ::device::ColorSpace_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ColorSpace > (
      ::device::ColorSpace_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::ColorSpace > (
        ::device::ColorSpace_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ColorSpace" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ColorSpace > r (
        ::xsd::cxx::tree::traits< ::device::ColorSpace, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ColorSpace",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ColorSpace >
  ColorSpace_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ColorSpace" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ColorSpace > r (
        ::xsd::cxx::tree::traits< ::device::ColorSpace, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ColorSpace",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXProfiles > (
      ::device::DMXProfiles_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXProfiles > (
      ::device::DMXProfiles_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXProfiles > (
      ::device::DMXProfiles_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXProfiles_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXProfiles_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXProfiles_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXProfiles_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXProfiles_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXProfiles_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXProfiles > (
      ::device::DMXProfiles_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXProfiles > (
      ::device::DMXProfiles_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXProfiles > (
      ::device::DMXProfiles_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::DMXProfiles > (
        ::device::DMXProfiles_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DMXProfiles" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXProfiles > r (
        ::xsd::cxx::tree::traits< ::device::DMXProfiles, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXProfiles",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXProfiles >
  DMXProfiles_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DMXProfiles" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXProfiles > r (
        ::xsd::cxx::tree::traits< ::device::DMXProfiles, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXProfiles",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXProfile > (
      ::device::DMXProfile_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXProfile > (
      ::device::DMXProfile_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXProfile > (
      ::device::DMXProfile_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXProfile_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXProfile_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXProfile_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXProfile_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXProfile_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXProfile_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXProfile > (
      ::device::DMXProfile_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXProfile > (
      ::device::DMXProfile_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXProfile > (
      ::device::DMXProfile_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::DMXProfile > (
        ::device::DMXProfile_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DMXProfile" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXProfile > r (
        ::xsd::cxx::tree::traits< ::device::DMXProfile, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXProfile",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXProfile >
  DMXProfile_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DMXProfile" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXProfile > r (
        ::xsd::cxx::tree::traits< ::device::DMXProfile, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXProfile",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::CRIs > (
      ::device::CRIs_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CRIs > (
      ::device::CRIs_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CRIs > (
      ::device::CRIs_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::CRIs_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::CRIs_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::CRIs_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::CRIs_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::CRIs_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::CRIs_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::CRIs > (
      ::device::CRIs_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CRIs > (
      ::device::CRIs_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CRIs > (
      ::device::CRIs_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::CRIs > (
        ::device::CRIs_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CRIs" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::CRIs > r (
        ::xsd::cxx::tree::traits< ::device::CRIs, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CRIs",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::CRIs >
  CRIs_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "CRIs" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::CRIs > r (
        ::xsd::cxx::tree::traits< ::device::CRIs, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CRIs",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::CRI > (
      ::device::CRI_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CRI > (
      ::device::CRI_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CRI > (
      ::device::CRI_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::CRI_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::CRI_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::CRI_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::CRI_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::CRI_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::CRI_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::CRI > (
      ::device::CRI_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CRI > (
      ::device::CRI_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CRI > (
      ::device::CRI_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::CRI > (
        ::device::CRI_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CRI" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::CRI > r (
        ::xsd::cxx::tree::traits< ::device::CRI, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CRI",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::CRI >
  CRI_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "CRI" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::CRI > r (
        ::xsd::cxx::tree::traits< ::device::CRI, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CRI",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Protocols > (
      ::device::Protocols_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Protocols > (
      ::device::Protocols_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Protocols > (
      ::device::Protocols_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Protocols_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Protocols_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Protocols_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Protocols_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Protocols_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Protocols_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Protocols > (
      ::device::Protocols_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Protocols > (
      ::device::Protocols_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Protocols > (
      ::device::Protocols_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Protocols > (
        ::device::Protocols_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Protocols" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Protocols > r (
        ::xsd::cxx::tree::traits< ::device::Protocols, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Protocols",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Protocols >
  Protocols_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Protocols" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Protocols > r (
        ::xsd::cxx::tree::traits< ::device::Protocols, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Protocols",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Art_Net > (
      ::device::Art_Net_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Art_Net > (
      ::device::Art_Net_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Art_Net > (
      ::device::Art_Net_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Art_Net_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Art_Net_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Art_Net_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Art_Net_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Art_Net_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Art_Net_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Art_Net > (
      ::device::Art_Net_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Art_Net > (
      ::device::Art_Net_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Art_Net > (
      ::device::Art_Net_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Art_Net > (
        ::device::Art_Net_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Art-Net" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Art_Net > r (
        ::xsd::cxx::tree::traits< ::device::Art_Net, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Art-Net",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Art_Net >
  Art_Net_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Art-Net" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Art_Net > r (
        ::xsd::cxx::tree::traits< ::device::Art_Net, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Art-Net",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::sACN > (
      ::device::sACN_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::sACN > (
      ::device::sACN_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::sACN > (
      ::device::sACN_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::sACN_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::sACN_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::sACN_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::sACN_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::sACN_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::sACN_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::sACN > (
      ::device::sACN_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::sACN > (
      ::device::sACN_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::sACN > (
      ::device::sACN_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::sACN > (
        ::device::sACN_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "sACN" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::sACN > r (
        ::xsd::cxx::tree::traits< ::device::sACN, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "sACN",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::sACN >
  sACN_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "sACN" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::sACN > r (
        ::xsd::cxx::tree::traits< ::device::sACN, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "sACN",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::KiNET > (
      ::device::KiNET_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::KiNET > (
      ::device::KiNET_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::KiNET > (
      ::device::KiNET_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::KiNET_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::KiNET_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::KiNET_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::KiNET_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::KiNET_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::KiNET_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::KiNET > (
      ::device::KiNET_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::KiNET > (
      ::device::KiNET_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::KiNET > (
      ::device::KiNET_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::KiNET > (
        ::device::KiNET_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "KiNET" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::KiNET > r (
        ::xsd::cxx::tree::traits< ::device::KiNET, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "KiNET",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::KiNET >
  KiNET_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "KiNET" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::KiNET > r (
        ::xsd::cxx::tree::traits< ::device::KiNET, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "KiNET",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::PosiStageNet > (
      ::device::PosiStageNet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::PosiStageNet > (
      ::device::PosiStageNet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::PosiStageNet > (
      ::device::PosiStageNet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::PosiStageNet_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::PosiStageNet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::PosiStageNet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::PosiStageNet_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::PosiStageNet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::PosiStageNet_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::PosiStageNet > (
      ::device::PosiStageNet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::PosiStageNet > (
      ::device::PosiStageNet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::PosiStageNet > (
      ::device::PosiStageNet_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::PosiStageNet > (
        ::device::PosiStageNet_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PosiStageNet" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::PosiStageNet > r (
        ::xsd::cxx::tree::traits< ::device::PosiStageNet, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PosiStageNet",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::PosiStageNet >
  PosiStageNet_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "PosiStageNet" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::PosiStageNet > r (
        ::xsd::cxx::tree::traits< ::device::PosiStageNet, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PosiStageNet",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::OpenSoundControl > (
      ::device::OpenSoundControl_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::OpenSoundControl > (
      ::device::OpenSoundControl_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::OpenSoundControl > (
      ::device::OpenSoundControl_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::OpenSoundControl_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::OpenSoundControl_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::OpenSoundControl_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::OpenSoundControl_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::OpenSoundControl_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::OpenSoundControl_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::OpenSoundControl > (
      ::device::OpenSoundControl_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::OpenSoundControl > (
      ::device::OpenSoundControl_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::OpenSoundControl > (
      ::device::OpenSoundControl_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::OpenSoundControl > (
        ::device::OpenSoundControl_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "OpenSoundControl" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::OpenSoundControl > r (
        ::xsd::cxx::tree::traits< ::device::OpenSoundControl, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "OpenSoundControl",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::OpenSoundControl >
  OpenSoundControl_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "OpenSoundControl" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::OpenSoundControl > r (
        ::xsd::cxx::tree::traits< ::device::OpenSoundControl, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "OpenSoundControl",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::CITP > (
      ::device::CITP_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CITP > (
      ::device::CITP_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CITP > (
      ::device::CITP_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::CITP_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::CITP_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::CITP_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::CITP_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::CITP_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::CITP_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::CITP > (
      ::device::CITP_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CITP > (
      ::device::CITP_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::CITP > (
      ::device::CITP_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::CITP > (
        ::device::CITP_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CITP" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::CITP > r (
        ::xsd::cxx::tree::traits< ::device::CITP, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CITP",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::CITP >
  CITP_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "CITP" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::CITP > r (
        ::xsd::cxx::tree::traits< ::device::CITP, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CITP",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::RDM > (
      ::device::RDM_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::RDM > (
      ::device::RDM_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::RDM > (
      ::device::RDM_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::RDM_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::RDM_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::RDM_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::RDM_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::RDM_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::RDM_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::RDM > (
      ::device::RDM_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::RDM > (
      ::device::RDM_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::RDM > (
      ::device::RDM_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::RDM > (
        ::device::RDM_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "RDM" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::RDM > r (
        ::xsd::cxx::tree::traits< ::device::RDM, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RDM",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::RDM >
  RDM_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "RDM" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::RDM > r (
        ::xsd::cxx::tree::traits< ::device::RDM, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "RDM",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::SoftwareVersionID > (
      ::device::SoftwareVersionID_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::SoftwareVersionID > (
      ::device::SoftwareVersionID_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::SoftwareVersionID > (
      ::device::SoftwareVersionID_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::SoftwareVersionID_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::SoftwareVersionID_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::SoftwareVersionID_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::SoftwareVersionID_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::SoftwareVersionID_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::SoftwareVersionID_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::SoftwareVersionID > (
      ::device::SoftwareVersionID_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::SoftwareVersionID > (
      ::device::SoftwareVersionID_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::SoftwareVersionID > (
      ::device::SoftwareVersionID_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::SoftwareVersionID > (
        ::device::SoftwareVersionID_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SoftwareVersionID" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::SoftwareVersionID > r (
        ::xsd::cxx::tree::traits< ::device::SoftwareVersionID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SoftwareVersionID",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::SoftwareVersionID >
  SoftwareVersionID_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SoftwareVersionID" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::SoftwareVersionID > r (
        ::xsd::cxx::tree::traits< ::device::SoftwareVersionID, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SoftwareVersionID",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXPersonality > (
      ::device::DMXPersonality_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXPersonality > (
      ::device::DMXPersonality_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXPersonality > (
      ::device::DMXPersonality_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXPersonality_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXPersonality_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::DMXPersonality_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXPersonality_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXPersonality_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::DMXPersonality_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::DMXPersonality > (
      ::device::DMXPersonality_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXPersonality > (
      ::device::DMXPersonality_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::DMXPersonality > (
      ::device::DMXPersonality_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::DMXPersonality > (
        ::device::DMXPersonality_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DMXPersonality" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXPersonality > r (
        ::xsd::cxx::tree::traits< ::device::DMXPersonality, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXPersonality",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::DMXPersonality >
  DMXPersonality_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DMXPersonality" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::DMXPersonality > r (
        ::xsd::cxx::tree::traits< ::device::DMXPersonality, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DMXPersonality",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::AttributeDefinitions > (
      ::device::AttributeDefinitions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::AttributeDefinitions > (
      ::device::AttributeDefinitions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::AttributeDefinitions > (
      ::device::AttributeDefinitions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::AttributeDefinitions_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::AttributeDefinitions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::AttributeDefinitions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::AttributeDefinitions_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::AttributeDefinitions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::AttributeDefinitions_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::AttributeDefinitions > (
      ::device::AttributeDefinitions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::AttributeDefinitions > (
      ::device::AttributeDefinitions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::AttributeDefinitions > (
      ::device::AttributeDefinitions_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::AttributeDefinitions > (
        ::device::AttributeDefinitions_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "AttributeDefinitions" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::AttributeDefinitions > r (
        ::xsd::cxx::tree::traits< ::device::AttributeDefinitions, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AttributeDefinitions",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::AttributeDefinitions >
  AttributeDefinitions_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "AttributeDefinitions" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::AttributeDefinitions > r (
        ::xsd::cxx::tree::traits< ::device::AttributeDefinitions, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AttributeDefinitions",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ActivationGroups > (
      ::device::ActivationGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ActivationGroups > (
      ::device::ActivationGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ActivationGroups > (
      ::device::ActivationGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ActivationGroups_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ActivationGroups_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ActivationGroups_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ActivationGroups_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ActivationGroups_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ActivationGroups_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ActivationGroups > (
      ::device::ActivationGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ActivationGroups > (
      ::device::ActivationGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ActivationGroups > (
      ::device::ActivationGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::ActivationGroups > (
        ::device::ActivationGroups_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ActivationGroups" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ActivationGroups > r (
        ::xsd::cxx::tree::traits< ::device::ActivationGroups, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ActivationGroups",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ActivationGroups >
  ActivationGroups_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ActivationGroups" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ActivationGroups > r (
        ::xsd::cxx::tree::traits< ::device::ActivationGroups, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ActivationGroups",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FeatureGroups > (
      ::device::FeatureGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FeatureGroups > (
      ::device::FeatureGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FeatureGroups > (
      ::device::FeatureGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FeatureGroups_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FeatureGroups_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FeatureGroups_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FeatureGroups_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FeatureGroups_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FeatureGroups_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FeatureGroups > (
      ::device::FeatureGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FeatureGroups > (
      ::device::FeatureGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FeatureGroups > (
      ::device::FeatureGroups_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FeatureGroups > (
        ::device::FeatureGroups_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FeatureGroups" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FeatureGroups > r (
        ::xsd::cxx::tree::traits< ::device::FeatureGroups, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FeatureGroups",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FeatureGroups >
  FeatureGroups_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FeatureGroups" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FeatureGroups > r (
        ::xsd::cxx::tree::traits< ::device::FeatureGroups, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FeatureGroups",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ActivationGroup > (
      ::device::ActivationGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ActivationGroup > (
      ::device::ActivationGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ActivationGroup > (
      ::device::ActivationGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ActivationGroup_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ActivationGroup_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::ActivationGroup_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ActivationGroup_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ActivationGroup_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::ActivationGroup_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::ActivationGroup > (
      ::device::ActivationGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ActivationGroup > (
      ::device::ActivationGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::ActivationGroup > (
      ::device::ActivationGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::ActivationGroup > (
        ::device::ActivationGroup_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ActivationGroup" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ActivationGroup > r (
        ::xsd::cxx::tree::traits< ::device::ActivationGroup, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ActivationGroup",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::ActivationGroup >
  ActivationGroup_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ActivationGroup" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::ActivationGroup > r (
        ::xsd::cxx::tree::traits< ::device::ActivationGroup, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ActivationGroup",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FeatureGroup > (
      ::device::FeatureGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FeatureGroup > (
      ::device::FeatureGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FeatureGroup > (
      ::device::FeatureGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FeatureGroup_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FeatureGroup_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::FeatureGroup_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FeatureGroup_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FeatureGroup_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::FeatureGroup_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::FeatureGroup > (
      ::device::FeatureGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FeatureGroup > (
      ::device::FeatureGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::FeatureGroup > (
      ::device::FeatureGroup_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::FeatureGroup > (
        ::device::FeatureGroup_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "FeatureGroup" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FeatureGroup > r (
        ::xsd::cxx::tree::traits< ::device::FeatureGroup, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FeatureGroup",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::FeatureGroup >
  FeatureGroup_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "FeatureGroup" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::FeatureGroup > r (
        ::xsd::cxx::tree::traits< ::device::FeatureGroup, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "FeatureGroup",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Feature > (
      ::device::Feature_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Feature > (
      ::device::Feature_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Feature > (
      ::device::Feature_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Feature_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Feature_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Feature_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Feature_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Feature_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Feature_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Feature > (
      ::device::Feature_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Feature > (
      ::device::Feature_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Feature > (
      ::device::Feature_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Feature > (
        ::device::Feature_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Feature" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Feature > r (
        ::xsd::cxx::tree::traits< ::device::Feature, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Feature",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Feature >
  Feature_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Feature" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Feature > r (
        ::xsd::cxx::tree::traits< ::device::Feature, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Feature",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Attributes > (
      ::device::Attributes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Attributes > (
      ::device::Attributes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Attributes > (
      ::device::Attributes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Attributes_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Attributes_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Attributes_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Attributes_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Attributes_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Attributes_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Attributes > (
      ::device::Attributes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Attributes > (
      ::device::Attributes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Attributes > (
      ::device::Attributes_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Attributes > (
        ::device::Attributes_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Attributes" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Attributes > r (
        ::xsd::cxx::tree::traits< ::device::Attributes, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Attributes",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Attributes >
  Attributes_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Attributes" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Attributes > r (
        ::xsd::cxx::tree::traits< ::device::Attributes, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Attributes",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Attribute > (
      ::device::Attribute_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Attribute > (
      ::device::Attribute_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Attribute > (
      ::device::Attribute_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Attribute_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Attribute_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::device::Attribute_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Attribute_ (isrc, f, p);
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Attribute_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::device::Attribute_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::device::Attribute > (
      ::device::Attribute_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Attribute > (
      ::device::Attribute_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::device::Attribute > (
      ::device::Attribute_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::device::Attribute > (
        ::device::Attribute_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Attribute" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Attribute > r (
        ::xsd::cxx::tree::traits< ::device::Attribute, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Attribute",
      "http://schemas.gdtf-share.com/device");
  }

  ::std::unique_ptr< ::device::Attribute >
  Attribute_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Attribute" &&
        n.namespace_ () == "http://schemas.gdtf-share.com/device")
    {
      ::std::unique_ptr< ::device::Attribute > r (
        ::xsd::cxx::tree::traits< ::device::Attribute, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Attribute",
      "http://schemas.gdtf-share.com/device");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

